type token =
    TK_WHILE
  | TK_VAR
  | TK_SUB
  | TK_STR of string
  | TK_SKIP
  | TK_SEMICOLON
  | TK_RPAREN
  | TK_RBRACE
  | TK_NEQ
  | TK_NAT of int
  | TK_MUL
  | TK_LST
  | TK_LPAREN
  | TK_LEQ
  | TK_LBRACE
  | TK_INC
  | TK_IF
  | TK_GST
  | TK_GEQ
  | TK_FOR
  | TK_EQ
  | TK_EOF
  | TK_ELSE
  | TK_DIV
  | TK_DEC
  | TK_COMMA
  | TK_ASSIGN
  | TK_ASSERT
  | TK_ADD
type condition = Guard of Command.Predicate.t | NonDet
type instruction =
    Assignment of string * Command.Expression.t
  | IfThenElse of condition * statement * statement option
  | WhileLoop of condition * statement
  | Block of statement list
  | Skip
  | Assertion of condition
and statement = Lexing.position * instruction
val location_of_position : Lexing.position -> string
val assertion_failure_loc : string
val process_statement :
  string * (string * (Command.t * string) list) list ->
  statement -> string * (string * (Command.t * string) list) list
val output :
  'a ->
  'b ->
  statement ->
  Lexing.position ->
  'a * 'b * string * string * (string * (Command.t * string) list) list
val menhir_begin_marker : int
val xv_whileloop : statement
val xv_variables : string list
val xv_statement : statement
val xv_skip : statement
val xv_separated_nonempty_list_TK_COMMA_assignment_ : statement list
val xv_separated_nonempty_list_TK_COMMA_TK_STR_ : string list
val xv_separated_list_TK_COMMA_assignment_ : statement list
val xv_relop : Command.Predicate.op
val xv_main :
  string * string list * string * string *
  (string * (Command.t * string) list) list
val xv_loption_separated_nonempty_list_TK_COMMA_assignment__ : statement list
val xv_list_variables_ : string list list
val xv_list_statement_ : statement list
val xv_ifthenelse : statement
val xv_funop : Command.Expression.op
val xv_forloop : statement
val xv_expression : Command.Expression.t
val xv_condition : condition
val xv_block : statement
val xv_assignments : statement
val xv_assignment : statement
val xv_assertion : statement
val menhir_end_marker : int
