####################
# Forward Analysis #
####################

=============================
aut/another_example.aut with bound 5
=============================
Automaton:
   Another_Example
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 3 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x > y » q_3
      » x < 0 » q_bad
   q_3
      » y := (y + x) » q_4
   q_4
      » x := (x - 1) » q_2

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0) (= x$ 3) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1) (= y$ 0) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (> x y)
         (= x x$)
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (< x 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (+ y x))
         (= x x$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_4)
         (= x$ (- x 1))
         (= y y$)
         (= state$ q_2)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/another_example.aut with bound 25
=============================
Automaton:
   Another_Example
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 3 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x > y » q_3
      » x < 0 » q_bad
   q_3
      » y := (y + x) » q_4
   q_4
      » x := (x - 1) » q_2

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0) (= x$ 3) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1) (= y$ 0) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (> x y)
         (= x x$)
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (< x 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (+ y x))
         (= x x$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_4)
         (= x$ (- x 1))
         (= y y$)
         (= state$ q_2)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/another_example.aut with bound 100
=============================
Automaton:
   Another_Example
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 3 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x > y » q_3
      » x < 0 » q_bad
   q_3
      » y := (y + x) » q_4
   q_4
      » x := (x - 1) » q_2

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0) (= x$ 3) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1) (= y$ 0) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (> x y)
         (= x x$)
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (< x 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (+ y x))
         (= x x$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_4)
         (= x$ (- x 1))
         (= y y$)
         (= state$ q_2)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/big_integers.aut with bound 5
=============================
Automaton:
   Big_Integers
4 variables:
   max_int, min_int, y, z
8 locations:
   q_0, q_1, q_2, q_bad, q_y_large, q_y_small, q_z_large, q_z_small
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » max_int := 4611686018427387903 » q_1
   q_1
      » min_int := (-4611686018427387903 - 1) » q_2
   q_2
      » y := (max_int + 1) » q_y_large
      » z := (2 * max_int) » q_z_large
      » y := (min_int - 1) » q_y_small
      » z := (2 * min_int) » q_z_small
   q_y_large
      » y <= max_int » q_bad
   q_y_small
      » y >= min_int » q_bad
   q_z_large
      » z <= max_int » q_bad
   q_z_small
      » z >= min_int » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0)
         (= max_int$ 4611686018427387903)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1)
         (= min_int$ (- (- 4611686018427387903) 1))
         (= max_int max_int$)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (= y$ (+ max_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_y_large)
         (= transition$ |2|))
    (and (= state q_2)
         (= z$ (* 2 max_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_z_large)
         (= transition$ |3|))
    (and (= state q_2)
         (= y$ (- min_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_y_small)
         (= transition$ |4|))
    (and (= state q_2)
         (= z$ (* 2 min_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_z_small)
         (= transition$ |5|))
    (and (= state q_y_large)
         (<= y max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |6|))
    (and (= state q_y_small)
         (>= y min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |7|))
    (and (= state q_z_large)
         (<= z max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |8|))
    (and (= state q_z_small)
         (>= z min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |9|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/big_integers.aut with bound 25
=============================
Automaton:
   Big_Integers
4 variables:
   max_int, min_int, y, z
8 locations:
   q_0, q_1, q_2, q_bad, q_y_large, q_y_small, q_z_large, q_z_small
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » max_int := 4611686018427387903 » q_1
   q_1
      » min_int := (-4611686018427387903 - 1) » q_2
   q_2
      » y := (max_int + 1) » q_y_large
      » z := (2 * max_int) » q_z_large
      » y := (min_int - 1) » q_y_small
      » z := (2 * min_int) » q_z_small
   q_y_large
      » y <= max_int » q_bad
   q_y_small
      » y >= min_int » q_bad
   q_z_large
      » z <= max_int » q_bad
   q_z_small
      » z >= min_int » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0)
         (= max_int$ 4611686018427387903)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1)
         (= min_int$ (- (- 4611686018427387903) 1))
         (= max_int max_int$)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (= y$ (+ max_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_y_large)
         (= transition$ |2|))
    (and (= state q_2)
         (= z$ (* 2 max_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_z_large)
         (= transition$ |3|))
    (and (= state q_2)
         (= y$ (- min_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_y_small)
         (= transition$ |4|))
    (and (= state q_2)
         (= z$ (* 2 min_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_z_small)
         (= transition$ |5|))
    (and (= state q_y_large)
         (<= y max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |6|))
    (and (= state q_y_small)
         (>= y min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |7|))
    (and (= state q_z_large)
         (<= z max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |8|))
    (and (= state q_z_small)
         (>= z min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |9|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/big_integers.aut with bound 100
=============================
Automaton:
   Big_Integers
4 variables:
   max_int, min_int, y, z
8 locations:
   q_0, q_1, q_2, q_bad, q_y_large, q_y_small, q_z_large, q_z_small
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » max_int := 4611686018427387903 » q_1
   q_1
      » min_int := (-4611686018427387903 - 1) » q_2
   q_2
      » y := (max_int + 1) » q_y_large
      » z := (2 * max_int) » q_z_large
      » y := (min_int - 1) » q_y_small
      » z := (2 * min_int) » q_z_small
   q_y_large
      » y <= max_int » q_bad
   q_y_small
      » y >= min_int » q_bad
   q_z_large
      » z <= max_int » q_bad
   q_z_small
      » z >= min_int » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0)
         (= max_int$ 4611686018427387903)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1)
         (= min_int$ (- (- 4611686018427387903) 1))
         (= max_int max_int$)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (= y$ (+ max_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_y_large)
         (= transition$ |2|))
    (and (= state q_2)
         (= z$ (* 2 max_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_z_large)
         (= transition$ |3|))
    (and (= state q_2)
         (= y$ (- min_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_y_small)
         (= transition$ |4|))
    (and (= state q_2)
         (= z$ (* 2 min_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_z_small)
         (= transition$ |5|))
    (and (= state q_y_large)
         (<= y max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |6|))
    (and (= state q_y_small)
         (>= y min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |7|))
    (and (= state q_z_large)
         (<= z max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |8|))
    (and (= state q_z_small)
         (>= z min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |9|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/congruence_1.aut with bound 5
=============================
Automaton:
   Congruence_1
3 variables:
   x, y, z
10 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := 5 » q_02
   q_02
      » x != 5 » q_bad
      » x < 2 » q_bad
      » x <= 3 » q_bad
      » x >= 7 » q_bad
      » x > 8 » q_bad
      » (x + 8) != 13 » q_bad
      » (x - 8) != -3 » q_bad
      » (0 * x) != 0 » q_bad
      » (x * 3) != 15 » q_bad
      » (x / 2) != 2 » q_bad
      » (x / 3) != 1 » q_bad
      » (2 / x) != 0 » q_bad
      » (-7 / x) != -1 » q_bad
      » (x * y) == 18 » q_bad
      » (x * y) == 15 » q_03
   q_03
      » (y * z) == x » q_bad
      » ((y * z) - x) == y » q_bad
      » z := (x + y) » q_04
      » z := (y + x) » q_04
      » z == (x + y) » q_04
      » z := (x - y) » q_05
      » x == (y + z) » q_05
      » z := (y - x) » q_06
      » (x + z) == y » q_06
      » z := (x * y) » q_07
      » z := (y * x) » q_07
      » z := (x / y) » q_08
      » z := (y / x) » q_09
   q_04
      » z == (x - y) » q_bad
      » ((x * y) * z) <= ((x + y) + z) » q_bad
      » (z / x) > y » q_bad
   q_05
      » ((x + y) + z) != 10 » q_bad
      » ((x * y) * z) != 30 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and (= state q_02)
                (not (= (+ x 8) 13))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |6|)))
      (a!2 (and (= state q_02)
                (not (= (- x 8) (- 3)))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |7|)))
      (a!3 (and (= state q_02)
                (not (= (* 0 x) 0))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |8|)))
      (a!4 (and (= state q_02)
                (not (= (* x 3) 15))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |9|)))
      (a!5 (ite (>= x 0) (div x 2) (- (div (- x) 2))))
      (a!6 (ite (>= x 0) (div x 3) (- (div (- x) 3))))
      (a!7 (ite (>= 2 0) (div 2 x) (- (div (- 2) x))))
      (a!8 (ite (>= (- 7) 0) (div (- 7) x) (- (div (- (- 7)) x))))
      (a!9 (and (= state q_03)
                (= (- (* y z) x) y)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |17|)))
      (a!10 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!11 (ite (>= y 0) (div y x) (- (div (- y) x))))
      (a!12 (and (= state q_04)
                 (<= (* (* x y) z) (+ (+ x y) z))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_bad)
                 (= transition$ |30|)))
      (a!13 (ite (>= z 0) (div z x) (- (div (- z) x))))
      (a!14 (not (= (+ (+ x y) z) 10)))
      (a!15 (not (= (* (* x y) z) 30))))
  (or (and (= state q_01)
           (= x$ 5)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_02)
           (not (= x 5))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |1|))
      (and (= state q_02)
           (< x 2)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |2|))
      (and (= state q_02)
           (<= x 3)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |3|))
      (and (= state q_02)
           (>= x 7)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |4|))
      (and (= state q_02)
           (> x 8)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |5|))
      a!1
      a!2
      a!3
      a!4
      (and (= state q_02)
           (not (= 2 0))
           (not (= a!5 2))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |10|))
      (and (= state q_02)
           (not (= 3 0))
           (not (= a!6 1))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |11|))
      (and (= state q_02)
           (not (= x 0))
           (not (= a!7 0))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |12|))
      (and (= state q_02)
           (not (= x 0))
           (not (= a!8 (- 1)))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |13|))
      (and (= state q_02)
           (= (* x y) 18)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |14|))
      (and (= state q_02)
           (= (* x y) 15)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |15|))
      (and (= state q_03)
           (= (* y z) x)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |16|))
      a!9
      (and (= state q_03)
           (= z$ (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_04)
           (= transition$ |18|))
      (and (= state q_03)
           (= z$ (+ y x))
           (= x x$)
           (= y y$)
           (= state$ q_04)
           (= transition$ |19|))
      (and (= state q_03)
           (= z (+ x y))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |20|))
      (and (= state q_03)
           (= z$ (- x y))
           (= x x$)
           (= y y$)
           (= state$ q_05)
           (= transition$ |21|))
      (and (= state q_03)
           (= x (+ y z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |22|))
      (and (= state q_03)
           (= z$ (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_06)
           (= transition$ |23|))
      (and (= state q_03)
           (= (+ x z) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_06)
           (= transition$ |24|))
      (and (= state q_03)
           (= z$ (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |25|))
      (and (= state q_03)
           (= z$ (* y x))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |26|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!10)
           (= x x$)
           (= y y$)
           (= state$ q_08)
           (= transition$ |27|))
      (and (= state q_03)
           (not (= x 0))
           (= z$ a!11)
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |28|))
      (and (= state q_04)
           (= z (- x y))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |29|))
      a!12
      (and (= state q_04)
           (not (= x 0))
           (> a!13 y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |31|))
      (and (= state q_05)
           a!14
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |32|))
      (and (= state q_05)
           a!15
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |33|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_01: No

=============================
aut/congruence_1.aut with bound 25
=============================
Automaton:
   Congruence_1
3 variables:
   x, y, z
10 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := 5 » q_02
   q_02
      » x != 5 » q_bad
      » x < 2 » q_bad
      » x <= 3 » q_bad
      » x >= 7 » q_bad
      » x > 8 » q_bad
      » (x + 8) != 13 » q_bad
      » (x - 8) != -3 » q_bad
      » (0 * x) != 0 » q_bad
      » (x * 3) != 15 » q_bad
      » (x / 2) != 2 » q_bad
      » (x / 3) != 1 » q_bad
      » (2 / x) != 0 » q_bad
      » (-7 / x) != -1 » q_bad
      » (x * y) == 18 » q_bad
      » (x * y) == 15 » q_03
   q_03
      » (y * z) == x » q_bad
      » ((y * z) - x) == y » q_bad
      » z := (x + y) » q_04
      » z := (y + x) » q_04
      » z == (x + y) » q_04
      » z := (x - y) » q_05
      » x == (y + z) » q_05
      » z := (y - x) » q_06
      » (x + z) == y » q_06
      » z := (x * y) » q_07
      » z := (y * x) » q_07
      » z := (x / y) » q_08
      » z := (y / x) » q_09
   q_04
      » z == (x - y) » q_bad
      » ((x * y) * z) <= ((x + y) + z) » q_bad
      » (z / x) > y » q_bad
   q_05
      » ((x + y) + z) != 10 » q_bad
      » ((x * y) * z) != 30 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and (= state q_02)
                (not (= (+ x 8) 13))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |6|)))
      (a!2 (and (= state q_02)
                (not (= (- x 8) (- 3)))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |7|)))
      (a!3 (and (= state q_02)
                (not (= (* 0 x) 0))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |8|)))
      (a!4 (and (= state q_02)
                (not (= (* x 3) 15))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |9|)))
      (a!5 (ite (>= x 0) (div x 2) (- (div (- x) 2))))
      (a!6 (ite (>= x 0) (div x 3) (- (div (- x) 3))))
      (a!7 (ite (>= 2 0) (div 2 x) (- (div (- 2) x))))
      (a!8 (ite (>= (- 7) 0) (div (- 7) x) (- (div (- (- 7)) x))))
      (a!9 (and (= state q_03)
                (= (- (* y z) x) y)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |17|)))
      (a!10 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!11 (ite (>= y 0) (div y x) (- (div (- y) x))))
      (a!12 (and (= state q_04)
                 (<= (* (* x y) z) (+ (+ x y) z))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_bad)
                 (= transition$ |30|)))
      (a!13 (ite (>= z 0) (div z x) (- (div (- z) x))))
      (a!14 (not (= (+ (+ x y) z) 10)))
      (a!15 (not (= (* (* x y) z) 30))))
  (or (and (= state q_01)
           (= x$ 5)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_02)
           (not (= x 5))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |1|))
      (and (= state q_02)
           (< x 2)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |2|))
      (and (= state q_02)
           (<= x 3)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |3|))
      (and (= state q_02)
           (>= x 7)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |4|))
      (and (= state q_02)
           (> x 8)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |5|))
      a!1
      a!2
      a!3
      a!4
      (and (= state q_02)
           (not (= 2 0))
           (not (= a!5 2))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |10|))
      (and (= state q_02)
           (not (= 3 0))
           (not (= a!6 1))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |11|))
      (and (= state q_02)
           (not (= x 0))
           (not (= a!7 0))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |12|))
      (and (= state q_02)
           (not (= x 0))
           (not (= a!8 (- 1)))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |13|))
      (and (= state q_02)
           (= (* x y) 18)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |14|))
      (and (= state q_02)
           (= (* x y) 15)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |15|))
      (and (= state q_03)
           (= (* y z) x)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |16|))
      a!9
      (and (= state q_03)
           (= z$ (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_04)
           (= transition$ |18|))
      (and (= state q_03)
           (= z$ (+ y x))
           (= x x$)
           (= y y$)
           (= state$ q_04)
           (= transition$ |19|))
      (and (= state q_03)
           (= z (+ x y))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |20|))
      (and (= state q_03)
           (= z$ (- x y))
           (= x x$)
           (= y y$)
           (= state$ q_05)
           (= transition$ |21|))
      (and (= state q_03)
           (= x (+ y z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |22|))
      (and (= state q_03)
           (= z$ (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_06)
           (= transition$ |23|))
      (and (= state q_03)
           (= (+ x z) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_06)
           (= transition$ |24|))
      (and (= state q_03)
           (= z$ (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |25|))
      (and (= state q_03)
           (= z$ (* y x))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |26|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!10)
           (= x x$)
           (= y y$)
           (= state$ q_08)
           (= transition$ |27|))
      (and (= state q_03)
           (not (= x 0))
           (= z$ a!11)
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |28|))
      (and (= state q_04)
           (= z (- x y))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |29|))
      a!12
      (and (= state q_04)
           (not (= x 0))
           (> a!13 y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |31|))
      (and (= state q_05)
           a!14
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |32|))
      (and (= state q_05)
           a!15
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |33|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_01: No

=============================
aut/congruence_1.aut with bound 100
=============================
Automaton:
   Congruence_1
3 variables:
   x, y, z
10 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := 5 » q_02
   q_02
      » x != 5 » q_bad
      » x < 2 » q_bad
      » x <= 3 » q_bad
      » x >= 7 » q_bad
      » x > 8 » q_bad
      » (x + 8) != 13 » q_bad
      » (x - 8) != -3 » q_bad
      » (0 * x) != 0 » q_bad
      » (x * 3) != 15 » q_bad
      » (x / 2) != 2 » q_bad
      » (x / 3) != 1 » q_bad
      » (2 / x) != 0 » q_bad
      » (-7 / x) != -1 » q_bad
      » (x * y) == 18 » q_bad
      » (x * y) == 15 » q_03
   q_03
      » (y * z) == x » q_bad
      » ((y * z) - x) == y » q_bad
      » z := (x + y) » q_04
      » z := (y + x) » q_04
      » z == (x + y) » q_04
      » z := (x - y) » q_05
      » x == (y + z) » q_05
      » z := (y - x) » q_06
      » (x + z) == y » q_06
      » z := (x * y) » q_07
      » z := (y * x) » q_07
      » z := (x / y) » q_08
      » z := (y / x) » q_09
   q_04
      » z == (x - y) » q_bad
      » ((x * y) * z) <= ((x + y) + z) » q_bad
      » (z / x) > y » q_bad
   q_05
      » ((x + y) + z) != 10 » q_bad
      » ((x * y) * z) != 30 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and (= state q_02)
                (not (= (+ x 8) 13))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |6|)))
      (a!2 (and (= state q_02)
                (not (= (- x 8) (- 3)))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |7|)))
      (a!3 (and (= state q_02)
                (not (= (* 0 x) 0))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |8|)))
      (a!4 (and (= state q_02)
                (not (= (* x 3) 15))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |9|)))
      (a!5 (ite (>= x 0) (div x 2) (- (div (- x) 2))))
      (a!6 (ite (>= x 0) (div x 3) (- (div (- x) 3))))
      (a!7 (ite (>= 2 0) (div 2 x) (- (div (- 2) x))))
      (a!8 (ite (>= (- 7) 0) (div (- 7) x) (- (div (- (- 7)) x))))
      (a!9 (and (= state q_03)
                (= (- (* y z) x) y)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |17|)))
      (a!10 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!11 (ite (>= y 0) (div y x) (- (div (- y) x))))
      (a!12 (and (= state q_04)
                 (<= (* (* x y) z) (+ (+ x y) z))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_bad)
                 (= transition$ |30|)))
      (a!13 (ite (>= z 0) (div z x) (- (div (- z) x))))
      (a!14 (not (= (+ (+ x y) z) 10)))
      (a!15 (not (= (* (* x y) z) 30))))
  (or (and (= state q_01)
           (= x$ 5)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_02)
           (not (= x 5))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |1|))
      (and (= state q_02)
           (< x 2)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |2|))
      (and (= state q_02)
           (<= x 3)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |3|))
      (and (= state q_02)
           (>= x 7)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |4|))
      (and (= state q_02)
           (> x 8)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |5|))
      a!1
      a!2
      a!3
      a!4
      (and (= state q_02)
           (not (= 2 0))
           (not (= a!5 2))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |10|))
      (and (= state q_02)
           (not (= 3 0))
           (not (= a!6 1))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |11|))
      (and (= state q_02)
           (not (= x 0))
           (not (= a!7 0))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |12|))
      (and (= state q_02)
           (not (= x 0))
           (not (= a!8 (- 1)))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |13|))
      (and (= state q_02)
           (= (* x y) 18)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |14|))
      (and (= state q_02)
           (= (* x y) 15)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |15|))
      (and (= state q_03)
           (= (* y z) x)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |16|))
      a!9
      (and (= state q_03)
           (= z$ (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_04)
           (= transition$ |18|))
      (and (= state q_03)
           (= z$ (+ y x))
           (= x x$)
           (= y y$)
           (= state$ q_04)
           (= transition$ |19|))
      (and (= state q_03)
           (= z (+ x y))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |20|))
      (and (= state q_03)
           (= z$ (- x y))
           (= x x$)
           (= y y$)
           (= state$ q_05)
           (= transition$ |21|))
      (and (= state q_03)
           (= x (+ y z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |22|))
      (and (= state q_03)
           (= z$ (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_06)
           (= transition$ |23|))
      (and (= state q_03)
           (= (+ x z) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_06)
           (= transition$ |24|))
      (and (= state q_03)
           (= z$ (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |25|))
      (and (= state q_03)
           (= z$ (* y x))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |26|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!10)
           (= x x$)
           (= y y$)
           (= state$ q_08)
           (= transition$ |27|))
      (and (= state q_03)
           (not (= x 0))
           (= z$ a!11)
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |28|))
      (and (= state q_04)
           (= z (- x y))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |29|))
      a!12
      (and (= state q_04)
           (not (= x 0))
           (> a!13 y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |31|))
      (and (= state q_05)
           a!14
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |32|))
      (and (= state q_05)
           a!15
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |33|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_01: No

=============================
aut/congruence_2.aut with bound 5
=============================
Automaton:
   Congruence_2
3 variables:
   x, y, z
14 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_10, q_11, 
   q_12, q_13, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := -9 » q_02
      » x := 3 » q_02
   q_02
      » y := 10 » q_03
      » y := 18 » q_03
   q_03
      » x := (x + 12) » q_03
      » x := ((x + (3 * y)) - 6) » q_03
      » y := (y - 8) » q_03
      » x == y » q_bad
      » (x - 1) == y » q_04
      » x == (6 * z) » q_bad
      » y == (4 * z) » q_bad
      » (x + y) == (2 * z) » q_bad
      » z := (x + y) » q_05
      » z := (y - x) » q_06
      » z := (x * y) » q_07
      » z := (x / y) » q_08
      » z := (5 / y) » q_09
      » z := (7 / (x - 1)) » q_10
   q_05
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_06
      » ((x + y) + z) == 2 » q_bad
      » ((x * y) * z) == 2 » q_bad
   q_07
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_08
      » (x * y) == 12 » q_bad
   q_09
      » z := (z + 2) » q_09
      » z == 1 » q_bad
   q_10
      » y == z » q_11
      » (x + y) == z » q_12
      » (x + (y * (1 + z))) == -1 » q_13

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (= x$ (- (+ x (* 3 y)) 6)))
      (a!2 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!3 (ite (>= 5 0) (div 5 y) (- (div (- 5) y))))
      (a!4 (ite (>= 7 0) (div 7 (- x 1)) (- (div (- 7) (- x 1)))))
      (a!6 (and (= (+ (+ x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!7 (and (= (* (* x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!8 (and (= state q_06)
                (= (+ (+ x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |20|)))
      (a!9 (and (= state q_06)
                (= (* (* x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |21|)))
      (a!10 (= (+ x (* y (+ 1 z))) (- 1))))
(let ((a!5 (and (= state q_03)
                (not (= (- x 1) 0))
                (= z$ a!4)
                (= x x$)
                (= y y$)
                (= state$ q_10)
                (= transition$ |17|))))
  (or (and (= state q_01)
           (= x$ (- 9))
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_01)
           (= x$ 3)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |1|))
      (and (= state q_02)
           (= y$ 10)
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |2|))
      (and (= state q_02)
           (= y$ 18)
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |3|))
      (and (= state q_03)
           (= x$ (+ x 12))
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |4|))
      (and (= state q_03)
           a!1
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |5|))
      (and (= state q_03)
           (= y$ (- y 8))
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |6|))
      (and (= state q_03)
           (= x y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |7|))
      (and (= state q_03)
           (= (- x 1) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |8|))
      (and (= state q_03)
           (= x (* 6 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |9|))
      (and (= state q_03)
           (= y (* 4 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |10|))
      (and (= state q_03)
           (= (+ x y) (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |11|))
      (and (= state q_03)
           (= z$ (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_05)
           (= transition$ |12|))
      (and (= state q_03)
           (= z$ (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_06)
           (= transition$ |13|))
      (and (= state q_03)
           (= z$ (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |14|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!2)
           (= x x$)
           (= y y$)
           (= state$ q_08)
           (= transition$ |15|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!3)
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |16|))
      a!5
      (and (= state q_05) a!6 (= state$ q_bad) (= transition$ |18|))
      (and (= state q_05) a!7 (= state$ q_bad) (= transition$ |19|))
      a!8
      a!9
      (and (= state q_07) a!6 (= state$ q_bad) (= transition$ |22|))
      (and (= state q_07) a!7 (= state$ q_bad) (= transition$ |23|))
      (and (= state q_08)
           (= (* x y) 12)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |24|))
      (and (= state q_09)
           (= z$ (+ z 2))
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |25|))
      (and (= state q_09)
           (= z 1)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |26|))
      (and (= state q_10)
           (= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_11)
           (= transition$ |27|))
      (and (= state q_10)
           (= (+ x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_12)
           (= transition$ |28|))
      (and (= state q_10)
           a!10
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_13)
           (= transition$ |29|)))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_01: Unknown

=============================
aut/congruence_2.aut with bound 25
=============================
Automaton:
   Congruence_2
3 variables:
   x, y, z
14 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_10, q_11, 
   q_12, q_13, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := -9 » q_02
      » x := 3 » q_02
   q_02
      » y := 10 » q_03
      » y := 18 » q_03
   q_03
      » x := (x + 12) » q_03
      » x := ((x + (3 * y)) - 6) » q_03
      » y := (y - 8) » q_03
      » x == y » q_bad
      » (x - 1) == y » q_04
      » x == (6 * z) » q_bad
      » y == (4 * z) » q_bad
      » (x + y) == (2 * z) » q_bad
      » z := (x + y) » q_05
      » z := (y - x) » q_06
      » z := (x * y) » q_07
      » z := (x / y) » q_08
      » z := (5 / y) » q_09
      » z := (7 / (x - 1)) » q_10
   q_05
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_06
      » ((x + y) + z) == 2 » q_bad
      » ((x * y) * z) == 2 » q_bad
   q_07
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_08
      » (x * y) == 12 » q_bad
   q_09
      » z := (z + 2) » q_09
      » z == 1 » q_bad
   q_10
      » y == z » q_11
      » (x + y) == z » q_12
      » (x + (y * (1 + z))) == -1 » q_13

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (= x$ (- (+ x (* 3 y)) 6)))
      (a!2 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!3 (ite (>= 5 0) (div 5 y) (- (div (- 5) y))))
      (a!4 (ite (>= 7 0) (div 7 (- x 1)) (- (div (- 7) (- x 1)))))
      (a!6 (and (= (+ (+ x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!7 (and (= (* (* x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!8 (and (= state q_06)
                (= (+ (+ x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |20|)))
      (a!9 (and (= state q_06)
                (= (* (* x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |21|)))
      (a!10 (= (+ x (* y (+ 1 z))) (- 1))))
(let ((a!5 (and (= state q_03)
                (not (= (- x 1) 0))
                (= z$ a!4)
                (= x x$)
                (= y y$)
                (= state$ q_10)
                (= transition$ |17|))))
  (or (and (= state q_01)
           (= x$ (- 9))
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_01)
           (= x$ 3)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |1|))
      (and (= state q_02)
           (= y$ 10)
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |2|))
      (and (= state q_02)
           (= y$ 18)
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |3|))
      (and (= state q_03)
           (= x$ (+ x 12))
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |4|))
      (and (= state q_03)
           a!1
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |5|))
      (and (= state q_03)
           (= y$ (- y 8))
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |6|))
      (and (= state q_03)
           (= x y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |7|))
      (and (= state q_03)
           (= (- x 1) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |8|))
      (and (= state q_03)
           (= x (* 6 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |9|))
      (and (= state q_03)
           (= y (* 4 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |10|))
      (and (= state q_03)
           (= (+ x y) (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |11|))
      (and (= state q_03)
           (= z$ (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_05)
           (= transition$ |12|))
      (and (= state q_03)
           (= z$ (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_06)
           (= transition$ |13|))
      (and (= state q_03)
           (= z$ (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |14|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!2)
           (= x x$)
           (= y y$)
           (= state$ q_08)
           (= transition$ |15|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!3)
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |16|))
      a!5
      (and (= state q_05) a!6 (= state$ q_bad) (= transition$ |18|))
      (and (= state q_05) a!7 (= state$ q_bad) (= transition$ |19|))
      a!8
      a!9
      (and (= state q_07) a!6 (= state$ q_bad) (= transition$ |22|))
      (and (= state q_07) a!7 (= state$ q_bad) (= transition$ |23|))
      (and (= state q_08)
           (= (* x y) 12)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |24|))
      (and (= state q_09)
           (= z$ (+ z 2))
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |25|))
      (and (= state q_09)
           (= z 1)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |26|))
      (and (= state q_10)
           (= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_11)
           (= transition$ |27|))
      (and (= state q_10)
           (= (+ x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_12)
           (= transition$ |28|))
      (and (= state q_10)
           a!10
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_13)
           (= transition$ |29|)))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.

=============================
aut/congruence_2.aut with bound 100
=============================
Automaton:
   Congruence_2
3 variables:
   x, y, z
14 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_10, q_11, 
   q_12, q_13, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := -9 » q_02
      » x := 3 » q_02
   q_02
      » y := 10 » q_03
      » y := 18 » q_03
   q_03
      » x := (x + 12) » q_03
      » x := ((x + (3 * y)) - 6) » q_03
      » y := (y - 8) » q_03
      » x == y » q_bad
      » (x - 1) == y » q_04
      » x == (6 * z) » q_bad
      » y == (4 * z) » q_bad
      » (x + y) == (2 * z) » q_bad
      » z := (x + y) » q_05
      » z := (y - x) » q_06
      » z := (x * y) » q_07
      » z := (x / y) » q_08
      » z := (5 / y) » q_09
      » z := (7 / (x - 1)) » q_10
   q_05
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_06
      » ((x + y) + z) == 2 » q_bad
      » ((x * y) * z) == 2 » q_bad
   q_07
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_08
      » (x * y) == 12 » q_bad
   q_09
      » z := (z + 2) » q_09
      » z == 1 » q_bad
   q_10
      » y == z » q_11
      » (x + y) == z » q_12
      » (x + (y * (1 + z))) == -1 » q_13

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (= x$ (- (+ x (* 3 y)) 6)))
      (a!2 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!3 (ite (>= 5 0) (div 5 y) (- (div (- 5) y))))
      (a!4 (ite (>= 7 0) (div 7 (- x 1)) (- (div (- 7) (- x 1)))))
      (a!6 (and (= (+ (+ x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!7 (and (= (* (* x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!8 (and (= state q_06)
                (= (+ (+ x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |20|)))
      (a!9 (and (= state q_06)
                (= (* (* x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_bad)
                (= transition$ |21|)))
      (a!10 (= (+ x (* y (+ 1 z))) (- 1))))
(let ((a!5 (and (= state q_03)
                (not (= (- x 1) 0))
                (= z$ a!4)
                (= x x$)
                (= y y$)
                (= state$ q_10)
                (= transition$ |17|))))
  (or (and (= state q_01)
           (= x$ (- 9))
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_01)
           (= x$ 3)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |1|))
      (and (= state q_02)
           (= y$ 10)
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |2|))
      (and (= state q_02)
           (= y$ 18)
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |3|))
      (and (= state q_03)
           (= x$ (+ x 12))
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |4|))
      (and (= state q_03)
           a!1
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |5|))
      (and (= state q_03)
           (= y$ (- y 8))
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |6|))
      (and (= state q_03)
           (= x y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |7|))
      (and (= state q_03)
           (= (- x 1) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |8|))
      (and (= state q_03)
           (= x (* 6 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |9|))
      (and (= state q_03)
           (= y (* 4 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |10|))
      (and (= state q_03)
           (= (+ x y) (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |11|))
      (and (= state q_03)
           (= z$ (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_05)
           (= transition$ |12|))
      (and (= state q_03)
           (= z$ (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_06)
           (= transition$ |13|))
      (and (= state q_03)
           (= z$ (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_07)
           (= transition$ |14|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!2)
           (= x x$)
           (= y y$)
           (= state$ q_08)
           (= transition$ |15|))
      (and (= state q_03)
           (not (= y 0))
           (= z$ a!3)
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |16|))
      a!5
      (and (= state q_05) a!6 (= state$ q_bad) (= transition$ |18|))
      (and (= state q_05) a!7 (= state$ q_bad) (= transition$ |19|))
      a!8
      a!9
      (and (= state q_07) a!6 (= state$ q_bad) (= transition$ |22|))
      (and (= state q_07) a!7 (= state$ q_bad) (= transition$ |23|))
      (and (= state q_08)
           (= (* x y) 12)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |24|))
      (and (= state q_09)
           (= z$ (+ z 2))
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |25|))
      (and (= state q_09)
           (= z 1)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_bad)
           (= transition$ |26|))
      (and (= state q_10)
           (= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_11)
           (= transition$ |27|))
      (and (= state q_10)
           (= (+ x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_12)
           (= transition$ |28|))
      (and (= state q_10)
           a!10
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_13)
           (= transition$ |29|)))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.

=============================
aut/constant_propagation.aut with bound 5
=============================
Automaton:
   Constant_Propagation
3 variables:
   x, y, z
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 1 » q_1
      » x := 2 » q_2
   q_1
      » y := 2 » q_3
   q_2
      » y := 1 » q_3
   q_3
      » z := (x + y) » q_4
   q_4
      » z != 3 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0)
         (= x$ 1)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_0)
         (= x$ 2)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_1)
         (= y$ 2)
         (= x x$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (= y$ 1)
         (= x x$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |3|))
    (and (= state q_3)
         (= z$ (+ x y))
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_4)
         (not (= z 3))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/constant_propagation.aut with bound 25
=============================
Automaton:
   Constant_Propagation
3 variables:
   x, y, z
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 1 » q_1
      » x := 2 » q_2
   q_1
      » y := 2 » q_3
   q_2
      » y := 1 » q_3
   q_3
      » z := (x + y) » q_4
   q_4
      » z != 3 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0)
         (= x$ 1)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_0)
         (= x$ 2)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_1)
         (= y$ 2)
         (= x x$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (= y$ 1)
         (= x x$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |3|))
    (and (= state q_3)
         (= z$ (+ x y))
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_4)
         (not (= z 3))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/constant_propagation.aut with bound 100
=============================
Automaton:
   Constant_Propagation
3 variables:
   x, y, z
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 1 » q_1
      » x := 2 » q_2
   q_1
      » y := 2 » q_3
   q_2
      » y := 1 » q_3
   q_3
      » z := (x + y) » q_4
   q_4
      » z != 3 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0)
         (= x$ 1)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_0)
         (= x$ 2)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_1)
         (= y$ 2)
         (= x x$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (= y$ 1)
         (= x x$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |3|))
    (and (= state q_3)
         (= z$ (+ x y))
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_4)
         (not (= z 3))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/division_by_zero.aut with bound 5
=============================
Automaton:
   Division_by_Zero
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_bad, q_bad'
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x <= (3 / 0) » q_bad'
      » x := -1 » q_1
      » x := (x / (y + 2)) » q_2
      » (x / y) > 3 » q_3
   q_1
      » y := (3 / (x + 1)) » q_bad'
   q_2
      » y == -2 » q_bad
   q_3
      » y == 0 » q_bad
   q_bad'
      » skip » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= 3 0) (div 3 0) (- (div (- 3) 0))))
      (a!2 (ite (>= x 0) (div x (+ y 2)) (- (div (- x) (+ y 2)))))
      (a!4 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!5 (ite (>= 3 0) (div 3 (+ x 1)) (- (div (- 3) (+ x 1))))))
(let ((a!3 (and (= state q_0)
                (not (= (+ y 2) 0))
                (= x$ a!2)
                (= y y$)
                (= state$ q_2)
                (= transition$ |2|)))
      (a!6 (and (= state q_1)
                (not (= (+ x 1) 0))
                (= y$ a!5)
                (= x x$)
                (= state$ |q_bad'|)
                (= transition$ |4|))))
  (or (and (= state q_0)
           (not (= 0 0))
           (<= x a!1)
           (= x x$)
           (= y y$)
           (= state$ |q_bad'|)
           (= transition$ |0|))
      (and (= state q_0)
           (= x$ (- 1))
           (= y y$)
           (= state$ q_1)
           (= transition$ |1|))
      a!3
      (and (= state q_0)
           (not (= y 0))
           (> a!4 3)
           (= x x$)
           (= y y$)
           (= state$ q_3)
           (= transition$ |3|))
      a!6
      (and (= state q_2)
           (= y (- 2))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |5|))
      (and (= state q_3)
           (= y 0)
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |6|))
      (and (= state |q_bad'|)
           true
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |7|)))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: No feasible path of length 2. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/division_by_zero.aut with bound 25
=============================
Automaton:
   Division_by_Zero
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_bad, q_bad'
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x <= (3 / 0) » q_bad'
      » x := -1 » q_1
      » x := (x / (y + 2)) » q_2
      » (x / y) > 3 » q_3
   q_1
      » y := (3 / (x + 1)) » q_bad'
   q_2
      » y == -2 » q_bad
   q_3
      » y == 0 » q_bad
   q_bad'
      » skip » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= 3 0) (div 3 0) (- (div (- 3) 0))))
      (a!2 (ite (>= x 0) (div x (+ y 2)) (- (div (- x) (+ y 2)))))
      (a!4 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!5 (ite (>= 3 0) (div 3 (+ x 1)) (- (div (- 3) (+ x 1))))))
(let ((a!3 (and (= state q_0)
                (not (= (+ y 2) 0))
                (= x$ a!2)
                (= y y$)
                (= state$ q_2)
                (= transition$ |2|)))
      (a!6 (and (= state q_1)
                (not (= (+ x 1) 0))
                (= y$ a!5)
                (= x x$)
                (= state$ |q_bad'|)
                (= transition$ |4|))))
  (or (and (= state q_0)
           (not (= 0 0))
           (<= x a!1)
           (= x x$)
           (= y y$)
           (= state$ |q_bad'|)
           (= transition$ |0|))
      (and (= state q_0)
           (= x$ (- 1))
           (= y y$)
           (= state$ q_1)
           (= transition$ |1|))
      a!3
      (and (= state q_0)
           (not (= y 0))
           (> a!4 3)
           (= x x$)
           (= y y$)
           (= state$ q_3)
           (= transition$ |3|))
      a!6
      (and (= state q_2)
           (= y (- 2))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |5|))
      (and (= state q_3)
           (= y 0)
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |6|))
      (and (= state |q_bad'|)
           true
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |7|)))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: No feasible path of length 2. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/division_by_zero.aut with bound 100
=============================
Automaton:
   Division_by_Zero
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_bad, q_bad'
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x <= (3 / 0) » q_bad'
      » x := -1 » q_1
      » x := (x / (y + 2)) » q_2
      » (x / y) > 3 » q_3
   q_1
      » y := (3 / (x + 1)) » q_bad'
   q_2
      » y == -2 » q_bad
   q_3
      » y == 0 » q_bad
   q_bad'
      » skip » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= 3 0) (div 3 0) (- (div (- 3) 0))))
      (a!2 (ite (>= x 0) (div x (+ y 2)) (- (div (- x) (+ y 2)))))
      (a!4 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!5 (ite (>= 3 0) (div 3 (+ x 1)) (- (div (- 3) (+ x 1))))))
(let ((a!3 (and (= state q_0)
                (not (= (+ y 2) 0))
                (= x$ a!2)
                (= y y$)
                (= state$ q_2)
                (= transition$ |2|)))
      (a!6 (and (= state q_1)
                (not (= (+ x 1) 0))
                (= y$ a!5)
                (= x x$)
                (= state$ |q_bad'|)
                (= transition$ |4|))))
  (or (and (= state q_0)
           (not (= 0 0))
           (<= x a!1)
           (= x x$)
           (= y y$)
           (= state$ |q_bad'|)
           (= transition$ |0|))
      (and (= state q_0)
           (= x$ (- 1))
           (= y y$)
           (= state$ q_1)
           (= transition$ |1|))
      a!3
      (and (= state q_0)
           (not (= y 0))
           (> a!4 3)
           (= x x$)
           (= y y$)
           (= state$ q_3)
           (= transition$ |3|))
      a!6
      (and (= state q_2)
           (= y (- 2))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |5|))
      (and (= state q_3)
           (= y 0)
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |6|))
      (and (= state |q_bad'|)
           true
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |7|)))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: No feasible path of length 2. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/inductive_invariants_exercise_1.aut with bound 5
=============================
Automaton:
   Exercise_1
2 variables:
   x, y
3 locations:
   q_0, q_1, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » x := (x * y) » q_1
      » x := (x + 3) » q_1
      » x == 10 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0) (= x$ 0) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1)
         (= x$ (* x y))
         (= y y$)
         (= state$ q_1)
         (= transition$ |1|))
    (and (= state q_1)
         (= x$ (+ x 3))
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (= x 10)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |3|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariants_exercise_1.aut with bound 25
=============================
Automaton:
   Exercise_1
2 variables:
   x, y
3 locations:
   q_0, q_1, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » x := (x * y) » q_1
      » x := (x + 3) » q_1
      » x == 10 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0) (= x$ 0) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1)
         (= x$ (* x y))
         (= y y$)
         (= state$ q_1)
         (= transition$ |1|))
    (and (= state q_1)
         (= x$ (+ x 3))
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (= x 10)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |3|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.

=============================
aut/inductive_invariants_exercise_1.aut with bound 100
=============================
Automaton:
   Exercise_1
2 variables:
   x, y
3 locations:
   q_0, q_1, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » x := (x * y) » q_1
      » x := (x + 3) » q_1
      » x == 10 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0) (= x$ 0) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1)
         (= x$ (* x y))
         (= y y$)
         (= state$ q_1)
         (= transition$ |1|))
    (and (= state q_1)
         (= x$ (+ x 3))
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (= x 10)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |3|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.

=============================
aut/inductive_invariants_exercise_2.aut with bound 5
=============================
Automaton:
   Exercise_2
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » y > 0 » q_1
   q_1
      » x := 0 » q_2
   q_2
      » x := (x + y) » q_3
      » y == 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= x$ 0) (= y y$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (= x$ (+ x y))
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (= y 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_2)
         (= transition$ |4|))
    (and (= state q_4)
         (= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariants_exercise_2.aut with bound 25
=============================
Automaton:
   Exercise_2
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » y > 0 » q_1
   q_1
      » x := 0 » q_2
   q_2
      » x := (x + y) » q_3
      » y == 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= x$ 0) (= y y$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (= x$ (+ x y))
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (= y 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_2)
         (= transition$ |4|))
    (and (= state q_4)
         (= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariants_exercise_2.aut with bound 100
=============================
Automaton:
   Exercise_2
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » y > 0 » q_1
   q_1
      » x := 0 » q_2
   q_2
      » x := (x + y) » q_3
      » y == 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= x$ 0) (= y y$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (= x$ (+ x y))
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (= y 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_2)
         (= transition$ |4|))
    (and (= state q_4)
         (= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |5|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: All paths to q_bad are unfeasible.
Depth  27: All paths to q_bad are unfeasible.
Depth  28: All paths to q_bad are unfeasible.
Depth  29: All paths to q_bad are unfeasible.
Depth  30: All paths to q_bad are unfeasible.
Depth  31: All paths to q_bad are unfeasible.
Depth  32: All paths to q_bad are unfeasible.
Depth  33: All paths to q_bad are unfeasible.
Depth  34: All paths to q_bad are unfeasible.
Depth  35: All paths to q_bad are unfeasible.
Depth  36: All paths to q_bad are unfeasible.
Depth  37: All paths to q_bad are unfeasible.
Depth  38: All paths to q_bad are unfeasible.
Depth  39: All paths to q_bad are unfeasible.
Depth  40: All paths to q_bad are unfeasible.
Depth  41: All paths to q_bad are unfeasible.
Depth  42: All paths to q_bad are unfeasible.
Depth  43: All paths to q_bad are unfeasible.
Depth  44: All paths to q_bad are unfeasible.
Depth  45: All paths to q_bad are unfeasible.
Depth  46: All paths to q_bad are unfeasible.
Depth  47: All paths to q_bad are unfeasible.
Depth  48: All paths to q_bad are unfeasible.
Depth  49: All paths to q_bad are unfeasible.
Depth  50: All paths to q_bad are unfeasible.
Depth  51: All paths to q_bad are unfeasible.
Depth  52: All paths to q_bad are unfeasible.
Depth  53: All paths to q_bad are unfeasible.
Depth  54: All paths to q_bad are unfeasible.
Depth  55: All paths to q_bad are unfeasible.
Depth  56: All paths to q_bad are unfeasible.
Depth  57: All paths to q_bad are unfeasible.
Depth  58: All paths to q_bad are unfeasible.
Depth  59: All paths to q_bad are unfeasible.
Depth  60: All paths to q_bad are unfeasible.
Depth  61: All paths to q_bad are unfeasible.
Depth  62: All paths to q_bad are unfeasible.
Depth  63: All paths to q_bad are unfeasible.
Depth  64: All paths to q_bad are unfeasible.
Depth  65: All paths to q_bad are unfeasible.
Depth  66: All paths to q_bad are unfeasible.
Depth  67: All paths to q_bad are unfeasible.
Depth  68: All paths to q_bad are unfeasible.
Depth  69: All paths to q_bad are unfeasible.
Depth  70: All paths to q_bad are unfeasible.
Depth  71: All paths to q_bad are unfeasible.
Depth  72: All paths to q_bad are unfeasible.
Depth  73: All paths to q_bad are unfeasible.
Depth  74: All paths to q_bad are unfeasible.
Depth  75: All paths to q_bad are unfeasible.
Depth  76: All paths to q_bad are unfeasible.
Depth  77: All paths to q_bad are unfeasible.
Depth  78: All paths to q_bad are unfeasible.
Depth  79: All paths to q_bad are unfeasible.
Depth  80: All paths to q_bad are unfeasible.
Depth  81: All paths to q_bad are unfeasible.
Depth  82: All paths to q_bad are unfeasible.
Depth  83: All paths to q_bad are unfeasible.
Depth  84: All paths to q_bad are unfeasible.
Depth  85: All paths to q_bad are unfeasible.
Depth  86: All paths to q_bad are unfeasible.
Depth  87: All paths to q_bad are unfeasible.
Depth  88: All paths to q_bad are unfeasible.
Depth  89: All paths to q_bad are unfeasible.
Depth  90: All paths to q_bad are unfeasible.
Depth  91: All paths to q_bad are unfeasible.
Depth  92: All paths to q_bad are unfeasible.
Depth  93: All paths to q_bad are unfeasible.
Depth  94: All paths to q_bad are unfeasible.
Depth  95: All paths to q_bad are unfeasible.
Depth  96: All paths to q_bad are unfeasible.
Depth  97: All paths to q_bad are unfeasible.
Depth  98: All paths to q_bad are unfeasible.
Depth  99: All paths to q_bad are unfeasible.
Depth 100: All paths to q_bad are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariant_simple.aut with bound 5
=============================
Automaton:
   Example
1 variables:
   x
3 locations:
   A, B, C
Initial location:
   A
Final location:
   C
Transitions:
   A
      » x := 1 » B
   B
      » x := (5 * x) » B
      » x := (x + 2) » B
      » x < 0 » C

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state A) (= x$ 1) (= state$ B) (= transition$ |0|))
    (and (= state B) (= x$ (* 5 x)) (= state$ B) (= transition$ |1|))
    (and (= state B) (= x$ (+ x 2)) (= state$ B) (= transition$ |2|))
    (and (= state B) (< x 0) (= x x$) (= state$ C) (= transition$ |3|)))

Depth   1: All paths to C are unfeasible.
Depth   2: All paths to C are unfeasible.
Depth   3: All paths to C are unfeasible.
Depth   4: All paths to C are unfeasible.
Depth   5: All paths to C are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location C reachable from initial location A: Unknown

=============================
aut/inductive_invariant_simple.aut with bound 25
=============================
Automaton:
   Example
1 variables:
   x
3 locations:
   A, B, C
Initial location:
   A
Final location:
   C
Transitions:
   A
      » x := 1 » B
   B
      » x := (5 * x) » B
      » x := (x + 2) » B
      » x < 0 » C

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state A) (= x$ 1) (= state$ B) (= transition$ |0|))
    (and (= state B) (= x$ (* 5 x)) (= state$ B) (= transition$ |1|))
    (and (= state B) (= x$ (+ x 2)) (= state$ B) (= transition$ |2|))
    (and (= state B) (< x 0) (= x x$) (= state$ C) (= transition$ |3|)))

Depth   1: All paths to C are unfeasible.
Depth   2: All paths to C are unfeasible.
Depth   3: All paths to C are unfeasible.
Depth   4: All paths to C are unfeasible.
Depth   5: All paths to C are unfeasible.
Depth   6: All paths to C are unfeasible.
Depth   7: All paths to C are unfeasible.
Depth   8: All paths to C are unfeasible.
Depth   9: All paths to C are unfeasible.
Depth  10: All paths to C are unfeasible.
Depth  11: All paths to C are unfeasible.
Depth  12: All paths to C are unfeasible.
Depth  13: All paths to C are unfeasible.
Depth  14: All paths to C are unfeasible.
Depth  15: All paths to C are unfeasible.
Depth  16: All paths to C are unfeasible.
Depth  17: All paths to C are unfeasible.
Depth  18: All paths to C are unfeasible.
Depth  19: All paths to C are unfeasible.
Depth  20: All paths to C are unfeasible.
Depth  21: All paths to C are unfeasible.
Depth  22: All paths to C are unfeasible.
Depth  23: All paths to C are unfeasible.
Depth  24: All paths to C are unfeasible.
Depth  25: All paths to C are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location C reachable from initial location A: Unknown

=============================
aut/inductive_invariant_simple.aut with bound 100
=============================
Automaton:
   Example
1 variables:
   x
3 locations:
   A, B, C
Initial location:
   A
Final location:
   C
Transitions:
   A
      » x := 1 » B
   B
      » x := (5 * x) » B
      » x := (x + 2) » B
      » x < 0 » C

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state A) (= x$ 1) (= state$ B) (= transition$ |0|))
    (and (= state B) (= x$ (* 5 x)) (= state$ B) (= transition$ |1|))
    (and (= state B) (= x$ (+ x 2)) (= state$ B) (= transition$ |2|))
    (and (= state B) (< x 0) (= x x$) (= state$ C) (= transition$ |3|)))

Depth   1: All paths to C are unfeasible.
Depth   2: All paths to C are unfeasible.
Depth   3: All paths to C are unfeasible.
Depth   4: All paths to C are unfeasible.
Depth   5: All paths to C are unfeasible.
Depth   6: All paths to C are unfeasible.
Depth   7: All paths to C are unfeasible.
Depth   8: All paths to C are unfeasible.
Depth   9: All paths to C are unfeasible.
Depth  10: All paths to C are unfeasible.
Depth  11: All paths to C are unfeasible.
Depth  12: All paths to C are unfeasible.
Depth  13: All paths to C are unfeasible.
Depth  14: All paths to C are unfeasible.
Depth  15: All paths to C are unfeasible.
Depth  16: All paths to C are unfeasible.
Depth  17: All paths to C are unfeasible.
Depth  18: All paths to C are unfeasible.
Depth  19: All paths to C are unfeasible.
Depth  20: All paths to C are unfeasible.
Depth  21: All paths to C are unfeasible.
Depth  22: All paths to C are unfeasible.
Depth  23: All paths to C are unfeasible.
Depth  24: All paths to C are unfeasible.
Depth  25: All paths to C are unfeasible.
Depth  26: All paths to C are unfeasible.
Depth  27: All paths to C are unfeasible.
Depth  28: All paths to C are unfeasible.
Depth  29: All paths to C are unfeasible.
Depth  30: All paths to C are unfeasible.
Depth  31: All paths to C are unfeasible.
Depth  32: All paths to C are unfeasible.
Depth  33: All paths to C are unfeasible.
Depth  34: All paths to C are unfeasible.
Depth  35: All paths to C are unfeasible.
Depth  36: All paths to C are unfeasible.
Depth  37: All paths to C are unfeasible.
Depth  38: All paths to C are unfeasible.
Depth  39: All paths to C are unfeasible.
Depth  40: All paths to C are unfeasible.
Depth  41: All paths to C are unfeasible.
Depth  42: All paths to C are unfeasible.
Depth  43: All paths to C are unfeasible.
Depth  44: All paths to C are unfeasible.
Depth  45: All paths to C are unfeasible.
Depth  46: All paths to C are unfeasible.
Depth  47: All paths to C are unfeasible.
Depth  48: All paths to C are unfeasible.
Depth  49: All paths to C are unfeasible.
Depth  50: All paths to C are unfeasible.
Depth  51: All paths to C are unfeasible.
Depth  52: All paths to C are unfeasible.
Depth  53: All paths to C are unfeasible.
Depth  54: All paths to C are unfeasible.
Depth  55: All paths to C are unfeasible.
Depth  56: All paths to C are unfeasible.
Depth  57: All paths to C are unfeasible.
Depth  58: All paths to C are unfeasible.
Depth  59: All paths to C are unfeasible.
Depth  60: All paths to C are unfeasible.
Depth  61: All paths to C are unfeasible.
Depth  62: All paths to C are unfeasible.
Depth  63: All paths to C are unfeasible.
Depth  64: All paths to C are unfeasible.
Depth  65: All paths to C are unfeasible.
Depth  66: All paths to C are unfeasible.
Depth  67: All paths to C are unfeasible.
Depth  68: All paths to C are unfeasible.
Depth  69: All paths to C are unfeasible.
Depth  70: All paths to C are unfeasible.
Depth  71: All paths to C are unfeasible.
Depth  72: All paths to C are unfeasible.
Depth  73: All paths to C are unfeasible.
Depth  74: All paths to C are unfeasible.
Depth  75: All paths to C are unfeasible.
Depth  76: All paths to C are unfeasible.
Depth  77: All paths to C are unfeasible.
Depth  78: All paths to C are unfeasible.
Depth  79: All paths to C are unfeasible.
Depth  80: All paths to C are unfeasible.
Depth  81: All paths to C are unfeasible.
Depth  82: All paths to C are unfeasible.
Depth  83: All paths to C are unfeasible.
Depth  84: All paths to C are unfeasible.
Depth  85: All paths to C are unfeasible.
Depth  86: All paths to C are unfeasible.
Depth  87: All paths to C are unfeasible.
Depth  88: All paths to C are unfeasible.
Depth  89: All paths to C are unfeasible.
Depth  90: All paths to C are unfeasible.
Depth  91: All paths to C are unfeasible.
Depth  92: All paths to C are unfeasible.
Depth  93: All paths to C are unfeasible.
Depth  94: All paths to C are unfeasible.
Depth  95: All paths to C are unfeasible.
Depth  96: All paths to C are unfeasible.
Depth  97: All paths to C are unfeasible.
Depth  98: All paths to C are unfeasible.
Depth  99: All paths to C are unfeasible.
Depth 100: All paths to C are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location C reachable from initial location A: Unknown

=============================
aut/infinite_descent.aut with bound 5
=============================
Automaton:
   Infinite_Descent
1 variables:
   x
4 locations:
   q_0, q_1, q_2, r
Initial location:
   q_0
Final location:
   r
Transitions:
   q_0
      » skip » q_2
      » x := 0 » q_1
   q_1
      » x == 3 » r
   q_2
      » x := 1 » q_1
   r
      » x := (x + 1) » r

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0) true (= x x$) (= state$ q_2) (= transition$ |0|))
    (and (= state q_0) (= x$ 0) (= state$ q_1) (= transition$ |1|))
    (and (= state q_1) (= x 3) (= x x$) (= state$ r) (= transition$ |2|))
    (and (= state q_2) (= x$ 1) (= state$ q_1) (= transition$ |3|))
    (and (= state r) (= x$ (+ x 1)) (= state$ r) (= transition$ |4|)))

Depth   1: All paths to r are unfeasible.
Depth   2: All paths to r are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location r reachable from initial location q_0: No

=============================
aut/infinite_descent.aut with bound 25
=============================
Automaton:
   Infinite_Descent
1 variables:
   x
4 locations:
   q_0, q_1, q_2, r
Initial location:
   q_0
Final location:
   r
Transitions:
   q_0
      » skip » q_2
      » x := 0 » q_1
   q_1
      » x == 3 » r
   q_2
      » x := 1 » q_1
   r
      » x := (x + 1) » r

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0) true (= x x$) (= state$ q_2) (= transition$ |0|))
    (and (= state q_0) (= x$ 0) (= state$ q_1) (= transition$ |1|))
    (and (= state q_1) (= x 3) (= x x$) (= state$ r) (= transition$ |2|))
    (and (= state q_2) (= x$ 1) (= state$ q_1) (= transition$ |3|))
    (and (= state r) (= x$ (+ x 1)) (= state$ r) (= transition$ |4|)))

Depth   1: All paths to r are unfeasible.
Depth   2: All paths to r are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location r reachable from initial location q_0: No

=============================
aut/infinite_descent.aut with bound 100
=============================
Automaton:
   Infinite_Descent
1 variables:
   x
4 locations:
   q_0, q_1, q_2, r
Initial location:
   q_0
Final location:
   r
Transitions:
   q_0
      » skip » q_2
      » x := 0 » q_1
   q_1
      » x == 3 » r
   q_2
      » x := 1 » q_1
   r
      » x := (x + 1) » r

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0) true (= x x$) (= state$ q_2) (= transition$ |0|))
    (and (= state q_0) (= x$ 0) (= state$ q_1) (= transition$ |1|))
    (and (= state q_1) (= x 3) (= x x$) (= state$ r) (= transition$ |2|))
    (and (= state q_2) (= x$ 1) (= state$ q_1) (= transition$ |3|))
    (and (= state r) (= x$ (+ x 1)) (= state$ r) (= transition$ |4|)))

Depth   1: All paths to r are unfeasible.
Depth   2: All paths to r are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location r reachable from initial location q_0: No

=============================
aut/negative_division.aut with bound 5
=============================
Automaton:
   Negative_Division
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := -5 » q_1
   q_1
      » y := (x / 2) » q_2
   q_2
      » y != -2 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 2) (- (div (- x) 2)))))
  (or (and (= state q_0)
           (= x$ (- 5))
           (= y y$)
           (= state$ q_1)
           (= transition$ |0|))
      (and (= state q_1)
           (not (= 2 0))
           (= y$ a!1)
           (= x x$)
           (= state$ q_2)
           (= transition$ |1|))
      (and (= state q_2)
           (not (= y (- 2)))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |2|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/negative_division.aut with bound 25
=============================
Automaton:
   Negative_Division
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := -5 » q_1
   q_1
      » y := (x / 2) » q_2
   q_2
      » y != -2 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 2) (- (div (- x) 2)))))
  (or (and (= state q_0)
           (= x$ (- 5))
           (= y y$)
           (= state$ q_1)
           (= transition$ |0|))
      (and (= state q_1)
           (not (= 2 0))
           (= y$ a!1)
           (= x x$)
           (= state$ q_2)
           (= transition$ |1|))
      (and (= state q_2)
           (not (= y (- 2)))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |2|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/negative_division.aut with bound 100
=============================
Automaton:
   Negative_Division
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := -5 » q_1
   q_1
      » y := (x / 2) » q_2
   q_2
      » y != -2 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 2) (- (div (- x) 2)))))
  (or (and (= state q_0)
           (= x$ (- 5))
           (= y y$)
           (= state$ q_1)
           (= transition$ |0|))
      (and (= state q_1)
           (not (= 2 0))
           (= y$ a!1)
           (= x x$)
           (= state$ q_2)
           (= transition$ |1|))
      (and (= state q_2)
           (not (= y (- 2)))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |2|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/predicates-01.aut with bound 5
=============================
Automaton:
   Predicates_1
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x := (x + 1) » q_3
      » x > 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » (x + y) < 0 » q_bad
      » (x + y) > 0 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0) (= x$ 0) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1) (= y$ 0) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_2)
         (= transition$ |4|))
    (and (= state q_4)
         (< (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |5|))
    (and (= state q_4)
         (> (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |6|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/predicates-01.aut with bound 25
=============================
Automaton:
   Predicates_1
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x := (x + 1) » q_3
      » x > 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » (x + y) < 0 » q_bad
      » (x + y) > 0 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0) (= x$ 0) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1) (= y$ 0) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_2)
         (= transition$ |4|))
    (and (= state q_4)
         (< (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |5|))
    (and (= state q_4)
         (> (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |6|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/predicates-01.aut with bound 100
=============================
Automaton:
   Predicates_1
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x := (x + 1) » q_3
      » x > 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » (x + y) < 0 » q_bad
      » (x + y) > 0 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0) (= x$ 0) (= y y$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_1) (= y$ 0) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_2)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |3|))
    (and (= state q_3)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_2)
         (= transition$ |4|))
    (and (= state q_4)
         (< (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |5|))
    (and (= state q_4)
         (> (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |6|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: All paths to q_bad are unfeasible.
Depth  27: All paths to q_bad are unfeasible.
Depth  28: All paths to q_bad are unfeasible.
Depth  29: All paths to q_bad are unfeasible.
Depth  30: All paths to q_bad are unfeasible.
Depth  31: All paths to q_bad are unfeasible.
Depth  32: All paths to q_bad are unfeasible.
Depth  33: All paths to q_bad are unfeasible.
Depth  34: All paths to q_bad are unfeasible.
Depth  35: All paths to q_bad are unfeasible.
Depth  36: All paths to q_bad are unfeasible.
Depth  37: All paths to q_bad are unfeasible.
Depth  38: All paths to q_bad are unfeasible.
Depth  39: All paths to q_bad are unfeasible.
Depth  40: All paths to q_bad are unfeasible.
Depth  41: All paths to q_bad are unfeasible.
Depth  42: All paths to q_bad are unfeasible.
Depth  43: All paths to q_bad are unfeasible.
Depth  44: All paths to q_bad are unfeasible.
Depth  45: All paths to q_bad are unfeasible.
Depth  46: All paths to q_bad are unfeasible.
Depth  47: All paths to q_bad are unfeasible.
Depth  48: All paths to q_bad are unfeasible.
Depth  49: All paths to q_bad are unfeasible.
Depth  50: All paths to q_bad are unfeasible.
Depth  51: All paths to q_bad are unfeasible.
Depth  52: All paths to q_bad are unfeasible.
Depth  53: All paths to q_bad are unfeasible.
Depth  54: All paths to q_bad are unfeasible.
Depth  55: All paths to q_bad are unfeasible.
Depth  56: All paths to q_bad are unfeasible.
Depth  57: All paths to q_bad are unfeasible.
Depth  58: All paths to q_bad are unfeasible.
Depth  59: All paths to q_bad are unfeasible.
Depth  60: All paths to q_bad are unfeasible.
Depth  61: All paths to q_bad are unfeasible.
Depth  62: All paths to q_bad are unfeasible.
Depth  63: All paths to q_bad are unfeasible.
Depth  64: All paths to q_bad are unfeasible.
Depth  65: All paths to q_bad are unfeasible.
Depth  66: All paths to q_bad are unfeasible.
Depth  67: All paths to q_bad are unfeasible.
Depth  68: All paths to q_bad are unfeasible.
Depth  69: All paths to q_bad are unfeasible.
Depth  70: All paths to q_bad are unfeasible.
Depth  71: All paths to q_bad are unfeasible.
Depth  72: All paths to q_bad are unfeasible.
Depth  73: All paths to q_bad are unfeasible.
Depth  74: All paths to q_bad are unfeasible.
Depth  75: All paths to q_bad are unfeasible.
Depth  76: All paths to q_bad are unfeasible.
Depth  77: All paths to q_bad are unfeasible.
Depth  78: All paths to q_bad are unfeasible.
Depth  79: All paths to q_bad are unfeasible.
Depth  80: All paths to q_bad are unfeasible.
Depth  81: All paths to q_bad are unfeasible.
Depth  82: All paths to q_bad are unfeasible.
Depth  83: All paths to q_bad are unfeasible.
Depth  84: All paths to q_bad are unfeasible.
Depth  85: All paths to q_bad are unfeasible.
Depth  86: All paths to q_bad are unfeasible.
Depth  87: All paths to q_bad are unfeasible.
Depth  88: All paths to q_bad are unfeasible.
Depth  89: All paths to q_bad are unfeasible.
Depth  90: All paths to q_bad are unfeasible.
Depth  91: All paths to q_bad are unfeasible.
Depth  92: All paths to q_bad are unfeasible.
Depth  93: All paths to q_bad are unfeasible.
Depth  94: All paths to q_bad are unfeasible.
Depth  95: All paths to q_bad are unfeasible.
Depth  96: All paths to q_bad are unfeasible.
Depth  97: All paths to q_bad are unfeasible.
Depth  98: All paths to q_bad are unfeasible.
Depth  99: All paths to q_bad are unfeasible.
Depth 100: All paths to q_bad are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/predicates-02.aut with bound 5
=============================
Automaton:
   Predicates_2
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
   q_1
      » y := x » q_2
   q_2
      » y < 0 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0)
         (>= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= y$ x) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |2|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/predicates-02.aut with bound 25
=============================
Automaton:
   Predicates_2
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
   q_1
      » y := x » q_2
   q_2
      » y < 0 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0)
         (>= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= y$ x) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |2|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/predicates-02.aut with bound 100
=============================
Automaton:
   Predicates_2
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
   q_1
      » y := x » q_2
   q_2
      » y < 0 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0)
         (>= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= y$ x) (= x x$) (= state$ q_2) (= transition$ |1|))
    (and (= state q_2)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ q_bad)
         (= transition$ |2|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/pre_only.aut with bound 5
=============================
Automaton:
   Pre_Only
3 variables:
   x, y, z
5 locations:
   q_0, q_1, q_2, q_3, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » (x * y) >= 0 » q_1
   q_1
      » z := y » q_2
   q_2
      » x < 0 » q_3
   q_3
      » z >= 3 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0)
         (>= (* x y) 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1)
         (= z$ y)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (< x 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_3)
         (>= z 3)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |3|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/pre_only.aut with bound 25
=============================
Automaton:
   Pre_Only
3 variables:
   x, y, z
5 locations:
   q_0, q_1, q_2, q_3, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » (x * y) >= 0 » q_1
   q_1
      » z := y » q_2
   q_2
      » x < 0 » q_3
   q_3
      » z >= 3 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0)
         (>= (* x y) 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1)
         (= z$ y)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (< x 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_3)
         (>= z 3)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |3|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/pre_only.aut with bound 100
=============================
Automaton:
   Pre_Only
3 variables:
   x, y, z
5 locations:
   q_0, q_1, q_2, q_3, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » (x * y) >= 0 » q_1
   q_1
      » z := y » q_2
   q_2
      » x < 0 » q_3
   q_3
      » z >= 3 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0)
         (>= (* x y) 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1)
         (= z$ y)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (< x 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |2|))
    (and (= state q_3)
         (>= z 3)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_bad)
         (= transition$ |3|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/running_example.aut with bound 5
=============================
Automaton:
   Running_Example
2 variables:
   x, y
9 locations:
   q_01, q_02, q_03, q_06, q_07, q_08, q_11, q_12, q_13
Initial location:
   q_01
Final location:
   q_13
Transitions:
   q_01
      » x := 1 » q_02
   q_02
      » y <= 10 » q_03
      » y > 10 » q_06
   q_03
      » y := 10 » q_11
   q_06
      » x < y » q_07
      » x >= y » q_11
   q_07
      » x := (2 * x) » q_08
   q_08
      » y := (y - 1) » q_06
   q_11
      » x := (y + 1) » q_12
   q_12
      » x <= 0 » q_13

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_01) (= x$ 1) (= y y$) (= state$ q_02) (= transition$ |0|))
    (and (= state q_02)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ q_03)
         (= transition$ |1|))
    (and (= state q_02)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |2|))
    (and (= state q_03) (= y$ 10) (= x x$) (= state$ q_11) (= transition$ |3|))
    (and (= state q_06)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ q_07)
         (= transition$ |4|))
    (and (= state q_06)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ q_11)
         (= transition$ |5|))
    (and (= state q_07)
         (= x$ (* 2 x))
         (= y y$)
         (= state$ q_08)
         (= transition$ |6|))
    (and (= state q_08)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_06)
         (= transition$ |7|))
    (and (= state q_11)
         (= x$ (+ y 1))
         (= y y$)
         (= state$ q_12)
         (= transition$ |8|))
    (and (= state q_12)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_13)
         (= transition$ |9|)))

Depth   1: All paths to q_13 are unfeasible.
Depth   2: All paths to q_13 are unfeasible.
Depth   3: All paths to q_13 are unfeasible.
Depth   4: All paths to q_13 are unfeasible.
Depth   5: All paths to q_13 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_13 reachable from initial location q_01: Unknown

=============================
aut/running_example.aut with bound 25
=============================
Automaton:
   Running_Example
2 variables:
   x, y
9 locations:
   q_01, q_02, q_03, q_06, q_07, q_08, q_11, q_12, q_13
Initial location:
   q_01
Final location:
   q_13
Transitions:
   q_01
      » x := 1 » q_02
   q_02
      » y <= 10 » q_03
      » y > 10 » q_06
   q_03
      » y := 10 » q_11
   q_06
      » x < y » q_07
      » x >= y » q_11
   q_07
      » x := (2 * x) » q_08
   q_08
      » y := (y - 1) » q_06
   q_11
      » x := (y + 1) » q_12
   q_12
      » x <= 0 » q_13

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_01) (= x$ 1) (= y y$) (= state$ q_02) (= transition$ |0|))
    (and (= state q_02)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ q_03)
         (= transition$ |1|))
    (and (= state q_02)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |2|))
    (and (= state q_03) (= y$ 10) (= x x$) (= state$ q_11) (= transition$ |3|))
    (and (= state q_06)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ q_07)
         (= transition$ |4|))
    (and (= state q_06)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ q_11)
         (= transition$ |5|))
    (and (= state q_07)
         (= x$ (* 2 x))
         (= y y$)
         (= state$ q_08)
         (= transition$ |6|))
    (and (= state q_08)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_06)
         (= transition$ |7|))
    (and (= state q_11)
         (= x$ (+ y 1))
         (= y y$)
         (= state$ q_12)
         (= transition$ |8|))
    (and (= state q_12)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_13)
         (= transition$ |9|)))

Depth   1: All paths to q_13 are unfeasible.
Depth   2: All paths to q_13 are unfeasible.
Depth   3: All paths to q_13 are unfeasible.
Depth   4: All paths to q_13 are unfeasible.
Depth   5: All paths to q_13 are unfeasible.
Depth   6: All paths to q_13 are unfeasible.
Depth   7: All paths to q_13 are unfeasible.
Depth   8: All paths to q_13 are unfeasible.
Depth   9: All paths to q_13 are unfeasible.
Depth  10: All paths to q_13 are unfeasible.
Depth  11: All paths to q_13 are unfeasible.
Depth  12: All paths to q_13 are unfeasible.
Depth  13: All paths to q_13 are unfeasible.
Depth  14: All paths to q_13 are unfeasible.
Depth  15: All paths to q_13 are unfeasible.
Depth  16: All paths to q_13 are unfeasible.
Depth  17: All paths to q_13 are unfeasible.
Depth  18: All paths to q_13 are unfeasible.
Depth  19: All paths to q_13 are unfeasible.
Depth  20: All paths to q_13 are unfeasible.
Depth  21: All paths to q_13 are unfeasible.
Depth  22: All paths to q_13 are unfeasible.
Depth  23: All paths to q_13 are unfeasible.
Depth  24: All paths to q_13 are unfeasible.
Depth  25: All paths to q_13 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_13 reachable from initial location q_01: Unknown

=============================
aut/running_example.aut with bound 100
=============================
Automaton:
   Running_Example
2 variables:
   x, y
9 locations:
   q_01, q_02, q_03, q_06, q_07, q_08, q_11, q_12, q_13
Initial location:
   q_01
Final location:
   q_13
Transitions:
   q_01
      » x := 1 » q_02
   q_02
      » y <= 10 » q_03
      » y > 10 » q_06
   q_03
      » y := 10 » q_11
   q_06
      » x < y » q_07
      » x >= y » q_11
   q_07
      » x := (2 * x) » q_08
   q_08
      » y := (y - 1) » q_06
   q_11
      » x := (y + 1) » q_12
   q_12
      » x <= 0 » q_13

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_01) (= x$ 1) (= y y$) (= state$ q_02) (= transition$ |0|))
    (and (= state q_02)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ q_03)
         (= transition$ |1|))
    (and (= state q_02)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |2|))
    (and (= state q_03) (= y$ 10) (= x x$) (= state$ q_11) (= transition$ |3|))
    (and (= state q_06)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ q_07)
         (= transition$ |4|))
    (and (= state q_06)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ q_11)
         (= transition$ |5|))
    (and (= state q_07)
         (= x$ (* 2 x))
         (= y y$)
         (= state$ q_08)
         (= transition$ |6|))
    (and (= state q_08)
         (= y$ (- y 1))
         (= x x$)
         (= state$ q_06)
         (= transition$ |7|))
    (and (= state q_11)
         (= x$ (+ y 1))
         (= y y$)
         (= state$ q_12)
         (= transition$ |8|))
    (and (= state q_12)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_13)
         (= transition$ |9|)))

Depth   1: All paths to q_13 are unfeasible.
Depth   2: All paths to q_13 are unfeasible.
Depth   3: All paths to q_13 are unfeasible.
Depth   4: All paths to q_13 are unfeasible.
Depth   5: All paths to q_13 are unfeasible.
Depth   6: All paths to q_13 are unfeasible.
Depth   7: All paths to q_13 are unfeasible.
Depth   8: All paths to q_13 are unfeasible.
Depth   9: All paths to q_13 are unfeasible.
Depth  10: All paths to q_13 are unfeasible.
Depth  11: All paths to q_13 are unfeasible.
Depth  12: All paths to q_13 are unfeasible.
Depth  13: All paths to q_13 are unfeasible.
Depth  14: All paths to q_13 are unfeasible.
Depth  15: All paths to q_13 are unfeasible.
Depth  16: All paths to q_13 are unfeasible.
Depth  17: All paths to q_13 are unfeasible.
Depth  18: All paths to q_13 are unfeasible.
Depth  19: All paths to q_13 are unfeasible.
Depth  20: All paths to q_13 are unfeasible.
Depth  21: All paths to q_13 are unfeasible.
Depth  22: All paths to q_13 are unfeasible.
Depth  23: All paths to q_13 are unfeasible.
Depth  24: All paths to q_13 are unfeasible.
Depth  25: All paths to q_13 are unfeasible.
Depth  26: All paths to q_13 are unfeasible.
Depth  27: All paths to q_13 are unfeasible.
Depth  28: All paths to q_13 are unfeasible.
Depth  29: All paths to q_13 are unfeasible.
Depth  30: All paths to q_13 are unfeasible.
Depth  31: All paths to q_13 are unfeasible.
Depth  32: All paths to q_13 are unfeasible.
Depth  33: All paths to q_13 are unfeasible.
Depth  34: All paths to q_13 are unfeasible.
Depth  35: All paths to q_13 are unfeasible.
Depth  36: All paths to q_13 are unfeasible.
Depth  37: All paths to q_13 are unfeasible.
Depth  38: All paths to q_13 are unfeasible.
Depth  39: All paths to q_13 are unfeasible.
Depth  40: All paths to q_13 are unfeasible.
Depth  41: All paths to q_13 are unfeasible.
Depth  42: All paths to q_13 are unfeasible.
Depth  43: All paths to q_13 are unfeasible.
Depth  44: All paths to q_13 are unfeasible.
Depth  45: All paths to q_13 are unfeasible.
Depth  46: All paths to q_13 are unfeasible.
Depth  47: All paths to q_13 are unfeasible.
Depth  48: All paths to q_13 are unfeasible.
Depth  49: All paths to q_13 are unfeasible.
Depth  50: All paths to q_13 are unfeasible.
Depth  51: All paths to q_13 are unfeasible.
Depth  52: All paths to q_13 are unfeasible.
Depth  53: All paths to q_13 are unfeasible.
Depth  54: All paths to q_13 are unfeasible.
Depth  55: All paths to q_13 are unfeasible.
Depth  56: All paths to q_13 are unfeasible.
Depth  57: All paths to q_13 are unfeasible.
Depth  58: All paths to q_13 are unfeasible.
Depth  59: All paths to q_13 are unfeasible.
Depth  60: All paths to q_13 are unfeasible.
Depth  61: All paths to q_13 are unfeasible.
Depth  62: All paths to q_13 are unfeasible.
Depth  63: All paths to q_13 are unfeasible.
Depth  64: All paths to q_13 are unfeasible.
Depth  65: All paths to q_13 are unfeasible.
Depth  66: All paths to q_13 are unfeasible.
Depth  67: All paths to q_13 are unfeasible.
Depth  68: All paths to q_13 are unfeasible.
Depth  69: All paths to q_13 are unfeasible.
Depth  70: All paths to q_13 are unfeasible.
Depth  71: All paths to q_13 are unfeasible.
Depth  72: All paths to q_13 are unfeasible.
Depth  73: All paths to q_13 are unfeasible.
Depth  74: All paths to q_13 are unfeasible.
Depth  75: All paths to q_13 are unfeasible.
Depth  76: All paths to q_13 are unfeasible.
Depth  77: All paths to q_13 are unfeasible.
Depth  78: All paths to q_13 are unfeasible.
Depth  79: All paths to q_13 are unfeasible.
Depth  80: All paths to q_13 are unfeasible.
Depth  81: All paths to q_13 are unfeasible.
Depth  82: All paths to q_13 are unfeasible.
Depth  83: All paths to q_13 are unfeasible.
Depth  84: All paths to q_13 are unfeasible.
Depth  85: All paths to q_13 are unfeasible.
Depth  86: All paths to q_13 are unfeasible.
Depth  87: All paths to q_13 are unfeasible.
Depth  88: All paths to q_13 are unfeasible.
Depth  89: All paths to q_13 are unfeasible.
Depth  90: All paths to q_13 are unfeasible.
Depth  91: All paths to q_13 are unfeasible.
Depth  92: All paths to q_13 are unfeasible.
Depth  93: All paths to q_13 are unfeasible.
Depth  94: All paths to q_13 are unfeasible.
Depth  95: All paths to q_13 are unfeasible.
Depth  96: All paths to q_13 are unfeasible.
Depth  97: All paths to q_13 are unfeasible.
Depth  98: All paths to q_13 are unfeasible.
Depth  99: All paths to q_13 are unfeasible.
Depth 100: All paths to q_13 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_13 reachable from initial location q_01: Unknown

=============================
aut/sign_nonzero_crucial.aut with bound 5
=============================
Automaton:
   Sign_Nonzero
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
      » x < 0 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0) (>= x 0) (= x x$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_0) (< x 0) (= x x$) (= state$ q_3) (= transition$ |1|))
    (and (= state q_1) (< x 10) (= x x$) (= state$ q_2) (= transition$ |2|))
    (and (= state q_1) (>= x 10) (= x x$) (= state$ q_4) (= transition$ |3|))
    (and (= state q_2) (= x$ (+ x 1)) (= state$ q_1) (= transition$ |4|))
    (and (= state q_3) (= x$ (- x 1)) (= state$ q_3) (= transition$ |5|))
    (and (= state q_3) (<= x 10) (= x x$) (= state$ q_4) (= transition$ |6|))
    (and (= state q_4) (= x 0) (= x x$) (= state$ q_bad) (= transition$ |7|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial.aut with bound 25
=============================
Automaton:
   Sign_Nonzero
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
      » x < 0 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0) (>= x 0) (= x x$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_0) (< x 0) (= x x$) (= state$ q_3) (= transition$ |1|))
    (and (= state q_1) (< x 10) (= x x$) (= state$ q_2) (= transition$ |2|))
    (and (= state q_1) (>= x 10) (= x x$) (= state$ q_4) (= transition$ |3|))
    (and (= state q_2) (= x$ (+ x 1)) (= state$ q_1) (= transition$ |4|))
    (and (= state q_3) (= x$ (- x 1)) (= state$ q_3) (= transition$ |5|))
    (and (= state q_3) (<= x 10) (= x x$) (= state$ q_4) (= transition$ |6|))
    (and (= state q_4) (= x 0) (= x x$) (= state$ q_bad) (= transition$ |7|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial.aut with bound 100
=============================
Automaton:
   Sign_Nonzero
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
      » x < 0 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0) (>= x 0) (= x x$) (= state$ q_1) (= transition$ |0|))
    (and (= state q_0) (< x 0) (= x x$) (= state$ q_3) (= transition$ |1|))
    (and (= state q_1) (< x 10) (= x x$) (= state$ q_2) (= transition$ |2|))
    (and (= state q_1) (>= x 10) (= x x$) (= state$ q_4) (= transition$ |3|))
    (and (= state q_2) (= x$ (+ x 1)) (= state$ q_1) (= transition$ |4|))
    (and (= state q_3) (= x$ (- x 1)) (= state$ q_3) (= transition$ |5|))
    (and (= state q_3) (<= x 10) (= x x$) (= state$ q_4) (= transition$ |6|))
    (and (= state q_4) (= x 0) (= x x$) (= state$ q_bad) (= transition$ |7|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: All paths to q_bad are unfeasible.
Depth  27: All paths to q_bad are unfeasible.
Depth  28: All paths to q_bad are unfeasible.
Depth  29: All paths to q_bad are unfeasible.
Depth  30: All paths to q_bad are unfeasible.
Depth  31: All paths to q_bad are unfeasible.
Depth  32: All paths to q_bad are unfeasible.
Depth  33: All paths to q_bad are unfeasible.
Depth  34: All paths to q_bad are unfeasible.
Depth  35: All paths to q_bad are unfeasible.
Depth  36: All paths to q_bad are unfeasible.
Depth  37: All paths to q_bad are unfeasible.
Depth  38: All paths to q_bad are unfeasible.
Depth  39: All paths to q_bad are unfeasible.
Depth  40: All paths to q_bad are unfeasible.
Depth  41: All paths to q_bad are unfeasible.
Depth  42: All paths to q_bad are unfeasible.
Depth  43: All paths to q_bad are unfeasible.
Depth  44: All paths to q_bad are unfeasible.
Depth  45: All paths to q_bad are unfeasible.
Depth  46: All paths to q_bad are unfeasible.
Depth  47: All paths to q_bad are unfeasible.
Depth  48: All paths to q_bad are unfeasible.
Depth  49: All paths to q_bad are unfeasible.
Depth  50: All paths to q_bad are unfeasible.
Depth  51: All paths to q_bad are unfeasible.
Depth  52: All paths to q_bad are unfeasible.
Depth  53: All paths to q_bad are unfeasible.
Depth  54: All paths to q_bad are unfeasible.
Depth  55: All paths to q_bad are unfeasible.
Depth  56: All paths to q_bad are unfeasible.
Depth  57: All paths to q_bad are unfeasible.
Depth  58: All paths to q_bad are unfeasible.
Depth  59: All paths to q_bad are unfeasible.
Depth  60: All paths to q_bad are unfeasible.
Depth  61: All paths to q_bad are unfeasible.
Depth  62: All paths to q_bad are unfeasible.
Depth  63: All paths to q_bad are unfeasible.
Depth  64: All paths to q_bad are unfeasible.
Depth  65: All paths to q_bad are unfeasible.
Depth  66: All paths to q_bad are unfeasible.
Depth  67: All paths to q_bad are unfeasible.
Depth  68: All paths to q_bad are unfeasible.
Depth  69: All paths to q_bad are unfeasible.
Depth  70: All paths to q_bad are unfeasible.
Depth  71: All paths to q_bad are unfeasible.
Depth  72: All paths to q_bad are unfeasible.
Depth  73: All paths to q_bad are unfeasible.
Depth  74: All paths to q_bad are unfeasible.
Depth  75: All paths to q_bad are unfeasible.
Depth  76: All paths to q_bad are unfeasible.
Depth  77: All paths to q_bad are unfeasible.
Depth  78: All paths to q_bad are unfeasible.
Depth  79: All paths to q_bad are unfeasible.
Depth  80: All paths to q_bad are unfeasible.
Depth  81: All paths to q_bad are unfeasible.
Depth  82: All paths to q_bad are unfeasible.
Depth  83: All paths to q_bad are unfeasible.
Depth  84: All paths to q_bad are unfeasible.
Depth  85: All paths to q_bad are unfeasible.
Depth  86: All paths to q_bad are unfeasible.
Depth  87: All paths to q_bad are unfeasible.
Depth  88: All paths to q_bad are unfeasible.
Depth  89: All paths to q_bad are unfeasible.
Depth  90: All paths to q_bad are unfeasible.
Depth  91: All paths to q_bad are unfeasible.
Depth  92: All paths to q_bad are unfeasible.
Depth  93: All paths to q_bad are unfeasible.
Depth  94: All paths to q_bad are unfeasible.
Depth  95: All paths to q_bad are unfeasible.
Depth  96: All paths to q_bad are unfeasible.
Depth  97: All paths to q_bad are unfeasible.
Depth  98: All paths to q_bad are unfeasible.
Depth  99: All paths to q_bad are unfeasible.
Depth 100: All paths to q_bad are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial_variant.aut with bound 5
=============================
Automaton:
   Sign_Nonzero_Variant
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 2 » q_1
      » x := -3 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state q_0) (= x$ 2) (= state$ q_1) (= transition$ |0|))
    (and (= state q_0) (= x$ (- 3)) (= state$ q_3) (= transition$ |1|))
    (and (= state q_1) (< x 10) (= x x$) (= state$ q_2) (= transition$ |2|))
    (and (= state q_1) (>= x 10) (= x x$) (= state$ q_4) (= transition$ |3|))
    (and (= state q_2) (= x$ (+ x 1)) (= state$ q_1) (= transition$ |4|))
    (and (= state q_3) (= x$ (- x 1)) (= state$ q_3) (= transition$ |5|))
    (and (= state q_3) (<= x 10) (= x x$) (= state$ q_4) (= transition$ |6|))
    (and (= state q_4) (= x 0) (= x x$) (= state$ q_bad) (= transition$ |7|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial_variant.aut with bound 25
=============================
Automaton:
   Sign_Nonzero_Variant
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 2 » q_1
      » x := -3 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state q_0) (= x$ 2) (= state$ q_1) (= transition$ |0|))
    (and (= state q_0) (= x$ (- 3)) (= state$ q_3) (= transition$ |1|))
    (and (= state q_1) (< x 10) (= x x$) (= state$ q_2) (= transition$ |2|))
    (and (= state q_1) (>= x 10) (= x x$) (= state$ q_4) (= transition$ |3|))
    (and (= state q_2) (= x$ (+ x 1)) (= state$ q_1) (= transition$ |4|))
    (and (= state q_3) (= x$ (- x 1)) (= state$ q_3) (= transition$ |5|))
    (and (= state q_3) (<= x 10) (= x x$) (= state$ q_4) (= transition$ |6|))
    (and (= state q_4) (= x 0) (= x x$) (= state$ q_bad) (= transition$ |7|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial_variant.aut with bound 100
=============================
Automaton:
   Sign_Nonzero_Variant
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 2 » q_1
      » x := -3 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state q_0) (= x$ 2) (= state$ q_1) (= transition$ |0|))
    (and (= state q_0) (= x$ (- 3)) (= state$ q_3) (= transition$ |1|))
    (and (= state q_1) (< x 10) (= x x$) (= state$ q_2) (= transition$ |2|))
    (and (= state q_1) (>= x 10) (= x x$) (= state$ q_4) (= transition$ |3|))
    (and (= state q_2) (= x$ (+ x 1)) (= state$ q_1) (= transition$ |4|))
    (and (= state q_3) (= x$ (- x 1)) (= state$ q_3) (= transition$ |5|))
    (and (= state q_3) (<= x 10) (= x x$) (= state$ q_4) (= transition$ |6|))
    (and (= state q_4) (= x 0) (= x x$) (= state$ q_bad) (= transition$ |7|)))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: All paths to q_bad are unfeasible.
Depth   4: All paths to q_bad are unfeasible.
Depth   5: All paths to q_bad are unfeasible.
Depth   6: All paths to q_bad are unfeasible.
Depth   7: All paths to q_bad are unfeasible.
Depth   8: All paths to q_bad are unfeasible.
Depth   9: All paths to q_bad are unfeasible.
Depth  10: All paths to q_bad are unfeasible.
Depth  11: All paths to q_bad are unfeasible.
Depth  12: All paths to q_bad are unfeasible.
Depth  13: All paths to q_bad are unfeasible.
Depth  14: All paths to q_bad are unfeasible.
Depth  15: All paths to q_bad are unfeasible.
Depth  16: All paths to q_bad are unfeasible.
Depth  17: All paths to q_bad are unfeasible.
Depth  18: All paths to q_bad are unfeasible.
Depth  19: All paths to q_bad are unfeasible.
Depth  20: All paths to q_bad are unfeasible.
Depth  21: All paths to q_bad are unfeasible.
Depth  22: All paths to q_bad are unfeasible.
Depth  23: All paths to q_bad are unfeasible.
Depth  24: All paths to q_bad are unfeasible.
Depth  25: All paths to q_bad are unfeasible.
Depth  26: All paths to q_bad are unfeasible.
Depth  27: All paths to q_bad are unfeasible.
Depth  28: All paths to q_bad are unfeasible.
Depth  29: All paths to q_bad are unfeasible.
Depth  30: All paths to q_bad are unfeasible.
Depth  31: All paths to q_bad are unfeasible.
Depth  32: All paths to q_bad are unfeasible.
Depth  33: All paths to q_bad are unfeasible.
Depth  34: All paths to q_bad are unfeasible.
Depth  35: All paths to q_bad are unfeasible.
Depth  36: All paths to q_bad are unfeasible.
Depth  37: All paths to q_bad are unfeasible.
Depth  38: All paths to q_bad are unfeasible.
Depth  39: All paths to q_bad are unfeasible.
Depth  40: All paths to q_bad are unfeasible.
Depth  41: All paths to q_bad are unfeasible.
Depth  42: All paths to q_bad are unfeasible.
Depth  43: All paths to q_bad are unfeasible.
Depth  44: All paths to q_bad are unfeasible.
Depth  45: All paths to q_bad are unfeasible.
Depth  46: All paths to q_bad are unfeasible.
Depth  47: All paths to q_bad are unfeasible.
Depth  48: All paths to q_bad are unfeasible.
Depth  49: All paths to q_bad are unfeasible.
Depth  50: All paths to q_bad are unfeasible.
Depth  51: All paths to q_bad are unfeasible.
Depth  52: All paths to q_bad are unfeasible.
Depth  53: All paths to q_bad are unfeasible.
Depth  54: All paths to q_bad are unfeasible.
Depth  55: All paths to q_bad are unfeasible.
Depth  56: All paths to q_bad are unfeasible.
Depth  57: All paths to q_bad are unfeasible.
Depth  58: All paths to q_bad are unfeasible.
Depth  59: All paths to q_bad are unfeasible.
Depth  60: All paths to q_bad are unfeasible.
Depth  61: All paths to q_bad are unfeasible.
Depth  62: All paths to q_bad are unfeasible.
Depth  63: All paths to q_bad are unfeasible.
Depth  64: All paths to q_bad are unfeasible.
Depth  65: All paths to q_bad are unfeasible.
Depth  66: All paths to q_bad are unfeasible.
Depth  67: All paths to q_bad are unfeasible.
Depth  68: All paths to q_bad are unfeasible.
Depth  69: All paths to q_bad are unfeasible.
Depth  70: All paths to q_bad are unfeasible.
Depth  71: All paths to q_bad are unfeasible.
Depth  72: All paths to q_bad are unfeasible.
Depth  73: All paths to q_bad are unfeasible.
Depth  74: All paths to q_bad are unfeasible.
Depth  75: All paths to q_bad are unfeasible.
Depth  76: All paths to q_bad are unfeasible.
Depth  77: All paths to q_bad are unfeasible.
Depth  78: All paths to q_bad are unfeasible.
Depth  79: All paths to q_bad are unfeasible.
Depth  80: All paths to q_bad are unfeasible.
Depth  81: All paths to q_bad are unfeasible.
Depth  82: All paths to q_bad are unfeasible.
Depth  83: All paths to q_bad are unfeasible.
Depth  84: All paths to q_bad are unfeasible.
Depth  85: All paths to q_bad are unfeasible.
Depth  86: All paths to q_bad are unfeasible.
Depth  87: All paths to q_bad are unfeasible.
Depth  88: All paths to q_bad are unfeasible.
Depth  89: All paths to q_bad are unfeasible.
Depth  90: All paths to q_bad are unfeasible.
Depth  91: All paths to q_bad are unfeasible.
Depth  92: All paths to q_bad are unfeasible.
Depth  93: All paths to q_bad are unfeasible.
Depth  94: All paths to q_bad are unfeasible.
Depth  95: All paths to q_bad are unfeasible.
Depth  96: All paths to q_bad are unfeasible.
Depth  97: All paths to q_bad are unfeasible.
Depth  98: All paths to q_bad are unfeasible.
Depth  99: All paths to q_bad are unfeasible.
Depth 100: All paths to q_bad are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/single_path_hard_for_z3.aut with bound 5
=============================
Automaton:
   Single_Path_Hard_for_Z3
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x == (3 * (x / 3)) » q_1
   q_1
      » x := (x * y) » q_2
   q_2
      » (x - 1) == (3 * (x / 3)) » q_bad

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 3) (- (div (- x) 3)))))
  (or (and (= state q_0)
           (not (= 3 0))
           (= x (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_1)
           (= transition$ |0|))
      (and (= state q_1)
           (= x$ (* x y))
           (= y y$)
           (= state$ q_2)
           (= transition$ |1|))
      (and (= state q_2)
           (not (= 3 0))
           (= (- x 1) (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |2|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: Some path to q_bad might be feasible.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/single_path_hard_for_z3.aut with bound 25
=============================
Automaton:
   Single_Path_Hard_for_Z3
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x == (3 * (x / 3)) » q_1
   q_1
      » x := (x * y) » q_2
   q_2
      » (x - 1) == (3 * (x / 3)) » q_bad

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 3) (- (div (- x) 3)))))
  (or (and (= state q_0)
           (not (= 3 0))
           (= x (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_1)
           (= transition$ |0|))
      (and (= state q_1)
           (= x$ (* x y))
           (= y y$)
           (= state$ q_2)
           (= transition$ |1|))
      (and (= state q_2)
           (not (= 3 0))
           (= (- x 1) (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |2|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: Some path to q_bad might be feasible.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/single_path_hard_for_z3.aut with bound 100
=============================
Automaton:
   Single_Path_Hard_for_Z3
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x == (3 * (x / 3)) » q_1
   q_1
      » x := (x * y) » q_2
   q_2
      » (x - 1) == (3 * (x / 3)) » q_bad

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 3) (- (div (- x) 3)))))
  (or (and (= state q_0)
           (not (= 3 0))
           (= x (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_1)
           (= transition$ |0|))
      (and (= state q_1)
           (= x$ (* x y))
           (= y y$)
           (= state$ q_2)
           (= transition$ |1|))
      (and (= state q_2)
           (not (= 3 0))
           (= (- x 1) (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_bad)
           (= transition$ |2|))))

Depth   1: All paths to q_bad are unfeasible.
Depth   2: All paths to q_bad are unfeasible.
Depth   3: Some path to q_bad might be feasible.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
prg/bfs_shorter.c with bound 5
=============================
Automaton:
   bfs_sorter
1 variables:
   x
8 locations:
   l07-c01, l08-c01, l10-c02, l12-c03, l16-c03, l18-c02, l20-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » 1 != 0 » l10-c02
      » 1 == 0 » l20-c00
   l10-c02
      » skip » l12-c03
      » skip » l16-c03
   l12-c03
      » skip » l18-c02
   l16-c03
      » x := (x + 1) » l18-c02
   l18-c02
      » x <= 10 » l08-c01
      » x > 10 » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state l07-c01) (= x$ 0) (= state$ l08-c01) (= transition$ |0|))
    (and (= state l08-c01)
         (not (= 1 0))
         (= x x$)
         (= state$ l10-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (= 1 0)
         (= x x$)
         (= state$ l20-c00)
         (= transition$ |2|))
    (and (= state l10-c02)
         (and true (= x x$))
         (= state$ l12-c03)
         (= transition$ |3|))
    (and (= state l10-c02)
         (and true (= x x$))
         (= state$ l16-c03)
         (= transition$ |4|))
    (and (= state l12-c03)
         (and true (= x x$))
         (= state$ l18-c02)
         (= transition$ |5|))
    (and (= state l16-c03)
         (= x$ (+ x 1))
         (= state$ l18-c02)
         (= transition$ |6|))
    (and (= state l18-c02)
         (<= x 10)
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |7|))
    (and (= state l18-c02)
         (> x 10)
         (= x x$)
         (= state$ ~assert)
         (= transition$ |8|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bfs_shorter.c with bound 25
=============================
Automaton:
   bfs_sorter
1 variables:
   x
8 locations:
   l07-c01, l08-c01, l10-c02, l12-c03, l16-c03, l18-c02, l20-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » 1 != 0 » l10-c02
      » 1 == 0 » l20-c00
   l10-c02
      » skip » l12-c03
      » skip » l16-c03
   l12-c03
      » skip » l18-c02
   l16-c03
      » x := (x + 1) » l18-c02
   l18-c02
      » x <= 10 » l08-c01
      » x > 10 » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state l07-c01) (= x$ 0) (= state$ l08-c01) (= transition$ |0|))
    (and (= state l08-c01)
         (not (= 1 0))
         (= x x$)
         (= state$ l10-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (= 1 0)
         (= x x$)
         (= state$ l20-c00)
         (= transition$ |2|))
    (and (= state l10-c02)
         (and true (= x x$))
         (= state$ l12-c03)
         (= transition$ |3|))
    (and (= state l10-c02)
         (and true (= x x$))
         (= state$ l16-c03)
         (= transition$ |4|))
    (and (= state l12-c03)
         (and true (= x x$))
         (= state$ l18-c02)
         (= transition$ |5|))
    (and (= state l16-c03)
         (= x$ (+ x 1))
         (= state$ l18-c02)
         (= transition$ |6|))
    (and (= state l18-c02)
         (<= x 10)
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |7|))
    (and (= state l18-c02)
         (> x 10)
         (= x x$)
         (= state$ ~assert)
         (= transition$ |8|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bfs_shorter.c with bound 100
=============================
Automaton:
   bfs_sorter
1 variables:
   x
8 locations:
   l07-c01, l08-c01, l10-c02, l12-c03, l16-c03, l18-c02, l20-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » 1 != 0 » l10-c02
      » 1 == 0 » l20-c00
   l10-c02
      » skip » l12-c03
      » skip » l16-c03
   l12-c03
      » skip » l18-c02
   l16-c03
      » x := (x + 1) » l18-c02
   l18-c02
      » x <= 10 » l08-c01
      » x > 10 » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state l07-c01) (= x$ 0) (= state$ l08-c01) (= transition$ |0|))
    (and (= state l08-c01)
         (not (= 1 0))
         (= x x$)
         (= state$ l10-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (= 1 0)
         (= x x$)
         (= state$ l20-c00)
         (= transition$ |2|))
    (and (= state l10-c02)
         (and true (= x x$))
         (= state$ l12-c03)
         (= transition$ |3|))
    (and (= state l10-c02)
         (and true (= x x$))
         (= state$ l16-c03)
         (= transition$ |4|))
    (and (= state l12-c03)
         (and true (= x x$))
         (= state$ l18-c02)
         (= transition$ |5|))
    (and (= state l16-c03)
         (= x$ (+ x 1))
         (= state$ l18-c02)
         (= transition$ |6|))
    (and (= state l18-c02)
         (<= x 10)
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |7|))
    (and (= state l18-c02)
         (> x 10)
         (= x x$)
         (= state$ ~assert)
         (= transition$ |8|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: Feasible path found at depth 45.

Feasible path (of length 45):
   l07-c01
      » x := 0 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x > 10 »
   ~assert

Final location ~assert reachable from initial location l07-c01: Yes

=============================
prg/bin_sum.c with bound 5
=============================
Automaton:
   bin_sum
4 variables:
   x, y, zbin, zun
17 locations:
   l07-c01, l09-c01, l11-c01, l12-c02, l13-c02, l16-c01, l17-c02, l18-c02,
   l21-c01, l22-c02, l23-c02, l26-c01, l27-c02, l28-c02, l31-c01, l32-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » zbin := (x + y) » l09-c01
   l09-c01
      » zun := 0 » l11-c01
   l11-c01
      » x > 0 » l12-c02
      » x <= 0 » l16-c01
   l12-c02
      » x := (x - 1) » l13-c02
   l13-c02
      » zun := (zun + 1) » l11-c01
   l16-c01
      » x < 0 » l17-c02
      » x >= 0 » l21-c01
   l17-c02
      » x := (x + 1) » l18-c02
   l18-c02
      » zun := (zun - 1) » l16-c01
   l21-c01
      » y > 0 » l22-c02
      » y <= 0 » l26-c01
   l22-c02
      » y := (y - 1) » l23-c02
   l23-c02
      » zun := (zun + 1) » l21-c01
   l26-c01
      » y < 0 » l27-c02
      » y >= 0 » l31-c01
   l27-c02
      » y := (y + 1) » l28-c02
   l28-c02
      » zun := (zun - 1) » l26-c01
   l31-c01
      » zbin == zun » l32-c00
      » zbin != zun » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and (= zun$ (+ zun 1)) (= x x$) (= y y$) (= zbin zbin$)))
      (a!2 (and (= zun$ (- zun 1)) (= x x$) (= y y$) (= zbin zbin$))))
  (or (and (= state l07-c01)
           (= zbin$ (+ x y))
           (= x x$)
           (= y y$)
           (= zun zun$)
           (= state$ l09-c01)
           (= transition$ |0|))
      (and (= state l09-c01)
           (= zun$ 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= state$ l11-c01)
           (= transition$ |1|))
      (and (= state l11-c01)
           (> x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l12-c02)
           (= transition$ |2|))
      (and (= state l11-c01)
           (<= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |3|))
      (and (= state l12-c02)
           (= x$ (- x 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l13-c02)
           (= transition$ |4|))
      (and (= state l13-c02) a!1 (= state$ l11-c01) (= transition$ |5|))
      (and (= state l16-c01)
           (< x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l17-c02)
           (= transition$ |6|))
      (and (= state l16-c01)
           (>= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |7|))
      (and (= state l17-c02)
           (= x$ (+ x 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l18-c02)
           (= transition$ |8|))
      (and (= state l18-c02) a!2 (= state$ l16-c01) (= transition$ |9|))
      (and (= state l21-c01)
           (> y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l22-c02)
           (= transition$ |10|))
      (and (= state l21-c01)
           (<= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |11|))
      (and (= state l22-c02)
           (= y$ (- y 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l23-c02)
           (= transition$ |12|))
      (and (= state l23-c02) a!1 (= state$ l21-c01) (= transition$ |13|))
      (and (= state l26-c01)
           (< y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l27-c02)
           (= transition$ |14|))
      (and (= state l26-c01)
           (>= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |15|))
      (and (= state l27-c02)
           (= y$ (+ y 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l28-c02)
           (= transition$ |16|))
      (and (= state l28-c02) a!2 (= state$ l26-c01) (= transition$ |17|))
      (and (= state l31-c01)
           (= zbin zun)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l32-c00)
           (= transition$ |18|))
      (and (= state l31-c01)
           (not (= zbin zun))
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ ~assert)
           (= transition$ |19|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bin_sum.c with bound 25
=============================
Automaton:
   bin_sum
4 variables:
   x, y, zbin, zun
17 locations:
   l07-c01, l09-c01, l11-c01, l12-c02, l13-c02, l16-c01, l17-c02, l18-c02,
   l21-c01, l22-c02, l23-c02, l26-c01, l27-c02, l28-c02, l31-c01, l32-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » zbin := (x + y) » l09-c01
   l09-c01
      » zun := 0 » l11-c01
   l11-c01
      » x > 0 » l12-c02
      » x <= 0 » l16-c01
   l12-c02
      » x := (x - 1) » l13-c02
   l13-c02
      » zun := (zun + 1) » l11-c01
   l16-c01
      » x < 0 » l17-c02
      » x >= 0 » l21-c01
   l17-c02
      » x := (x + 1) » l18-c02
   l18-c02
      » zun := (zun - 1) » l16-c01
   l21-c01
      » y > 0 » l22-c02
      » y <= 0 » l26-c01
   l22-c02
      » y := (y - 1) » l23-c02
   l23-c02
      » zun := (zun + 1) » l21-c01
   l26-c01
      » y < 0 » l27-c02
      » y >= 0 » l31-c01
   l27-c02
      » y := (y + 1) » l28-c02
   l28-c02
      » zun := (zun - 1) » l26-c01
   l31-c01
      » zbin == zun » l32-c00
      » zbin != zun » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and (= zun$ (+ zun 1)) (= x x$) (= y y$) (= zbin zbin$)))
      (a!2 (and (= zun$ (- zun 1)) (= x x$) (= y y$) (= zbin zbin$))))
  (or (and (= state l07-c01)
           (= zbin$ (+ x y))
           (= x x$)
           (= y y$)
           (= zun zun$)
           (= state$ l09-c01)
           (= transition$ |0|))
      (and (= state l09-c01)
           (= zun$ 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= state$ l11-c01)
           (= transition$ |1|))
      (and (= state l11-c01)
           (> x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l12-c02)
           (= transition$ |2|))
      (and (= state l11-c01)
           (<= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |3|))
      (and (= state l12-c02)
           (= x$ (- x 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l13-c02)
           (= transition$ |4|))
      (and (= state l13-c02) a!1 (= state$ l11-c01) (= transition$ |5|))
      (and (= state l16-c01)
           (< x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l17-c02)
           (= transition$ |6|))
      (and (= state l16-c01)
           (>= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |7|))
      (and (= state l17-c02)
           (= x$ (+ x 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l18-c02)
           (= transition$ |8|))
      (and (= state l18-c02) a!2 (= state$ l16-c01) (= transition$ |9|))
      (and (= state l21-c01)
           (> y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l22-c02)
           (= transition$ |10|))
      (and (= state l21-c01)
           (<= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |11|))
      (and (= state l22-c02)
           (= y$ (- y 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l23-c02)
           (= transition$ |12|))
      (and (= state l23-c02) a!1 (= state$ l21-c01) (= transition$ |13|))
      (and (= state l26-c01)
           (< y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l27-c02)
           (= transition$ |14|))
      (and (= state l26-c01)
           (>= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |15|))
      (and (= state l27-c02)
           (= y$ (+ y 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l28-c02)
           (= transition$ |16|))
      (and (= state l28-c02) a!2 (= state$ l26-c01) (= transition$ |17|))
      (and (= state l31-c01)
           (= zbin zun)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l32-c00)
           (= transition$ |18|))
      (and (= state l31-c01)
           (not (= zbin zun))
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ ~assert)
           (= transition$ |19|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bin_sum.c with bound 100
=============================
Automaton:
   bin_sum
4 variables:
   x, y, zbin, zun
17 locations:
   l07-c01, l09-c01, l11-c01, l12-c02, l13-c02, l16-c01, l17-c02, l18-c02,
   l21-c01, l22-c02, l23-c02, l26-c01, l27-c02, l28-c02, l31-c01, l32-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » zbin := (x + y) » l09-c01
   l09-c01
      » zun := 0 » l11-c01
   l11-c01
      » x > 0 » l12-c02
      » x <= 0 » l16-c01
   l12-c02
      » x := (x - 1) » l13-c02
   l13-c02
      » zun := (zun + 1) » l11-c01
   l16-c01
      » x < 0 » l17-c02
      » x >= 0 » l21-c01
   l17-c02
      » x := (x + 1) » l18-c02
   l18-c02
      » zun := (zun - 1) » l16-c01
   l21-c01
      » y > 0 » l22-c02
      » y <= 0 » l26-c01
   l22-c02
      » y := (y - 1) » l23-c02
   l23-c02
      » zun := (zun + 1) » l21-c01
   l26-c01
      » y < 0 » l27-c02
      » y >= 0 » l31-c01
   l27-c02
      » y := (y + 1) » l28-c02
   l28-c02
      » zun := (zun - 1) » l26-c01
   l31-c01
      » zbin == zun » l32-c00
      » zbin != zun » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and (= zun$ (+ zun 1)) (= x x$) (= y y$) (= zbin zbin$)))
      (a!2 (and (= zun$ (- zun 1)) (= x x$) (= y y$) (= zbin zbin$))))
  (or (and (= state l07-c01)
           (= zbin$ (+ x y))
           (= x x$)
           (= y y$)
           (= zun zun$)
           (= state$ l09-c01)
           (= transition$ |0|))
      (and (= state l09-c01)
           (= zun$ 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= state$ l11-c01)
           (= transition$ |1|))
      (and (= state l11-c01)
           (> x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l12-c02)
           (= transition$ |2|))
      (and (= state l11-c01)
           (<= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |3|))
      (and (= state l12-c02)
           (= x$ (- x 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l13-c02)
           (= transition$ |4|))
      (and (= state l13-c02) a!1 (= state$ l11-c01) (= transition$ |5|))
      (and (= state l16-c01)
           (< x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l17-c02)
           (= transition$ |6|))
      (and (= state l16-c01)
           (>= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |7|))
      (and (= state l17-c02)
           (= x$ (+ x 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l18-c02)
           (= transition$ |8|))
      (and (= state l18-c02) a!2 (= state$ l16-c01) (= transition$ |9|))
      (and (= state l21-c01)
           (> y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l22-c02)
           (= transition$ |10|))
      (and (= state l21-c01)
           (<= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |11|))
      (and (= state l22-c02)
           (= y$ (- y 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l23-c02)
           (= transition$ |12|))
      (and (= state l23-c02) a!1 (= state$ l21-c01) (= transition$ |13|))
      (and (= state l26-c01)
           (< y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l27-c02)
           (= transition$ |14|))
      (and (= state l26-c01)
           (>= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |15|))
      (and (= state l27-c02)
           (= y$ (+ y 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l28-c02)
           (= transition$ |16|))
      (and (= state l28-c02) a!2 (= state$ l26-c01) (= transition$ |17|))
      (and (= state l31-c01)
           (= zbin zun)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l32-c00)
           (= transition$ |18|))
      (and (= state l31-c01)
           (not (= zbin zun))
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ ~assert)
           (= transition$ |19|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.

=============================
prg/classic_for_loop.c with bound 5
=============================
Automaton:
   classic
1 variables:
   x
6 locations:
   l08-c06, l08-c12, l08-c23, l09-c01, l10-c00, ~assert
Initial location:
   l08-c06
Final location:
   ~assert
Transitions:
   l08-c06
      » x := 1 » l08-c12
   l08-c12
      » x <= 100 » l08-c23
      » x > 100 » l09-c01
   l08-c23
      » x := (x + 1) » l08-c12
   l09-c01
      » x < 150 » l10-c00
      » x >= 150 » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state l08-c06) (= x$ 1) (= state$ l08-c12) (= transition$ |0|))
    (and (= state l08-c12)
         (<= x 100)
         (= x x$)
         (= state$ l08-c23)
         (= transition$ |1|))
    (and (= state l08-c12)
         (> x 100)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |2|))
    (and (= state l08-c23)
         (= x$ (+ x 1))
         (= state$ l08-c12)
         (= transition$ |3|))
    (and (= state l09-c01)
         (< x 150)
         (= x x$)
         (= state$ l10-c00)
         (= transition$ |4|))
    (and (= state l09-c01)
         (>= x 150)
         (= x x$)
         (= state$ ~assert)
         (= transition$ |5|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c06: Unknown

=============================
prg/classic_for_loop.c with bound 25
=============================
Automaton:
   classic
1 variables:
   x
6 locations:
   l08-c06, l08-c12, l08-c23, l09-c01, l10-c00, ~assert
Initial location:
   l08-c06
Final location:
   ~assert
Transitions:
   l08-c06
      » x := 1 » l08-c12
   l08-c12
      » x <= 100 » l08-c23
      » x > 100 » l09-c01
   l08-c23
      » x := (x + 1) » l08-c12
   l09-c01
      » x < 150 » l10-c00
      » x >= 150 » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state l08-c06) (= x$ 1) (= state$ l08-c12) (= transition$ |0|))
    (and (= state l08-c12)
         (<= x 100)
         (= x x$)
         (= state$ l08-c23)
         (= transition$ |1|))
    (and (= state l08-c12)
         (> x 100)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |2|))
    (and (= state l08-c23)
         (= x$ (+ x 1))
         (= state$ l08-c12)
         (= transition$ |3|))
    (and (= state l09-c01)
         (< x 150)
         (= x x$)
         (= state$ l10-c00)
         (= transition$ |4|))
    (and (= state l09-c01)
         (>= x 150)
         (= x x$)
         (= state$ ~assert)
         (= transition$ |5|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c06: Unknown

=============================
prg/classic_for_loop.c with bound 100
=============================
Automaton:
   classic
1 variables:
   x
6 locations:
   l08-c06, l08-c12, l08-c23, l09-c01, l10-c00, ~assert
Initial location:
   l08-c06
Final location:
   ~assert
Transitions:
   l08-c06
      » x := 1 » l08-c12
   l08-c12
      » x <= 100 » l08-c23
      » x > 100 » l09-c01
   l08-c23
      » x := (x + 1) » l08-c12
   l09-c01
      » x < 150 » l10-c00
      » x >= 150 » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state l08-c06) (= x$ 1) (= state$ l08-c12) (= transition$ |0|))
    (and (= state l08-c12)
         (<= x 100)
         (= x x$)
         (= state$ l08-c23)
         (= transition$ |1|))
    (and (= state l08-c12)
         (> x 100)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |2|))
    (and (= state l08-c23)
         (= x$ (+ x 1))
         (= state$ l08-c12)
         (= transition$ |3|))
    (and (= state l09-c01)
         (< x 150)
         (= x x$)
         (= state$ l10-c00)
         (= transition$ |4|))
    (and (= state l09-c01)
         (>= x 150)
         (= x x$)
         (= state$ ~assert)
         (= transition$ |5|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.
Depth  79: All paths to ~assert are unfeasible.
Depth  80: All paths to ~assert are unfeasible.
Depth  81: All paths to ~assert are unfeasible.
Depth  82: All paths to ~assert are unfeasible.
Depth  83: All paths to ~assert are unfeasible.
Depth  84: All paths to ~assert are unfeasible.
Depth  85: All paths to ~assert are unfeasible.
Depth  86: All paths to ~assert are unfeasible.
Depth  87: All paths to ~assert are unfeasible.
Depth  88: All paths to ~assert are unfeasible.
Depth  89: All paths to ~assert are unfeasible.
Depth  90: All paths to ~assert are unfeasible.
Depth  91: All paths to ~assert are unfeasible.
Depth  92: All paths to ~assert are unfeasible.
Depth  93: All paths to ~assert are unfeasible.
Depth  94: All paths to ~assert are unfeasible.
Depth  95: All paths to ~assert are unfeasible.
Depth  96: All paths to ~assert are unfeasible.
Depth  97: All paths to ~assert are unfeasible.
Depth  98: All paths to ~assert are unfeasible.
Depth  99: All paths to ~assert are unfeasible.
Depth 100: All paths to ~assert are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c06: Unknown

=============================
prg/dichotomy.c with bound 5
=============================
Automaton:
   dichotomy
2 variables:
   x, y
8 locations:
   l08-c01, l09-c02, l10-c03, l11-c04, l13-c04, l15-c02, l17-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x < y » l09-c02
      » x >= y » l17-c00
   l09-c02
      » x < y » l10-c03
      » x >= y » l15-c02
   l10-c03
      » skip » l11-c04
      » skip » l13-c04
   l11-c04
      » x := ((x + y) / 2) » l09-c02
   l13-c04
      » y := ((x + y) / 2) » l09-c02
   l15-c02
      » x == y » l17-c00
      » x != y » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and (< x y) (= x x$) (= y y$)))
      (a!2 (and (>= x y) (= x x$) (= y y$)))
      (a!3 (- (div (- (+ x y)) 2))))
(let ((a!4 (ite (>= (+ x y) 0) (div (+ x y) 2) a!3)))
  (or (and (= state l08-c01) a!1 (= state$ l09-c02) (= transition$ |0|))
      (and (= state l08-c01) a!2 (= state$ l17-c00) (= transition$ |1|))
      (and (= state l09-c02) a!1 (= state$ l10-c03) (= transition$ |2|))
      (and (= state l09-c02) a!2 (= state$ l15-c02) (= transition$ |3|))
      (and (= state l10-c03)
           (and true (= x x$) (= y y$))
           (= state$ l11-c04)
           (= transition$ |4|))
      (and (= state l10-c03)
           (and true (= x x$) (= y y$))
           (= state$ l13-c04)
           (= transition$ |5|))
      (and (= state l11-c04)
           (not (= 2 0))
           (= x$ a!4)
           (= y y$)
           (= state$ l09-c02)
           (= transition$ |6|))
      (and (= state l13-c04)
           (not (= 2 0))
           (= y$ a!4)
           (= x x$)
           (= state$ l09-c02)
           (= transition$ |7|))
      (and (= state l15-c02)
           (= x y)
           (= x x$)
           (= y y$)
           (= state$ l17-c00)
           (= transition$ |8|))
      (and (= state l15-c02)
           (not (= x y))
           (= x x$)
           (= y y$)
           (= state$ ~assert)
           (= transition$ |9|)))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/dichotomy.c with bound 25
=============================
Automaton:
   dichotomy
2 variables:
   x, y
8 locations:
   l08-c01, l09-c02, l10-c03, l11-c04, l13-c04, l15-c02, l17-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x < y » l09-c02
      » x >= y » l17-c00
   l09-c02
      » x < y » l10-c03
      » x >= y » l15-c02
   l10-c03
      » skip » l11-c04
      » skip » l13-c04
   l11-c04
      » x := ((x + y) / 2) » l09-c02
   l13-c04
      » y := ((x + y) / 2) » l09-c02
   l15-c02
      » x == y » l17-c00
      » x != y » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and (< x y) (= x x$) (= y y$)))
      (a!2 (and (>= x y) (= x x$) (= y y$)))
      (a!3 (- (div (- (+ x y)) 2))))
(let ((a!4 (ite (>= (+ x y) 0) (div (+ x y) 2) a!3)))
  (or (and (= state l08-c01) a!1 (= state$ l09-c02) (= transition$ |0|))
      (and (= state l08-c01) a!2 (= state$ l17-c00) (= transition$ |1|))
      (and (= state l09-c02) a!1 (= state$ l10-c03) (= transition$ |2|))
      (and (= state l09-c02) a!2 (= state$ l15-c02) (= transition$ |3|))
      (and (= state l10-c03)
           (and true (= x x$) (= y y$))
           (= state$ l11-c04)
           (= transition$ |4|))
      (and (= state l10-c03)
           (and true (= x x$) (= y y$))
           (= state$ l13-c04)
           (= transition$ |5|))
      (and (= state l11-c04)
           (not (= 2 0))
           (= x$ a!4)
           (= y y$)
           (= state$ l09-c02)
           (= transition$ |6|))
      (and (= state l13-c04)
           (not (= 2 0))
           (= y$ a!4)
           (= x x$)
           (= state$ l09-c02)
           (= transition$ |7|))
      (and (= state l15-c02)
           (= x y)
           (= x x$)
           (= y y$)
           (= state$ l17-c00)
           (= transition$ |8|))
      (and (= state l15-c02)
           (not (= x y))
           (= x x$)
           (= y y$)
           (= state$ ~assert)
           (= transition$ |9|)))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/dichotomy.c with bound 100
=============================
Automaton:
   dichotomy
2 variables:
   x, y
8 locations:
   l08-c01, l09-c02, l10-c03, l11-c04, l13-c04, l15-c02, l17-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x < y » l09-c02
      » x >= y » l17-c00
   l09-c02
      » x < y » l10-c03
      » x >= y » l15-c02
   l10-c03
      » skip » l11-c04
      » skip » l13-c04
   l11-c04
      » x := ((x + y) / 2) » l09-c02
   l13-c04
      » y := ((x + y) / 2) » l09-c02
   l15-c02
      » x == y » l17-c00
      » x != y » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and (< x y) (= x x$) (= y y$)))
      (a!2 (and (>= x y) (= x x$) (= y y$)))
      (a!3 (- (div (- (+ x y)) 2))))
(let ((a!4 (ite (>= (+ x y) 0) (div (+ x y) 2) a!3)))
  (or (and (= state l08-c01) a!1 (= state$ l09-c02) (= transition$ |0|))
      (and (= state l08-c01) a!2 (= state$ l17-c00) (= transition$ |1|))
      (and (= state l09-c02) a!1 (= state$ l10-c03) (= transition$ |2|))
      (and (= state l09-c02) a!2 (= state$ l15-c02) (= transition$ |3|))
      (and (= state l10-c03)
           (and true (= x x$) (= y y$))
           (= state$ l11-c04)
           (= transition$ |4|))
      (and (= state l10-c03)
           (and true (= x x$) (= y y$))
           (= state$ l13-c04)
           (= transition$ |5|))
      (and (= state l11-c04)
           (not (= 2 0))
           (= x$ a!4)
           (= y y$)
           (= state$ l09-c02)
           (= transition$ |6|))
      (and (= state l13-c04)
           (not (= 2 0))
           (= y$ a!4)
           (= x x$)
           (= state$ l09-c02)
           (= transition$ |7|))
      (and (= state l15-c02)
           (= x y)
           (= x x$)
           (= y y$)
           (= state$ l17-c00)
           (= transition$ |8|))
      (and (= state l15-c02)
           (not (= x y))
           (= x x$)
           (= y y$)
           (= state$ ~assert)
           (= transition$ |9|)))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.

=============================
prg/division.c with bound 5
=============================
Automaton:
   division
2 variables:
   x, y
8 locations:
   l05-c04, l06-c04, l07-c04, l08-c08, l09-c08, l10-c08, l12-c00, ~assert
Initial location:
   l05-c04
Final location:
   ~assert
Transitions:
   l05-c04
      » x := 30 » l06-c04
   l06-c04
      » y := 10 » l07-c04
   l07-c04
      » x > 1 » l08-c08
      » x <= 1 » l12-c00
   l08-c08
      » x := (x / y) » l09-c08
   l09-c08
      » y := (y + 1) » l10-c08
   l10-c08
      » x < y » l07-c04
      » x >= y » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= x 0) (div x y) (- (div (- x) y)))))
  (or (and (= state l05-c04)
           (= x$ 30)
           (= y y$)
           (= state$ l06-c04)
           (= transition$ |0|))
      (and (= state l06-c04)
           (= y$ 10)
           (= x x$)
           (= state$ l07-c04)
           (= transition$ |1|))
      (and (= state l07-c04)
           (> x 1)
           (= x x$)
           (= y y$)
           (= state$ l08-c08)
           (= transition$ |2|))
      (and (= state l07-c04)
           (<= x 1)
           (= x x$)
           (= y y$)
           (= state$ l12-c00)
           (= transition$ |3|))
      (and (= state l08-c08)
           (not (= y 0))
           (= x$ a!1)
           (= y y$)
           (= state$ l09-c08)
           (= transition$ |4|))
      (and (= state l09-c08)
           (= y$ (+ y 1))
           (= x x$)
           (= state$ l10-c08)
           (= transition$ |5|))
      (and (= state l10-c08)
           (< x y)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |6|))
      (and (= state l10-c08)
           (>= x y)
           (= x x$)
           (= y y$)
           (= state$ ~assert)
           (= transition$ |7|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l05-c04: Unknown

=============================
prg/division.c with bound 25
=============================
Automaton:
   division
2 variables:
   x, y
8 locations:
   l05-c04, l06-c04, l07-c04, l08-c08, l09-c08, l10-c08, l12-c00, ~assert
Initial location:
   l05-c04
Final location:
   ~assert
Transitions:
   l05-c04
      » x := 30 » l06-c04
   l06-c04
      » y := 10 » l07-c04
   l07-c04
      » x > 1 » l08-c08
      » x <= 1 » l12-c00
   l08-c08
      » x := (x / y) » l09-c08
   l09-c08
      » y := (y + 1) » l10-c08
   l10-c08
      » x < y » l07-c04
      » x >= y » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= x 0) (div x y) (- (div (- x) y)))))
  (or (and (= state l05-c04)
           (= x$ 30)
           (= y y$)
           (= state$ l06-c04)
           (= transition$ |0|))
      (and (= state l06-c04)
           (= y$ 10)
           (= x x$)
           (= state$ l07-c04)
           (= transition$ |1|))
      (and (= state l07-c04)
           (> x 1)
           (= x x$)
           (= y y$)
           (= state$ l08-c08)
           (= transition$ |2|))
      (and (= state l07-c04)
           (<= x 1)
           (= x x$)
           (= y y$)
           (= state$ l12-c00)
           (= transition$ |3|))
      (and (= state l08-c08)
           (not (= y 0))
           (= x$ a!1)
           (= y y$)
           (= state$ l09-c08)
           (= transition$ |4|))
      (and (= state l09-c08)
           (= y$ (+ y 1))
           (= x x$)
           (= state$ l10-c08)
           (= transition$ |5|))
      (and (= state l10-c08)
           (< x y)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |6|))
      (and (= state l10-c08)
           (>= x y)
           (= x x$)
           (= y y$)
           (= state$ ~assert)
           (= transition$ |7|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: No feasible path of length 12. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l05-c04: No

=============================
prg/division.c with bound 100
=============================
Automaton:
   division
2 variables:
   x, y
8 locations:
   l05-c04, l06-c04, l07-c04, l08-c08, l09-c08, l10-c08, l12-c00, ~assert
Initial location:
   l05-c04
Final location:
   ~assert
Transitions:
   l05-c04
      » x := 30 » l06-c04
   l06-c04
      » y := 10 » l07-c04
   l07-c04
      » x > 1 » l08-c08
      » x <= 1 » l12-c00
   l08-c08
      » x := (x / y) » l09-c08
   l09-c08
      » y := (y + 1) » l10-c08
   l10-c08
      » x < y » l07-c04
      » x >= y » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= x 0) (div x y) (- (div (- x) y)))))
  (or (and (= state l05-c04)
           (= x$ 30)
           (= y y$)
           (= state$ l06-c04)
           (= transition$ |0|))
      (and (= state l06-c04)
           (= y$ 10)
           (= x x$)
           (= state$ l07-c04)
           (= transition$ |1|))
      (and (= state l07-c04)
           (> x 1)
           (= x x$)
           (= y y$)
           (= state$ l08-c08)
           (= transition$ |2|))
      (and (= state l07-c04)
           (<= x 1)
           (= x x$)
           (= y y$)
           (= state$ l12-c00)
           (= transition$ |3|))
      (and (= state l08-c08)
           (not (= y 0))
           (= x$ a!1)
           (= y y$)
           (= state$ l09-c08)
           (= transition$ |4|))
      (and (= state l09-c08)
           (= y$ (+ y 1))
           (= x x$)
           (= state$ l10-c08)
           (= transition$ |5|))
      (and (= state l10-c08)
           (< x y)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |6|))
      (and (= state l10-c08)
           (>= x y)
           (= x x$)
           (= y y$)
           (= state$ ~assert)
           (= transition$ |7|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: No feasible path of length 12. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l05-c04: No

=============================
prg/locking.c with bound 5
=============================
Automaton:
   locking
3 variables:
   L, old, new
11 locations:
   l09-c01, l10-c01, l13-c02, l14-c02, l15-c02, l16-c02, l19-c03, l20-c03,
   l21-c03, l24-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new != old » l13-c02
      » new == old » l24-c00
   l13-c02
      » L == 0 » l14-c02
      » L != 0 » ~assert
   l14-c02
      » L := 1 » l15-c02
   l15-c02
      » old := new » l16-c02
   l16-c02
      » skip » l19-c03
      » skip » l10-c01
   l19-c03
      » L == 1 » l20-c03
      » L != 1 » ~assert
   l20-c03
      » L := 0 » l21-c03
   l21-c03
      » new := (new + 1) » l10-c01

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and (= L$ 0) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state l09-c01) a!1 (= state$ l10-c01) (= transition$ |0|))
      (and (= state l10-c01)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |1|))
      (and (= state l10-c01)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l24-c00)
           (= transition$ |2|))
      (and (= state l13-c02)
           (= L 0)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |3|))
      (and (= state l13-c02)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |4|))
      (and (= state l14-c02)
           (= L$ 1)
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |5|))
      (and (= state l15-c02)
           (= old$ new)
           (= L L$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02) a!2 (= state$ l19-c03) (= transition$ |7|))
      (and (= state l16-c02) a!2 (= state$ l10-c01) (= transition$ |8|))
      (and (= state l19-c03)
           (= L 1)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |9|))
      (and (= state l19-c03)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |10|))
      (and (= state l20-c03) a!1 (= state$ l21-c03) (= transition$ |11|))
      (and (= state l21-c03)
           (= new$ (+ new 1))
           (= L L$)
           (= old old$)
           (= state$ l10-c01)
           (= transition$ |12|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l09-c01: Unknown

=============================
prg/locking.c with bound 25
=============================
Automaton:
   locking
3 variables:
   L, old, new
11 locations:
   l09-c01, l10-c01, l13-c02, l14-c02, l15-c02, l16-c02, l19-c03, l20-c03,
   l21-c03, l24-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new != old » l13-c02
      » new == old » l24-c00
   l13-c02
      » L == 0 » l14-c02
      » L != 0 » ~assert
   l14-c02
      » L := 1 » l15-c02
   l15-c02
      » old := new » l16-c02
   l16-c02
      » skip » l19-c03
      » skip » l10-c01
   l19-c03
      » L == 1 » l20-c03
      » L != 1 » ~assert
   l20-c03
      » L := 0 » l21-c03
   l21-c03
      » new := (new + 1) » l10-c01

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and (= L$ 0) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state l09-c01) a!1 (= state$ l10-c01) (= transition$ |0|))
      (and (= state l10-c01)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |1|))
      (and (= state l10-c01)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l24-c00)
           (= transition$ |2|))
      (and (= state l13-c02)
           (= L 0)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |3|))
      (and (= state l13-c02)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |4|))
      (and (= state l14-c02)
           (= L$ 1)
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |5|))
      (and (= state l15-c02)
           (= old$ new)
           (= L L$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02) a!2 (= state$ l19-c03) (= transition$ |7|))
      (and (= state l16-c02) a!2 (= state$ l10-c01) (= transition$ |8|))
      (and (= state l19-c03)
           (= L 1)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |9|))
      (and (= state l19-c03)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |10|))
      (and (= state l20-c03) a!1 (= state$ l21-c03) (= transition$ |11|))
      (and (= state l21-c03)
           (= new$ (+ new 1))
           (= L L$)
           (= old old$)
           (= state$ l10-c01)
           (= transition$ |12|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l09-c01: Unknown

=============================
prg/locking.c with bound 100
=============================
Automaton:
   locking
3 variables:
   L, old, new
11 locations:
   l09-c01, l10-c01, l13-c02, l14-c02, l15-c02, l16-c02, l19-c03, l20-c03,
   l21-c03, l24-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new != old » l13-c02
      » new == old » l24-c00
   l13-c02
      » L == 0 » l14-c02
      » L != 0 » ~assert
   l14-c02
      » L := 1 » l15-c02
   l15-c02
      » old := new » l16-c02
   l16-c02
      » skip » l19-c03
      » skip » l10-c01
   l19-c03
      » L == 1 » l20-c03
      » L != 1 » ~assert
   l20-c03
      » L := 0 » l21-c03
   l21-c03
      » new := (new + 1) » l10-c01

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and (= L$ 0) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state l09-c01) a!1 (= state$ l10-c01) (= transition$ |0|))
      (and (= state l10-c01)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |1|))
      (and (= state l10-c01)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l24-c00)
           (= transition$ |2|))
      (and (= state l13-c02)
           (= L 0)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |3|))
      (and (= state l13-c02)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |4|))
      (and (= state l14-c02)
           (= L$ 1)
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |5|))
      (and (= state l15-c02)
           (= old$ new)
           (= L L$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02) a!2 (= state$ l19-c03) (= transition$ |7|))
      (and (= state l16-c02) a!2 (= state$ l10-c01) (= transition$ |8|))
      (and (= state l19-c03)
           (= L 1)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |9|))
      (and (= state l19-c03)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |10|))
      (and (= state l20-c03) a!1 (= state$ l21-c03) (= transition$ |11|))
      (and (= state l21-c03)
           (= new$ (+ new 1))
           (= L L$)
           (= old old$)
           (= state$ l10-c01)
           (= transition$ |12|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.
Depth  79: All paths to ~assert are unfeasible.
Depth  80: All paths to ~assert are unfeasible.
Depth  81: All paths to ~assert are unfeasible.
Depth  82: All paths to ~assert are unfeasible.
Depth  83: All paths to ~assert are unfeasible.
Depth  84: All paths to ~assert are unfeasible.
Depth  85: All paths to ~assert are unfeasible.
Depth  86: All paths to ~assert are unfeasible.
Depth  87: All paths to ~assert are unfeasible.
Depth  88: All paths to ~assert are unfeasible.
Depth  89: All paths to ~assert are unfeasible.
Depth  90: All paths to ~assert are unfeasible.
Depth  91: All paths to ~assert are unfeasible.
Depth  92: All paths to ~assert are unfeasible.
Depth  93: All paths to ~assert are unfeasible.
Depth  94: All paths to ~assert are unfeasible.
Depth  95: All paths to ~assert are unfeasible.
Depth  96: All paths to ~assert are unfeasible.
Depth  97: All paths to ~assert are unfeasible.
Depth  98: All paths to ~assert are unfeasible.
Depth  99: All paths to ~assert are unfeasible.
Depth 100: All paths to ~assert are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l09-c01: Unknown

=============================
prg/locking_variant.c with bound 5
=============================
Automaton:
   locking
3 variables:
   L, old, new
12 locations:
   l09-c01, l10-c01, l11-c01, l14-c02, l15-c02, l16-c02, l17-c02, l20-c03,
   l21-c03, l22-c03, l25-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new := (old + 1) » l11-c01
   l11-c01
      » new != old » l14-c02
      » new == old » l25-c00
   l14-c02
      » L == 0 » l15-c02
      » L != 0 » ~assert
   l15-c02
      » L := 1 » l16-c02
   l16-c02
      » old := new » l17-c02
   l17-c02
      » skip » l20-c03
      » skip » l11-c01
   l20-c03
      » L == 1 » l21-c03
      » L != 1 » ~assert
   l21-c03
      » L := 0 » l22-c03
   l22-c03
      » new := (new + 1) » l11-c01

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and (= L$ 0) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state l09-c01) a!1 (= state$ l10-c01) (= transition$ |0|))
      (and (= state l10-c01)
           (= new$ (+ old 1))
           (= L L$)
           (= old old$)
           (= state$ l11-c01)
           (= transition$ |1|))
      (and (= state l11-c01)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |2|))
      (and (= state l11-c01)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l25-c00)
           (= transition$ |3|))
      (and (= state l14-c02)
           (= L 0)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |4|))
      (and (= state l14-c02)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |5|))
      (and (= state l15-c02)
           (= L$ 1)
           (= old old$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02)
           (= old$ new)
           (= L L$)
           (= new new$)
           (= state$ l17-c02)
           (= transition$ |7|))
      (and (= state l17-c02) a!2 (= state$ l20-c03) (= transition$ |8|))
      (and (= state l17-c02) a!2 (= state$ l11-c01) (= transition$ |9|))
      (and (= state l20-c03)
           (= L 1)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l21-c03)
           (= transition$ |10|))
      (and (= state l20-c03)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |11|))
      (and (= state l21-c03) a!1 (= state$ l22-c03) (= transition$ |12|))
      (and (= state l22-c03)
           (= new$ (+ new 1))
           (= L L$)
           (= old old$)
           (= state$ l11-c01)
           (= transition$ |13|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l09-c01: Unknown

=============================
prg/locking_variant.c with bound 25
=============================
Automaton:
   locking
3 variables:
   L, old, new
12 locations:
   l09-c01, l10-c01, l11-c01, l14-c02, l15-c02, l16-c02, l17-c02, l20-c03,
   l21-c03, l22-c03, l25-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new := (old + 1) » l11-c01
   l11-c01
      » new != old » l14-c02
      » new == old » l25-c00
   l14-c02
      » L == 0 » l15-c02
      » L != 0 » ~assert
   l15-c02
      » L := 1 » l16-c02
   l16-c02
      » old := new » l17-c02
   l17-c02
      » skip » l20-c03
      » skip » l11-c01
   l20-c03
      » L == 1 » l21-c03
      » L != 1 » ~assert
   l21-c03
      » L := 0 » l22-c03
   l22-c03
      » new := (new + 1) » l11-c01

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and (= L$ 0) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state l09-c01) a!1 (= state$ l10-c01) (= transition$ |0|))
      (and (= state l10-c01)
           (= new$ (+ old 1))
           (= L L$)
           (= old old$)
           (= state$ l11-c01)
           (= transition$ |1|))
      (and (= state l11-c01)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |2|))
      (and (= state l11-c01)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l25-c00)
           (= transition$ |3|))
      (and (= state l14-c02)
           (= L 0)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |4|))
      (and (= state l14-c02)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |5|))
      (and (= state l15-c02)
           (= L$ 1)
           (= old old$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02)
           (= old$ new)
           (= L L$)
           (= new new$)
           (= state$ l17-c02)
           (= transition$ |7|))
      (and (= state l17-c02) a!2 (= state$ l20-c03) (= transition$ |8|))
      (and (= state l17-c02) a!2 (= state$ l11-c01) (= transition$ |9|))
      (and (= state l20-c03)
           (= L 1)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l21-c03)
           (= transition$ |10|))
      (and (= state l20-c03)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |11|))
      (and (= state l21-c03) a!1 (= state$ l22-c03) (= transition$ |12|))
      (and (= state l22-c03)
           (= new$ (+ new 1))
           (= L L$)
           (= old old$)
           (= state$ l11-c01)
           (= transition$ |13|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l09-c01: Unknown

=============================
prg/locking_variant.c with bound 100
=============================
Automaton:
   locking
3 variables:
   L, old, new
12 locations:
   l09-c01, l10-c01, l11-c01, l14-c02, l15-c02, l16-c02, l17-c02, l20-c03,
   l21-c03, l22-c03, l25-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new := (old + 1) » l11-c01
   l11-c01
      » new != old » l14-c02
      » new == old » l25-c00
   l14-c02
      » L == 0 » l15-c02
      » L != 0 » ~assert
   l15-c02
      » L := 1 » l16-c02
   l16-c02
      » old := new » l17-c02
   l17-c02
      » skip » l20-c03
      » skip » l11-c01
   l20-c03
      » L == 1 » l21-c03
      » L != 1 » ~assert
   l21-c03
      » L := 0 » l22-c03
   l22-c03
      » new := (new + 1) » l11-c01

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and (= L$ 0) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state l09-c01) a!1 (= state$ l10-c01) (= transition$ |0|))
      (and (= state l10-c01)
           (= new$ (+ old 1))
           (= L L$)
           (= old old$)
           (= state$ l11-c01)
           (= transition$ |1|))
      (and (= state l11-c01)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |2|))
      (and (= state l11-c01)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l25-c00)
           (= transition$ |3|))
      (and (= state l14-c02)
           (= L 0)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |4|))
      (and (= state l14-c02)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |5|))
      (and (= state l15-c02)
           (= L$ 1)
           (= old old$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02)
           (= old$ new)
           (= L L$)
           (= new new$)
           (= state$ l17-c02)
           (= transition$ |7|))
      (and (= state l17-c02) a!2 (= state$ l20-c03) (= transition$ |8|))
      (and (= state l17-c02) a!2 (= state$ l11-c01) (= transition$ |9|))
      (and (= state l20-c03)
           (= L 1)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l21-c03)
           (= transition$ |10|))
      (and (= state l20-c03)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ ~assert)
           (= transition$ |11|))
      (and (= state l21-c03) a!1 (= state$ l22-c03) (= transition$ |12|))
      (and (= state l22-c03)
           (= new$ (+ new 1))
           (= L L$)
           (= old old$)
           (= state$ l11-c01)
           (= transition$ |13|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.
Depth  79: All paths to ~assert are unfeasible.
Depth  80: All paths to ~assert are unfeasible.
Depth  81: All paths to ~assert are unfeasible.
Depth  82: All paths to ~assert are unfeasible.
Depth  83: All paths to ~assert are unfeasible.
Depth  84: All paths to ~assert are unfeasible.
Depth  85: All paths to ~assert are unfeasible.
Depth  86: All paths to ~assert are unfeasible.
Depth  87: All paths to ~assert are unfeasible.
Depth  88: All paths to ~assert are unfeasible.
Depth  89: All paths to ~assert are unfeasible.
Depth  90: All paths to ~assert are unfeasible.
Depth  91: All paths to ~assert are unfeasible.
Depth  92: All paths to ~assert are unfeasible.
Depth  93: All paths to ~assert are unfeasible.
Depth  94: All paths to ~assert are unfeasible.
Depth  95: All paths to ~assert are unfeasible.
Depth  96: All paths to ~assert are unfeasible.
Depth  97: All paths to ~assert are unfeasible.
Depth  98: All paths to ~assert are unfeasible.
Depth  99: All paths to ~assert are unfeasible.
Depth 100: All paths to ~assert are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l09-c01: Unknown

=============================
prg/long_to_violate.c with bound 5
=============================
Automaton:
   long_to_violate
2 variables:
   x, y
11 locations:
   l07-c01, l08-c01, l10-c02, l11-c03, l13-c03, l14-c02, l15-c03, l16-c02,
   l18-c01, l19-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 20 » l10-c02
      » x >= 20 » l18-c01
   l10-c02
      » y < 0 » l11-c03
      » y >= 0 » l13-c03
   l11-c03
      » y := (y + x) » l14-c02
   l13-c03
      » y := (y - x) » l14-c02
   l14-c02
      » skip » l15-c03
      » skip » l16-c02
   l15-c03
      » y := (y + 200) » l16-c02
   l16-c02
      » x := (x + 1) » l08-c01
   l18-c01
      » y > 0 » l19-c00
      » y <= 0 » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state l07-c01)
         (= x$ 0)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (< x 20)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (>= x 20)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |2|))
    (and (= state l10-c02)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l11-c03)
         (= transition$ |3|))
    (and (= state l10-c02)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |4|))
    (and (= state l11-c03)
         (= y$ (+ y x))
         (= x x$)
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l13-c03)
         (= y$ (- y x))
         (= x x$)
         (= state$ l14-c02)
         (= transition$ |6|))
    (and (= state l14-c02)
         (and true (= x x$) (= y y$))
         (= state$ l15-c03)
         (= transition$ |7|))
    (and (= state l14-c02)
         (and true (= x x$) (= y y$))
         (= state$ l16-c02)
         (= transition$ |8|))
    (and (= state l15-c03)
         (= y$ (+ y 200))
         (= x x$)
         (= state$ l16-c02)
         (= transition$ |9|))
    (and (= state l16-c02)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |10|))
    (and (= state l18-c01)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ l19-c00)
         (= transition$ |11|))
    (and (= state l18-c01)
         (<= y 0)
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |12|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/long_to_violate.c with bound 25
=============================
Automaton:
   long_to_violate
2 variables:
   x, y
11 locations:
   l07-c01, l08-c01, l10-c02, l11-c03, l13-c03, l14-c02, l15-c03, l16-c02,
   l18-c01, l19-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 20 » l10-c02
      » x >= 20 » l18-c01
   l10-c02
      » y < 0 » l11-c03
      » y >= 0 » l13-c03
   l11-c03
      » y := (y + x) » l14-c02
   l13-c03
      » y := (y - x) » l14-c02
   l14-c02
      » skip » l15-c03
      » skip » l16-c02
   l15-c03
      » y := (y + 200) » l16-c02
   l16-c02
      » x := (x + 1) » l08-c01
   l18-c01
      » y > 0 » l19-c00
      » y <= 0 » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state l07-c01)
         (= x$ 0)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (< x 20)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (>= x 20)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |2|))
    (and (= state l10-c02)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l11-c03)
         (= transition$ |3|))
    (and (= state l10-c02)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |4|))
    (and (= state l11-c03)
         (= y$ (+ y x))
         (= x x$)
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l13-c03)
         (= y$ (- y x))
         (= x x$)
         (= state$ l14-c02)
         (= transition$ |6|))
    (and (= state l14-c02)
         (and true (= x x$) (= y y$))
         (= state$ l15-c03)
         (= transition$ |7|))
    (and (= state l14-c02)
         (and true (= x x$) (= y y$))
         (= state$ l16-c02)
         (= transition$ |8|))
    (and (= state l15-c03)
         (= y$ (+ y 200))
         (= x x$)
         (= state$ l16-c02)
         (= transition$ |9|))
    (and (= state l16-c02)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |10|))
    (and (= state l18-c01)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ l19-c00)
         (= transition$ |11|))
    (and (= state l18-c01)
         (<= y 0)
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |12|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/long_to_violate.c with bound 100
=============================
Automaton:
   long_to_violate
2 variables:
   x, y
11 locations:
   l07-c01, l08-c01, l10-c02, l11-c03, l13-c03, l14-c02, l15-c03, l16-c02,
   l18-c01, l19-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 20 » l10-c02
      » x >= 20 » l18-c01
   l10-c02
      » y < 0 » l11-c03
      » y >= 0 » l13-c03
   l11-c03
      » y := (y + x) » l14-c02
   l13-c03
      » y := (y - x) » l14-c02
   l14-c02
      » skip » l15-c03
      » skip » l16-c02
   l15-c03
      » y := (y + 200) » l16-c02
   l16-c02
      » x := (x + 1) » l08-c01
   l18-c01
      » y > 0 » l19-c00
      » y <= 0 » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state l07-c01)
         (= x$ 0)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (< x 20)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (>= x 20)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |2|))
    (and (= state l10-c02)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l11-c03)
         (= transition$ |3|))
    (and (= state l10-c02)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |4|))
    (and (= state l11-c03)
         (= y$ (+ y x))
         (= x x$)
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l13-c03)
         (= y$ (- y x))
         (= x x$)
         (= state$ l14-c02)
         (= transition$ |6|))
    (and (= state l14-c02)
         (and true (= x x$) (= y y$))
         (= state$ l15-c03)
         (= transition$ |7|))
    (and (= state l14-c02)
         (and true (= x x$) (= y y$))
         (= state$ l16-c02)
         (= transition$ |8|))
    (and (= state l15-c03)
         (= y$ (+ y 200))
         (= x x$)
         (= state$ l16-c02)
         (= transition$ |9|))
    (and (= state l16-c02)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |10|))
    (and (= state l18-c01)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ l19-c00)
         (= transition$ |11|))
    (and (= state l18-c01)
         (<= y 0)
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |12|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.

=============================
prg/must_unfold_loop.c with bound 5
=============================
Automaton:
   must_unfold_loop
3 variables:
   x, y, z
11 locations:
   l07-c01, l08-c01, l09-c01, l10-c06, l10-c12, l10-c21, l12-c02, l13-c03,
   l14-c02, l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » z := 20 » l09-c01
   l09-c01
      » y := 0 » l10-c06
   l10-c06
      » x := 0 » l10-c12
   l10-c12
      » x < 20 » l12-c02
      » x >= 20 » l16-c00
   l10-c21
      » x := (x + 1) » l10-c12
   l12-c02
      » skip » l13-c03
      » skip » l14-c02
   l13-c03
      » y := (y + 1) » l14-c02
   l14-c02
      » (x * y) < z » l10-c21
      » (x * y) >= z » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and (= x$ 0) (= y y$) (= z z$)))
      (a!2 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c01) a!1 (= state$ l08-c01) (= transition$ |0|))
      (and (= state l08-c01)
           (= z$ 20)
           (= x x$)
           (= y y$)
           (= state$ l09-c01)
           (= transition$ |1|))
      (and (= state l09-c01)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l10-c06)
           (= transition$ |2|))
      (and (= state l10-c06) a!1 (= state$ l10-c12) (= transition$ |3|))
      (and (= state l10-c12)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l12-c02)
           (= transition$ |4|))
      (and (= state l10-c12)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l16-c00)
           (= transition$ |5|))
      (and (= state l10-c21)
           (= x$ (+ x 1))
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |6|))
      (and (= state l12-c02) a!2 (= state$ l13-c03) (= transition$ |7|))
      (and (= state l12-c02) a!2 (= state$ l14-c02) (= transition$ |8|))
      (and (= state l13-c03)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |9|))
      (and (= state l14-c02)
           (< (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c21)
           (= transition$ |10|))
      (and (= state l14-c02)
           (>= (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ ~assert)
           (= transition$ |11|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/must_unfold_loop.c with bound 25
=============================
Automaton:
   must_unfold_loop
3 variables:
   x, y, z
11 locations:
   l07-c01, l08-c01, l09-c01, l10-c06, l10-c12, l10-c21, l12-c02, l13-c03,
   l14-c02, l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » z := 20 » l09-c01
   l09-c01
      » y := 0 » l10-c06
   l10-c06
      » x := 0 » l10-c12
   l10-c12
      » x < 20 » l12-c02
      » x >= 20 » l16-c00
   l10-c21
      » x := (x + 1) » l10-c12
   l12-c02
      » skip » l13-c03
      » skip » l14-c02
   l13-c03
      » y := (y + 1) » l14-c02
   l14-c02
      » (x * y) < z » l10-c21
      » (x * y) >= z » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and (= x$ 0) (= y y$) (= z z$)))
      (a!2 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c01) a!1 (= state$ l08-c01) (= transition$ |0|))
      (and (= state l08-c01)
           (= z$ 20)
           (= x x$)
           (= y y$)
           (= state$ l09-c01)
           (= transition$ |1|))
      (and (= state l09-c01)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l10-c06)
           (= transition$ |2|))
      (and (= state l10-c06) a!1 (= state$ l10-c12) (= transition$ |3|))
      (and (= state l10-c12)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l12-c02)
           (= transition$ |4|))
      (and (= state l10-c12)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l16-c00)
           (= transition$ |5|))
      (and (= state l10-c21)
           (= x$ (+ x 1))
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |6|))
      (and (= state l12-c02) a!2 (= state$ l13-c03) (= transition$ |7|))
      (and (= state l12-c02) a!2 (= state$ l14-c02) (= transition$ |8|))
      (and (= state l13-c03)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |9|))
      (and (= state l14-c02)
           (< (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c21)
           (= transition$ |10|))
      (and (= state l14-c02)
           (>= (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ ~assert)
           (= transition$ |11|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/must_unfold_loop.c with bound 100
=============================
Automaton:
   must_unfold_loop
3 variables:
   x, y, z
11 locations:
   l07-c01, l08-c01, l09-c01, l10-c06, l10-c12, l10-c21, l12-c02, l13-c03,
   l14-c02, l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » z := 20 » l09-c01
   l09-c01
      » y := 0 » l10-c06
   l10-c06
      » x := 0 » l10-c12
   l10-c12
      » x < 20 » l12-c02
      » x >= 20 » l16-c00
   l10-c21
      » x := (x + 1) » l10-c12
   l12-c02
      » skip » l13-c03
      » skip » l14-c02
   l13-c03
      » y := (y + 1) » l14-c02
   l14-c02
      » (x * y) < z » l10-c21
      » (x * y) >= z » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and (= x$ 0) (= y y$) (= z z$)))
      (a!2 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c01) a!1 (= state$ l08-c01) (= transition$ |0|))
      (and (= state l08-c01)
           (= z$ 20)
           (= x x$)
           (= y y$)
           (= state$ l09-c01)
           (= transition$ |1|))
      (and (= state l09-c01)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l10-c06)
           (= transition$ |2|))
      (and (= state l10-c06) a!1 (= state$ l10-c12) (= transition$ |3|))
      (and (= state l10-c12)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l12-c02)
           (= transition$ |4|))
      (and (= state l10-c12)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l16-c00)
           (= transition$ |5|))
      (and (= state l10-c21)
           (= x$ (+ x 1))
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |6|))
      (and (= state l12-c02) a!2 (= state$ l13-c03) (= transition$ |7|))
      (and (= state l12-c02) a!2 (= state$ l14-c02) (= transition$ |8|))
      (and (= state l13-c03)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |9|))
      (and (= state l14-c02)
           (< (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c21)
           (= transition$ |10|))
      (and (= state l14-c02)
           (>= (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ ~assert)
           (= transition$ |11|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: Feasible path found at depth 28.

Feasible path (of length 28):
   l07-c01
      » x := 0 »
   l08-c01
      » z := 20 »
   l09-c01
      » y := 0 »
   l10-c06
      » x := 0 »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) >= z »
   ~assert

Final location ~assert reachable from initial location l07-c01: Yes

=============================
prg/no_assert.c with bound 5
=============================
Automaton:
   no_assert
3 variables:
   x, y, z
11 locations:
   l07-c06, l07-c12, l07-c21, l09-c07, l09-c13, l09-c23, l11-c03, l12-c04,
   l14-c04, l17-c00, ~assert
Initial location:
   l07-c06
Final location:
   ~assert
Transitions:
   l07-c06
      » x := 0 » l07-c12
   l07-c12
      » x < 20 » l09-c07
      » x >= 20 » l17-c00
   l07-c21
      » x := (x + 1) » l07-c12
   l09-c07
      » y := 0 » l09-c13
   l09-c13
      » y < (x * x) » l11-c03
      » y >= (x * x) » l07-c21
   l09-c23
      » y := (y + 1) » l09-c13
   l11-c03
      » skip » l12-c04
      » skip » l14-c04
   l12-c04
      » z := (z + 1) » l09-c23
   l14-c04
      » z := (z - 1) » l09-c23

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c06)
           (= x$ 0)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |0|))
      (and (= state l07-c12)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c07)
           (= transition$ |1|))
      (and (= state l07-c12)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l17-c00)
           (= transition$ |2|))
      (and (= state l07-c21)
           (= x$ (+ x 1))
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |3|))
      (and (= state l09-c07)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |4|))
      (and (= state l09-c13)
           (< y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l11-c03)
           (= transition$ |5|))
      (and (= state l09-c13)
           (>= y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c21)
           (= transition$ |6|))
      (and (= state l09-c23)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |7|))
      (and (= state l11-c03) a!1 (= state$ l12-c04) (= transition$ |8|))
      (and (= state l11-c03) a!1 (= state$ l14-c04) (= transition$ |9|))
      (and (= state l12-c04)
           (= z$ (+ z 1))
           (= x x$)
           (= y y$)
           (= state$ l09-c23)
           (= transition$ |10|))
      (and (= state l14-c04)
           (= z$ (- z 1))
           (= x x$)
           (= y y$)
           (= state$ l09-c23)
           (= transition$ |11|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c06: Unknown

=============================
prg/no_assert.c with bound 25
=============================
Automaton:
   no_assert
3 variables:
   x, y, z
11 locations:
   l07-c06, l07-c12, l07-c21, l09-c07, l09-c13, l09-c23, l11-c03, l12-c04,
   l14-c04, l17-c00, ~assert
Initial location:
   l07-c06
Final location:
   ~assert
Transitions:
   l07-c06
      » x := 0 » l07-c12
   l07-c12
      » x < 20 » l09-c07
      » x >= 20 » l17-c00
   l07-c21
      » x := (x + 1) » l07-c12
   l09-c07
      » y := 0 » l09-c13
   l09-c13
      » y < (x * x) » l11-c03
      » y >= (x * x) » l07-c21
   l09-c23
      » y := (y + 1) » l09-c13
   l11-c03
      » skip » l12-c04
      » skip » l14-c04
   l12-c04
      » z := (z + 1) » l09-c23
   l14-c04
      » z := (z - 1) » l09-c23

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c06)
           (= x$ 0)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |0|))
      (and (= state l07-c12)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c07)
           (= transition$ |1|))
      (and (= state l07-c12)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l17-c00)
           (= transition$ |2|))
      (and (= state l07-c21)
           (= x$ (+ x 1))
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |3|))
      (and (= state l09-c07)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |4|))
      (and (= state l09-c13)
           (< y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l11-c03)
           (= transition$ |5|))
      (and (= state l09-c13)
           (>= y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c21)
           (= transition$ |6|))
      (and (= state l09-c23)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |7|))
      (and (= state l11-c03) a!1 (= state$ l12-c04) (= transition$ |8|))
      (and (= state l11-c03) a!1 (= state$ l14-c04) (= transition$ |9|))
      (and (= state l12-c04)
           (= z$ (+ z 1))
           (= x x$)
           (= y y$)
           (= state$ l09-c23)
           (= transition$ |10|))
      (and (= state l14-c04)
           (= z$ (- z 1))
           (= x x$)
           (= y y$)
           (= state$ l09-c23)
           (= transition$ |11|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c06: Unknown

=============================
prg/no_assert.c with bound 100
=============================
Automaton:
   no_assert
3 variables:
   x, y, z
11 locations:
   l07-c06, l07-c12, l07-c21, l09-c07, l09-c13, l09-c23, l11-c03, l12-c04,
   l14-c04, l17-c00, ~assert
Initial location:
   l07-c06
Final location:
   ~assert
Transitions:
   l07-c06
      » x := 0 » l07-c12
   l07-c12
      » x < 20 » l09-c07
      » x >= 20 » l17-c00
   l07-c21
      » x := (x + 1) » l07-c12
   l09-c07
      » y := 0 » l09-c13
   l09-c13
      » y < (x * x) » l11-c03
      » y >= (x * x) » l07-c21
   l09-c23
      » y := (y + 1) » l09-c13
   l11-c03
      » skip » l12-c04
      » skip » l14-c04
   l12-c04
      » z := (z + 1) » l09-c23
   l14-c04
      » z := (z - 1) » l09-c23

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c06)
           (= x$ 0)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |0|))
      (and (= state l07-c12)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c07)
           (= transition$ |1|))
      (and (= state l07-c12)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l17-c00)
           (= transition$ |2|))
      (and (= state l07-c21)
           (= x$ (+ x 1))
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |3|))
      (and (= state l09-c07)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |4|))
      (and (= state l09-c13)
           (< y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l11-c03)
           (= transition$ |5|))
      (and (= state l09-c13)
           (>= y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c21)
           (= transition$ |6|))
      (and (= state l09-c23)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |7|))
      (and (= state l11-c03) a!1 (= state$ l12-c04) (= transition$ |8|))
      (and (= state l11-c03) a!1 (= state$ l14-c04) (= transition$ |9|))
      (and (= state l12-c04)
           (= z$ (+ z 1))
           (= x x$)
           (= y y$)
           (= state$ l09-c23)
           (= transition$ |10|))
      (and (= state l14-c04)
           (= z$ (- z 1))
           (= x x$)
           (= y y$)
           (= state$ l09-c23)
           (= transition$ |11|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.
Depth  79: All paths to ~assert are unfeasible.
Depth  80: All paths to ~assert are unfeasible.
Depth  81: All paths to ~assert are unfeasible.
Depth  82: All paths to ~assert are unfeasible.
Depth  83: All paths to ~assert are unfeasible.
Depth  84: All paths to ~assert are unfeasible.
Depth  85: All paths to ~assert are unfeasible.
Depth  86: All paths to ~assert are unfeasible.
Depth  87: All paths to ~assert are unfeasible.
Depth  88: All paths to ~assert are unfeasible.
Depth  89: All paths to ~assert are unfeasible.
Depth  90: All paths to ~assert are unfeasible.
Depth  91: All paths to ~assert are unfeasible.
Depth  92: All paths to ~assert are unfeasible.
Depth  93: All paths to ~assert are unfeasible.
Depth  94: All paths to ~assert are unfeasible.
Depth  95: All paths to ~assert are unfeasible.
Depth  96: All paths to ~assert are unfeasible.
Depth  97: All paths to ~assert are unfeasible.
Depth  98: All paths to ~assert are unfeasible.
Depth  99: All paths to ~assert are unfeasible.
Depth 100: All paths to ~assert are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c06: Unknown

=============================
prg/not_reachable.c with bound 5
=============================
Automaton:
   not_rechable
3 variables:
   x, y, z
12 locations:
   l08-c01, l09-c01, l11-c07, l11-c13, l11-c21, l13-c08, l13-c14, l13-c23,
   l15-c04, l17-c03, l20-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x := 0 » l09-c01
   l09-c01
      » x < 10 » l11-c07
      » x >= 10 » l20-c00
   l11-c07
      » y := x » l11-c13
   l11-c13
      » y < 0 » l13-c08
      » y >= 0 » l09-c01
   l11-c21
      » y := (y + 1) » l11-c13
   l13-c08
      » z := 0 » l13-c14
   l13-c14
      » z < 10 » l15-c04
      » z >= 10 » l17-c03
   l13-c23
      » z := (z + 1) » l13-c14
   l15-c04
      » x := (x + 1) » l13-c23
   l17-c03
      » 0 == 1 » l11-c21
      » 0 != 1 » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state l08-c01)
         (= x$ 0)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |0|))
    (and (= state l09-c01)
         (< x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c07)
         (= transition$ |1|))
    (and (= state l09-c01)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l20-c00)
         (= transition$ |2|))
    (and (= state l11-c07)
         (= y$ x)
         (= x x$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |3|))
    (and (= state l11-c13)
         (< y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c08)
         (= transition$ |4|))
    (and (= state l11-c13)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |5|))
    (and (= state l11-c21)
         (= y$ (+ y 1))
         (= x x$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |6|))
    (and (= state l13-c08)
         (= z$ 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c14)
         (= transition$ |7|))
    (and (= state l13-c14)
         (< z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l15-c04)
         (= transition$ |8|))
    (and (= state l13-c14)
         (>= z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |9|))
    (and (= state l13-c23)
         (= z$ (+ z 1))
         (= x x$)
         (= y y$)
         (= state$ l13-c14)
         (= transition$ |10|))
    (and (= state l15-c04)
         (= x$ (+ x 1))
         (= y y$)
         (= z z$)
         (= state$ l13-c23)
         (= transition$ |11|))
    (and (= state l17-c03)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c21)
         (= transition$ |12|))
    (and (= state l17-c03)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ ~assert)
         (= transition$ |13|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/not_reachable.c with bound 25
=============================
Automaton:
   not_rechable
3 variables:
   x, y, z
12 locations:
   l08-c01, l09-c01, l11-c07, l11-c13, l11-c21, l13-c08, l13-c14, l13-c23,
   l15-c04, l17-c03, l20-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x := 0 » l09-c01
   l09-c01
      » x < 10 » l11-c07
      » x >= 10 » l20-c00
   l11-c07
      » y := x » l11-c13
   l11-c13
      » y < 0 » l13-c08
      » y >= 0 » l09-c01
   l11-c21
      » y := (y + 1) » l11-c13
   l13-c08
      » z := 0 » l13-c14
   l13-c14
      » z < 10 » l15-c04
      » z >= 10 » l17-c03
   l13-c23
      » z := (z + 1) » l13-c14
   l15-c04
      » x := (x + 1) » l13-c23
   l17-c03
      » 0 == 1 » l11-c21
      » 0 != 1 » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state l08-c01)
         (= x$ 0)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |0|))
    (and (= state l09-c01)
         (< x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c07)
         (= transition$ |1|))
    (and (= state l09-c01)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l20-c00)
         (= transition$ |2|))
    (and (= state l11-c07)
         (= y$ x)
         (= x x$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |3|))
    (and (= state l11-c13)
         (< y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c08)
         (= transition$ |4|))
    (and (= state l11-c13)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |5|))
    (and (= state l11-c21)
         (= y$ (+ y 1))
         (= x x$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |6|))
    (and (= state l13-c08)
         (= z$ 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c14)
         (= transition$ |7|))
    (and (= state l13-c14)
         (< z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l15-c04)
         (= transition$ |8|))
    (and (= state l13-c14)
         (>= z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |9|))
    (and (= state l13-c23)
         (= z$ (+ z 1))
         (= x x$)
         (= y y$)
         (= state$ l13-c14)
         (= transition$ |10|))
    (and (= state l15-c04)
         (= x$ (+ x 1))
         (= y y$)
         (= z z$)
         (= state$ l13-c23)
         (= transition$ |11|))
    (and (= state l17-c03)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c21)
         (= transition$ |12|))
    (and (= state l17-c03)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ ~assert)
         (= transition$ |13|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/not_reachable.c with bound 100
=============================
Automaton:
   not_rechable
3 variables:
   x, y, z
12 locations:
   l08-c01, l09-c01, l11-c07, l11-c13, l11-c21, l13-c08, l13-c14, l13-c23,
   l15-c04, l17-c03, l20-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x := 0 » l09-c01
   l09-c01
      » x < 10 » l11-c07
      » x >= 10 » l20-c00
   l11-c07
      » y := x » l11-c13
   l11-c13
      » y < 0 » l13-c08
      » y >= 0 » l09-c01
   l11-c21
      » y := (y + 1) » l11-c13
   l13-c08
      » z := 0 » l13-c14
   l13-c14
      » z < 10 » l15-c04
      » z >= 10 » l17-c03
   l13-c23
      » z := (z + 1) » l13-c14
   l15-c04
      » x := (x + 1) » l13-c23
   l17-c03
      » 0 == 1 » l11-c21
      » 0 != 1 » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state l08-c01)
         (= x$ 0)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |0|))
    (and (= state l09-c01)
         (< x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c07)
         (= transition$ |1|))
    (and (= state l09-c01)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l20-c00)
         (= transition$ |2|))
    (and (= state l11-c07)
         (= y$ x)
         (= x x$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |3|))
    (and (= state l11-c13)
         (< y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c08)
         (= transition$ |4|))
    (and (= state l11-c13)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |5|))
    (and (= state l11-c21)
         (= y$ (+ y 1))
         (= x x$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |6|))
    (and (= state l13-c08)
         (= z$ 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c14)
         (= transition$ |7|))
    (and (= state l13-c14)
         (< z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l15-c04)
         (= transition$ |8|))
    (and (= state l13-c14)
         (>= z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |9|))
    (and (= state l13-c23)
         (= z$ (+ z 1))
         (= x x$)
         (= y y$)
         (= state$ l13-c14)
         (= transition$ |10|))
    (and (= state l15-c04)
         (= x$ (+ x 1))
         (= y y$)
         (= z z$)
         (= state$ l13-c23)
         (= transition$ |11|))
    (and (= state l17-c03)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c21)
         (= transition$ |12|))
    (and (= state l17-c03)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ ~assert)
         (= transition$ |13|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.
Depth  79: All paths to ~assert are unfeasible.
Depth  80: All paths to ~assert are unfeasible.
Depth  81: All paths to ~assert are unfeasible.
Depth  82: All paths to ~assert are unfeasible.
Depth  83: All paths to ~assert are unfeasible.
Depth  84: All paths to ~assert are unfeasible.
Depth  85: All paths to ~assert are unfeasible.
Depth  86: All paths to ~assert are unfeasible.
Depth  87: All paths to ~assert are unfeasible.
Depth  88: All paths to ~assert are unfeasible.
Depth  89: All paths to ~assert are unfeasible.
Depth  90: All paths to ~assert are unfeasible.
Depth  91: All paths to ~assert are unfeasible.
Depth  92: All paths to ~assert are unfeasible.
Depth  93: All paths to ~assert are unfeasible.
Depth  94: All paths to ~assert are unfeasible.
Depth  95: All paths to ~assert are unfeasible.
Depth  96: All paths to ~assert are unfeasible.
Depth  97: All paths to ~assert are unfeasible.
Depth  98: All paths to ~assert are unfeasible.
Depth  99: All paths to ~assert are unfeasible.
Depth 100: All paths to ~assert are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/not_reachable_tractable.c with bound 5
=============================
Automaton:
   not_rechable
2 variables:
   x, y
9 locations:
   l07-c01, l08-c01, l10-c07, l10-c13, l10-c21, l12-c03, l14-c02, l16-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 10 » l10-c07
      » x >= 10 » l16-c00
   l10-c07
      » y := x » l10-c13
   l10-c13
      » y < 0 » l12-c03
      » y >= 0 » l14-c02
   l10-c21
      » y := (y + 1) » l10-c13
   l12-c03
      » 0 == 1 » l10-c21
      » 0 != 1 » ~assert
   l14-c02
      » x := (x + 1) » l08-c01

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state l07-c01)
         (= x$ 0)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (< x 10)
         (= x x$)
         (= y y$)
         (= state$ l10-c07)
         (= transition$ |1|))
    (and (= state l08-c01)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= state$ l16-c00)
         (= transition$ |2|))
    (and (= state l10-c07)
         (= y$ x)
         (= x x$)
         (= state$ l10-c13)
         (= transition$ |3|))
    (and (= state l10-c13)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |4|))
    (and (= state l10-c13)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l10-c21)
         (= y$ (+ y 1))
         (= x x$)
         (= state$ l10-c13)
         (= transition$ |6|))
    (and (= state l12-c03)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= state$ l10-c21)
         (= transition$ |7|))
    (and (= state l12-c03)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |8|))
    (and (= state l14-c02)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |9|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/not_reachable_tractable.c with bound 25
=============================
Automaton:
   not_rechable
2 variables:
   x, y
9 locations:
   l07-c01, l08-c01, l10-c07, l10-c13, l10-c21, l12-c03, l14-c02, l16-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 10 » l10-c07
      » x >= 10 » l16-c00
   l10-c07
      » y := x » l10-c13
   l10-c13
      » y < 0 » l12-c03
      » y >= 0 » l14-c02
   l10-c21
      » y := (y + 1) » l10-c13
   l12-c03
      » 0 == 1 » l10-c21
      » 0 != 1 » ~assert
   l14-c02
      » x := (x + 1) » l08-c01

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state l07-c01)
         (= x$ 0)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (< x 10)
         (= x x$)
         (= y y$)
         (= state$ l10-c07)
         (= transition$ |1|))
    (and (= state l08-c01)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= state$ l16-c00)
         (= transition$ |2|))
    (and (= state l10-c07)
         (= y$ x)
         (= x x$)
         (= state$ l10-c13)
         (= transition$ |3|))
    (and (= state l10-c13)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |4|))
    (and (= state l10-c13)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l10-c21)
         (= y$ (+ y 1))
         (= x x$)
         (= state$ l10-c13)
         (= transition$ |6|))
    (and (= state l12-c03)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= state$ l10-c21)
         (= transition$ |7|))
    (and (= state l12-c03)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |8|))
    (and (= state l14-c02)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |9|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/not_reachable_tractable.c with bound 100
=============================
Automaton:
   not_rechable
2 variables:
   x, y
9 locations:
   l07-c01, l08-c01, l10-c07, l10-c13, l10-c21, l12-c03, l14-c02, l16-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 10 » l10-c07
      » x >= 10 » l16-c00
   l10-c07
      » y := x » l10-c13
   l10-c13
      » y < 0 » l12-c03
      » y >= 0 » l14-c02
   l10-c21
      » y := (y + 1) » l10-c13
   l12-c03
      » 0 == 1 » l10-c21
      » 0 != 1 » ~assert
   l14-c02
      » x := (x + 1) » l08-c01

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state l07-c01)
         (= x$ 0)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (< x 10)
         (= x x$)
         (= y y$)
         (= state$ l10-c07)
         (= transition$ |1|))
    (and (= state l08-c01)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= state$ l16-c00)
         (= transition$ |2|))
    (and (= state l10-c07)
         (= y$ x)
         (= x x$)
         (= state$ l10-c13)
         (= transition$ |3|))
    (and (= state l10-c13)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |4|))
    (and (= state l10-c13)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l10-c21)
         (= y$ (+ y 1))
         (= x x$)
         (= state$ l10-c13)
         (= transition$ |6|))
    (and (= state l12-c03)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= state$ l10-c21)
         (= transition$ |7|))
    (and (= state l12-c03)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |8|))
    (and (= state l14-c02)
         (= x$ (+ x 1))
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |9|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: No feasible path of length 43. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c01: No

=============================
prg/pigeon.c with bound 5
=============================
Automaton:
   pigeon
5 variables:
   pigeon, n1, n2, n3, n4
17 locations:
   l08-c01, l09-c01, l10-c01, l11-c01, l12-c01, l14-c01, l15-c02, l16-c02,
   l17-c03, l19-c03, l20-c04, l22-c04, l23-c05, l25-c05, l26-c02, l28-c00,
   ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » pigeon := 0 » l09-c01
   l09-c01
      » n1 := 0 » l10-c01
   l10-c01
      » n2 := 0 » l11-c01
   l11-c01
      » n3 := 0 » l12-c01
   l12-c01
      » n4 := 0 » l14-c01
   l14-c01
      » 1 != 0 » l15-c02
      » 1 == 0 » l28-c00
   l15-c02
      » pigeon := (pigeon + 1) » l16-c02
   l16-c02
      » skip » l17-c03
      » skip » l19-c03
   l17-c03
      » n1 := (n1 + 1) » l26-c02
   l19-c03
      » skip » l20-c04
      » skip » l22-c04
   l20-c04
      » n2 := (n2 + 1) » l26-c02
   l22-c04
      » skip » l23-c05
      » skip » l25-c05
   l23-c05
      » n3 := (n3 + 1) » l26-c02
   l25-c05
      » n4 := (n4 + 1) » l26-c02
   l26-c02
      » pigeon == (((n1 + n2) + n3) + n4) » l14-c01
      » pigeon != (((n1 + n2) + n3) + n4) » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and true
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)))
      (a!2 (and (= state l26-c02)
                (not (= pigeon (+ n1 n2 n3 n4)))
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)
                (= state$ ~assert)
                (= transition$ |19|))))
  (or (and (= state l08-c01)
           (= pigeon$ 0)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l09-c01)
           (= transition$ |0|))
      (and (= state l09-c01)
           (= n1$ 0)
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l10-c01)
           (= transition$ |1|))
      (and (= state l10-c01)
           (= n2$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l11-c01)
           (= transition$ |2|))
      (and (= state l11-c01)
           (= n3$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l12-c01)
           (= transition$ |3|))
      (and (= state l12-c01)
           (= n4$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l14-c01)
           (= transition$ |4|))
      (and (= state l14-c01)
           (not (= 1 0))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l15-c02)
           (= transition$ |5|))
      (and (= state l14-c01)
           (= 1 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l28-c00)
           (= transition$ |6|))
      (and (= state l15-c02)
           (= pigeon$ (+ pigeon 1))
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l16-c02)
           (= transition$ |7|))
      (and (= state l16-c02) a!1 (= state$ l17-c03) (= transition$ |8|))
      (and (= state l16-c02) a!1 (= state$ l19-c03) (= transition$ |9|))
      (and (= state l17-c03)
           (= n1$ (+ n1 1))
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |10|))
      (and (= state l19-c03) a!1 (= state$ l20-c04) (= transition$ |11|))
      (and (= state l19-c03) a!1 (= state$ l22-c04) (= transition$ |12|))
      (and (= state l20-c04)
           (= n2$ (+ n2 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |13|))
      (and (= state l22-c04) a!1 (= state$ l23-c05) (= transition$ |14|))
      (and (= state l22-c04) a!1 (= state$ l25-c05) (= transition$ |15|))
      (and (= state l23-c05)
           (= n3$ (+ n3 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |16|))
      (and (= state l25-c05)
           (= n4$ (+ n4 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l26-c02)
           (= transition$ |17|))
      (and (= state l26-c02)
           (= pigeon (+ n1 n2 n3 n4))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |18|))
      a!2))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/pigeon.c with bound 25
=============================
Automaton:
   pigeon
5 variables:
   pigeon, n1, n2, n3, n4
17 locations:
   l08-c01, l09-c01, l10-c01, l11-c01, l12-c01, l14-c01, l15-c02, l16-c02,
   l17-c03, l19-c03, l20-c04, l22-c04, l23-c05, l25-c05, l26-c02, l28-c00,
   ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » pigeon := 0 » l09-c01
   l09-c01
      » n1 := 0 » l10-c01
   l10-c01
      » n2 := 0 » l11-c01
   l11-c01
      » n3 := 0 » l12-c01
   l12-c01
      » n4 := 0 » l14-c01
   l14-c01
      » 1 != 0 » l15-c02
      » 1 == 0 » l28-c00
   l15-c02
      » pigeon := (pigeon + 1) » l16-c02
   l16-c02
      » skip » l17-c03
      » skip » l19-c03
   l17-c03
      » n1 := (n1 + 1) » l26-c02
   l19-c03
      » skip » l20-c04
      » skip » l22-c04
   l20-c04
      » n2 := (n2 + 1) » l26-c02
   l22-c04
      » skip » l23-c05
      » skip » l25-c05
   l23-c05
      » n3 := (n3 + 1) » l26-c02
   l25-c05
      » n4 := (n4 + 1) » l26-c02
   l26-c02
      » pigeon == (((n1 + n2) + n3) + n4) » l14-c01
      » pigeon != (((n1 + n2) + n3) + n4) » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and true
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)))
      (a!2 (and (= state l26-c02)
                (not (= pigeon (+ n1 n2 n3 n4)))
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)
                (= state$ ~assert)
                (= transition$ |19|))))
  (or (and (= state l08-c01)
           (= pigeon$ 0)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l09-c01)
           (= transition$ |0|))
      (and (= state l09-c01)
           (= n1$ 0)
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l10-c01)
           (= transition$ |1|))
      (and (= state l10-c01)
           (= n2$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l11-c01)
           (= transition$ |2|))
      (and (= state l11-c01)
           (= n3$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l12-c01)
           (= transition$ |3|))
      (and (= state l12-c01)
           (= n4$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l14-c01)
           (= transition$ |4|))
      (and (= state l14-c01)
           (not (= 1 0))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l15-c02)
           (= transition$ |5|))
      (and (= state l14-c01)
           (= 1 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l28-c00)
           (= transition$ |6|))
      (and (= state l15-c02)
           (= pigeon$ (+ pigeon 1))
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l16-c02)
           (= transition$ |7|))
      (and (= state l16-c02) a!1 (= state$ l17-c03) (= transition$ |8|))
      (and (= state l16-c02) a!1 (= state$ l19-c03) (= transition$ |9|))
      (and (= state l17-c03)
           (= n1$ (+ n1 1))
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |10|))
      (and (= state l19-c03) a!1 (= state$ l20-c04) (= transition$ |11|))
      (and (= state l19-c03) a!1 (= state$ l22-c04) (= transition$ |12|))
      (and (= state l20-c04)
           (= n2$ (+ n2 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |13|))
      (and (= state l22-c04) a!1 (= state$ l23-c05) (= transition$ |14|))
      (and (= state l22-c04) a!1 (= state$ l25-c05) (= transition$ |15|))
      (and (= state l23-c05)
           (= n3$ (+ n3 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |16|))
      (and (= state l25-c05)
           (= n4$ (+ n4 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l26-c02)
           (= transition$ |17|))
      (and (= state l26-c02)
           (= pigeon (+ n1 n2 n3 n4))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |18|))
      a!2))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/pigeon.c with bound 100
=============================
Automaton:
   pigeon
5 variables:
   pigeon, n1, n2, n3, n4
17 locations:
   l08-c01, l09-c01, l10-c01, l11-c01, l12-c01, l14-c01, l15-c02, l16-c02,
   l17-c03, l19-c03, l20-c04, l22-c04, l23-c05, l25-c05, l26-c02, l28-c00,
   ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » pigeon := 0 » l09-c01
   l09-c01
      » n1 := 0 » l10-c01
   l10-c01
      » n2 := 0 » l11-c01
   l11-c01
      » n3 := 0 » l12-c01
   l12-c01
      » n4 := 0 » l14-c01
   l14-c01
      » 1 != 0 » l15-c02
      » 1 == 0 » l28-c00
   l15-c02
      » pigeon := (pigeon + 1) » l16-c02
   l16-c02
      » skip » l17-c03
      » skip » l19-c03
   l17-c03
      » n1 := (n1 + 1) » l26-c02
   l19-c03
      » skip » l20-c04
      » skip » l22-c04
   l20-c04
      » n2 := (n2 + 1) » l26-c02
   l22-c04
      » skip » l23-c05
      » skip » l25-c05
   l23-c05
      » n3 := (n3 + 1) » l26-c02
   l25-c05
      » n4 := (n4 + 1) » l26-c02
   l26-c02
      » pigeon == (((n1 + n2) + n3) + n4) » l14-c01
      » pigeon != (((n1 + n2) + n3) + n4) » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and true
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)))
      (a!2 (and (= state l26-c02)
                (not (= pigeon (+ n1 n2 n3 n4)))
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)
                (= state$ ~assert)
                (= transition$ |19|))))
  (or (and (= state l08-c01)
           (= pigeon$ 0)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l09-c01)
           (= transition$ |0|))
      (and (= state l09-c01)
           (= n1$ 0)
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l10-c01)
           (= transition$ |1|))
      (and (= state l10-c01)
           (= n2$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l11-c01)
           (= transition$ |2|))
      (and (= state l11-c01)
           (= n3$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l12-c01)
           (= transition$ |3|))
      (and (= state l12-c01)
           (= n4$ 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l14-c01)
           (= transition$ |4|))
      (and (= state l14-c01)
           (not (= 1 0))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l15-c02)
           (= transition$ |5|))
      (and (= state l14-c01)
           (= 1 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l28-c00)
           (= transition$ |6|))
      (and (= state l15-c02)
           (= pigeon$ (+ pigeon 1))
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l16-c02)
           (= transition$ |7|))
      (and (= state l16-c02) a!1 (= state$ l17-c03) (= transition$ |8|))
      (and (= state l16-c02) a!1 (= state$ l19-c03) (= transition$ |9|))
      (and (= state l17-c03)
           (= n1$ (+ n1 1))
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |10|))
      (and (= state l19-c03) a!1 (= state$ l20-c04) (= transition$ |11|))
      (and (= state l19-c03) a!1 (= state$ l22-c04) (= transition$ |12|))
      (and (= state l20-c04)
           (= n2$ (+ n2 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |13|))
      (and (= state l22-c04) a!1 (= state$ l23-c05) (= transition$ |14|))
      (and (= state l22-c04) a!1 (= state$ l25-c05) (= transition$ |15|))
      (and (= state l23-c05)
           (= n3$ (+ n3 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |16|))
      (and (= state l25-c05)
           (= n4$ (+ n4 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l26-c02)
           (= transition$ |17|))
      (and (= state l26-c02)
           (= pigeon (+ n1 n2 n3 n4))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |18|))
      a!2))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.

=============================
prg/relational.c with bound 5
=============================
Automaton:
   relational
3 variables:
   x, y, z
10 locations:
   l07-c01, l08-c06, l08-c13, l08-c22, l10-c02, l11-c03, l13-c03, l15-c01,
   l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c06
   l08-c06
      » y := 0 » l08-c13
   l08-c13
      » y < z » l10-c02
      » y >= z » l15-c01
   l08-c22
      » y := (y + 1) » l08-c13
   l10-c02
      » skip » l11-c03
      » skip » l13-c03
   l11-c03
      » x := (x + 5) » l08-c22
   l13-c03
      » x := (x + 3) » l08-c22
   l15-c01
      » x > (2 * z) » l16-c00
      » x <= (2 * z) » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c01)
           (= x$ 1)
           (= y y$)
           (= z z$)
           (= state$ l08-c06)
           (= transition$ |0|))
      (and (= state l08-c06)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |1|))
      (and (= state l08-c13)
           (< y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c02)
           (= transition$ |2|))
      (and (= state l08-c13)
           (>= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |3|))
      (and (= state l08-c22)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |4|))
      (and (= state l10-c02) a!1 (= state$ l11-c03) (= transition$ |5|))
      (and (= state l10-c02) a!1 (= state$ l13-c03) (= transition$ |6|))
      (and (= state l11-c03)
           (= x$ (+ x 5))
           (= y y$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |7|))
      (and (= state l13-c03)
           (= x$ (+ x 3))
           (= y y$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |8|))
      (and (= state l15-c01)
           (> x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l16-c00)
           (= transition$ |9|))
      (and (= state l15-c01)
           (<= x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ ~assert)
           (= transition$ |10|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/relational.c with bound 25
=============================
Automaton:
   relational
3 variables:
   x, y, z
10 locations:
   l07-c01, l08-c06, l08-c13, l08-c22, l10-c02, l11-c03, l13-c03, l15-c01,
   l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c06
   l08-c06
      » y := 0 » l08-c13
   l08-c13
      » y < z » l10-c02
      » y >= z » l15-c01
   l08-c22
      » y := (y + 1) » l08-c13
   l10-c02
      » skip » l11-c03
      » skip » l13-c03
   l11-c03
      » x := (x + 5) » l08-c22
   l13-c03
      » x := (x + 3) » l08-c22
   l15-c01
      » x > (2 * z) » l16-c00
      » x <= (2 * z) » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c01)
           (= x$ 1)
           (= y y$)
           (= z z$)
           (= state$ l08-c06)
           (= transition$ |0|))
      (and (= state l08-c06)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |1|))
      (and (= state l08-c13)
           (< y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c02)
           (= transition$ |2|))
      (and (= state l08-c13)
           (>= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |3|))
      (and (= state l08-c22)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |4|))
      (and (= state l10-c02) a!1 (= state$ l11-c03) (= transition$ |5|))
      (and (= state l10-c02) a!1 (= state$ l13-c03) (= transition$ |6|))
      (and (= state l11-c03)
           (= x$ (+ x 5))
           (= y y$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |7|))
      (and (= state l13-c03)
           (= x$ (+ x 3))
           (= y y$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |8|))
      (and (= state l15-c01)
           (> x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l16-c00)
           (= transition$ |9|))
      (and (= state l15-c01)
           (<= x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ ~assert)
           (= transition$ |10|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/relational.c with bound 100
=============================
Automaton:
   relational
3 variables:
   x, y, z
10 locations:
   l07-c01, l08-c06, l08-c13, l08-c22, l10-c02, l11-c03, l13-c03, l15-c01,
   l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c06
   l08-c06
      » y := 0 » l08-c13
   l08-c13
      » y < z » l10-c02
      » y >= z » l15-c01
   l08-c22
      » y := (y + 1) » l08-c13
   l10-c02
      » skip » l11-c03
      » skip » l13-c03
   l11-c03
      » x := (x + 5) » l08-c22
   l13-c03
      » x := (x + 3) » l08-c22
   l15-c01
      » x > (2 * z) » l16-c00
      » x <= (2 * z) » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l07-c01)
           (= x$ 1)
           (= y y$)
           (= z z$)
           (= state$ l08-c06)
           (= transition$ |0|))
      (and (= state l08-c06)
           (= y$ 0)
           (= x x$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |1|))
      (and (= state l08-c13)
           (< y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c02)
           (= transition$ |2|))
      (and (= state l08-c13)
           (>= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |3|))
      (and (= state l08-c22)
           (= y$ (+ y 1))
           (= x x$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |4|))
      (and (= state l10-c02) a!1 (= state$ l11-c03) (= transition$ |5|))
      (and (= state l10-c02) a!1 (= state$ l13-c03) (= transition$ |6|))
      (and (= state l11-c03)
           (= x$ (+ x 5))
           (= y y$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |7|))
      (and (= state l13-c03)
           (= x$ (+ x 3))
           (= y y$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |8|))
      (and (= state l15-c01)
           (> x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l16-c00)
           (= transition$ |9|))
      (and (= state l15-c01)
           (<= x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ ~assert)
           (= transition$ |10|))))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.
Depth  79: All paths to ~assert are unfeasible.
Depth  80: All paths to ~assert are unfeasible.
Depth  81: All paths to ~assert are unfeasible.
Depth  82: All paths to ~assert are unfeasible.
Depth  83: All paths to ~assert are unfeasible.
Depth  84: All paths to ~assert are unfeasible.
Depth  85: All paths to ~assert are unfeasible.
Depth  86: All paths to ~assert are unfeasible.
Depth  87: All paths to ~assert are unfeasible.
Depth  88: All paths to ~assert are unfeasible.
Depth  89: All paths to ~assert are unfeasible.
Depth  90: All paths to ~assert are unfeasible.
Depth  91: All paths to ~assert are unfeasible.
Depth  92: All paths to ~assert are unfeasible.
Depth  93: All paths to ~assert are unfeasible.
Depth  94: All paths to ~assert are unfeasible.
Depth  95: All paths to ~assert are unfeasible.
Depth  96: All paths to ~assert are unfeasible.
Depth  97: All paths to ~assert are unfeasible.
Depth  98: All paths to ~assert are unfeasible.
Depth  99: All paths to ~assert are unfeasible.
Depth 100: All paths to ~assert are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/running_example.c with bound 5
=============================
Automaton:
   running
2 variables:
   x, y
10 locations:
   l07-c01, l08-c01, l09-c02, l11-c02, l13-c03, l14-c03, l16-c01, l17-c01,
   l18-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c01
   l08-c01
      » y <= 10 » l09-c02
      » y > 10 » l11-c02
   l09-c02
      » y := 10 » l16-c01
   l11-c02
      » x < y » l13-c03
      » x >= y » l16-c01
   l13-c03
      » x := (2 * x) » l14-c03
   l14-c03
      » y := (y - 1) » l11-c02
   l16-c01
      » x := (y + 1) » l17-c01
   l17-c01
      » x > 0 » l18-c00
      » x <= 0 » ~assert

Bounded model checking: forward, depth <= 5

Step formula:
  (or (and (= state l07-c01)
         (= x$ 1)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ l09-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |2|))
    (and (= state l09-c02)
         (= y$ 10)
         (= x x$)
         (= state$ l16-c01)
         (= transition$ |3|))
    (and (= state l11-c02)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |4|))
    (and (= state l11-c02)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ l16-c01)
         (= transition$ |5|))
    (and (= state l13-c03)
         (= x$ (* 2 x))
         (= y y$)
         (= state$ l14-c03)
         (= transition$ |6|))
    (and (= state l14-c03)
         (= y$ (- y 1))
         (= x x$)
         (= state$ l11-c02)
         (= transition$ |7|))
    (and (= state l16-c01)
         (= x$ (+ y 1))
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |8|))
    (and (= state l17-c01)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c00)
         (= transition$ |9|))
    (and (= state l17-c01)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |10|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/running_example.c with bound 25
=============================
Automaton:
   running
2 variables:
   x, y
10 locations:
   l07-c01, l08-c01, l09-c02, l11-c02, l13-c03, l14-c03, l16-c01, l17-c01,
   l18-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c01
   l08-c01
      » y <= 10 » l09-c02
      » y > 10 » l11-c02
   l09-c02
      » y := 10 » l16-c01
   l11-c02
      » x < y » l13-c03
      » x >= y » l16-c01
   l13-c03
      » x := (2 * x) » l14-c03
   l14-c03
      » y := (y - 1) » l11-c02
   l16-c01
      » x := (y + 1) » l17-c01
   l17-c01
      » x > 0 » l18-c00
      » x <= 0 » ~assert

Bounded model checking: forward, depth <= 25

Step formula:
  (or (and (= state l07-c01)
         (= x$ 1)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ l09-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |2|))
    (and (= state l09-c02)
         (= y$ 10)
         (= x x$)
         (= state$ l16-c01)
         (= transition$ |3|))
    (and (= state l11-c02)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |4|))
    (and (= state l11-c02)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ l16-c01)
         (= transition$ |5|))
    (and (= state l13-c03)
         (= x$ (* 2 x))
         (= y y$)
         (= state$ l14-c03)
         (= transition$ |6|))
    (and (= state l14-c03)
         (= y$ (- y 1))
         (= x x$)
         (= state$ l11-c02)
         (= transition$ |7|))
    (and (= state l16-c01)
         (= x$ (+ y 1))
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |8|))
    (and (= state l17-c01)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c00)
         (= transition$ |9|))
    (and (= state l17-c01)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |10|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/running_example.c with bound 100
=============================
Automaton:
   running
2 variables:
   x, y
10 locations:
   l07-c01, l08-c01, l09-c02, l11-c02, l13-c03, l14-c03, l16-c01, l17-c01,
   l18-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c01
   l08-c01
      » y <= 10 » l09-c02
      » y > 10 » l11-c02
   l09-c02
      » y := 10 » l16-c01
   l11-c02
      » x < y » l13-c03
      » x >= y » l16-c01
   l13-c03
      » x := (2 * x) » l14-c03
   l14-c03
      » y := (y - 1) » l11-c02
   l16-c01
      » x := (y + 1) » l17-c01
   l17-c01
      » x > 0 » l18-c00
      » x <= 0 » ~assert

Bounded model checking: forward, depth <= 100

Step formula:
  (or (and (= state l07-c01)
         (= x$ 1)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |0|))
    (and (= state l08-c01)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ l09-c02)
         (= transition$ |1|))
    (and (= state l08-c01)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |2|))
    (and (= state l09-c02)
         (= y$ 10)
         (= x x$)
         (= state$ l16-c01)
         (= transition$ |3|))
    (and (= state l11-c02)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |4|))
    (and (= state l11-c02)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ l16-c01)
         (= transition$ |5|))
    (and (= state l13-c03)
         (= x$ (* 2 x))
         (= y y$)
         (= state$ l14-c03)
         (= transition$ |6|))
    (and (= state l14-c03)
         (= y$ (- y 1))
         (= x x$)
         (= state$ l11-c02)
         (= transition$ |7|))
    (and (= state l16-c01)
         (= x$ (+ y 1))
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |8|))
    (and (= state l17-c01)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c00)
         (= transition$ |9|))
    (and (= state l17-c01)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ ~assert)
         (= transition$ |10|)))

Depth   1: All paths to ~assert are unfeasible.
Depth   2: All paths to ~assert are unfeasible.
Depth   3: All paths to ~assert are unfeasible.
Depth   4: All paths to ~assert are unfeasible.
Depth   5: All paths to ~assert are unfeasible.
Depth   6: All paths to ~assert are unfeasible.
Depth   7: All paths to ~assert are unfeasible.
Depth   8: All paths to ~assert are unfeasible.
Depth   9: All paths to ~assert are unfeasible.
Depth  10: All paths to ~assert are unfeasible.
Depth  11: All paths to ~assert are unfeasible.
Depth  12: All paths to ~assert are unfeasible.
Depth  13: All paths to ~assert are unfeasible.
Depth  14: All paths to ~assert are unfeasible.
Depth  15: All paths to ~assert are unfeasible.
Depth  16: All paths to ~assert are unfeasible.
Depth  17: All paths to ~assert are unfeasible.
Depth  18: All paths to ~assert are unfeasible.
Depth  19: All paths to ~assert are unfeasible.
Depth  20: All paths to ~assert are unfeasible.
Depth  21: All paths to ~assert are unfeasible.
Depth  22: All paths to ~assert are unfeasible.
Depth  23: All paths to ~assert are unfeasible.
Depth  24: All paths to ~assert are unfeasible.
Depth  25: All paths to ~assert are unfeasible.
Depth  26: All paths to ~assert are unfeasible.
Depth  27: All paths to ~assert are unfeasible.
Depth  28: All paths to ~assert are unfeasible.
Depth  29: All paths to ~assert are unfeasible.
Depth  30: All paths to ~assert are unfeasible.
Depth  31: All paths to ~assert are unfeasible.
Depth  32: All paths to ~assert are unfeasible.
Depth  33: All paths to ~assert are unfeasible.
Depth  34: All paths to ~assert are unfeasible.
Depth  35: All paths to ~assert are unfeasible.
Depth  36: All paths to ~assert are unfeasible.
Depth  37: All paths to ~assert are unfeasible.
Depth  38: All paths to ~assert are unfeasible.
Depth  39: All paths to ~assert are unfeasible.
Depth  40: All paths to ~assert are unfeasible.
Depth  41: All paths to ~assert are unfeasible.
Depth  42: All paths to ~assert are unfeasible.
Depth  43: All paths to ~assert are unfeasible.
Depth  44: All paths to ~assert are unfeasible.
Depth  45: All paths to ~assert are unfeasible.
Depth  46: All paths to ~assert are unfeasible.
Depth  47: All paths to ~assert are unfeasible.
Depth  48: All paths to ~assert are unfeasible.
Depth  49: All paths to ~assert are unfeasible.
Depth  50: All paths to ~assert are unfeasible.
Depth  51: All paths to ~assert are unfeasible.
Depth  52: All paths to ~assert are unfeasible.
Depth  53: All paths to ~assert are unfeasible.
Depth  54: All paths to ~assert are unfeasible.
Depth  55: All paths to ~assert are unfeasible.
Depth  56: All paths to ~assert are unfeasible.
Depth  57: All paths to ~assert are unfeasible.
Depth  58: All paths to ~assert are unfeasible.
Depth  59: All paths to ~assert are unfeasible.
Depth  60: All paths to ~assert are unfeasible.
Depth  61: All paths to ~assert are unfeasible.
Depth  62: All paths to ~assert are unfeasible.
Depth  63: All paths to ~assert are unfeasible.
Depth  64: All paths to ~assert are unfeasible.
Depth  65: All paths to ~assert are unfeasible.
Depth  66: All paths to ~assert are unfeasible.
Depth  67: All paths to ~assert are unfeasible.
Depth  68: All paths to ~assert are unfeasible.
Depth  69: All paths to ~assert are unfeasible.
Depth  70: All paths to ~assert are unfeasible.
Depth  71: All paths to ~assert are unfeasible.
Depth  72: All paths to ~assert are unfeasible.
Depth  73: All paths to ~assert are unfeasible.
Depth  74: All paths to ~assert are unfeasible.
Depth  75: All paths to ~assert are unfeasible.
Depth  76: All paths to ~assert are unfeasible.
Depth  77: All paths to ~assert are unfeasible.
Depth  78: All paths to ~assert are unfeasible.
Depth  79: All paths to ~assert are unfeasible.
Depth  80: All paths to ~assert are unfeasible.
Depth  81: All paths to ~assert are unfeasible.
Depth  82: All paths to ~assert are unfeasible.
Depth  83: All paths to ~assert are unfeasible.
Depth  84: All paths to ~assert are unfeasible.
Depth  85: All paths to ~assert are unfeasible.
Depth  86: All paths to ~assert are unfeasible.
Depth  87: All paths to ~assert are unfeasible.
Depth  88: All paths to ~assert are unfeasible.
Depth  89: All paths to ~assert are unfeasible.
Depth  90: All paths to ~assert are unfeasible.
Depth  91: All paths to ~assert are unfeasible.
Depth  92: All paths to ~assert are unfeasible.
Depth  93: All paths to ~assert are unfeasible.
Depth  94: All paths to ~assert are unfeasible.
Depth  95: All paths to ~assert are unfeasible.
Depth  96: All paths to ~assert are unfeasible.
Depth  97: All paths to ~assert are unfeasible.
Depth  98: All paths to ~assert are unfeasible.
Depth  99: All paths to ~assert are unfeasible.
Depth 100: All paths to ~assert are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

####################
# Backward Analysis #
####################

=============================
aut/another_example.aut with bound 5
=============================
Automaton:
   Another_Example
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 3 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x > y » q_3
      » x < 0 » q_bad
   q_3
      » y := (y + x) » q_4
   q_4
      » x := (x - 1) » q_2

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad)
         (< x 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_4)
         (= y (+ y$ x))
         (= x x$)
         (= state$ q_3)
         (= transition$ |1|))
    (and (= state q_3)
         (> x y)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_2) (= y 0) (= x x$) (= state$ q_1) (= transition$ |3|))
    (and (= state q_2)
         (= x (- x$ 1))
         (= y y$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_1) (= x 3) (= y y$) (= state$ q_0) (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/another_example.aut with bound 25
=============================
Automaton:
   Another_Example
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 3 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x > y » q_3
      » x < 0 » q_bad
   q_3
      » y := (y + x) » q_4
   q_4
      » x := (x - 1) » q_2

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad)
         (< x 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_4)
         (= y (+ y$ x))
         (= x x$)
         (= state$ q_3)
         (= transition$ |1|))
    (and (= state q_3)
         (> x y)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_2) (= y 0) (= x x$) (= state$ q_1) (= transition$ |3|))
    (and (= state q_2)
         (= x (- x$ 1))
         (= y y$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_1) (= x 3) (= y y$) (= state$ q_0) (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/another_example.aut with bound 100
=============================
Automaton:
   Another_Example
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 3 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x > y » q_3
      » x < 0 » q_bad
   q_3
      » y := (y + x) » q_4
   q_4
      » x := (x - 1) » q_2

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad)
         (< x 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_4)
         (= y (+ y$ x))
         (= x x$)
         (= state$ q_3)
         (= transition$ |1|))
    (and (= state q_3)
         (> x y)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_2) (= y 0) (= x x$) (= state$ q_1) (= transition$ |3|))
    (and (= state q_2)
         (= x (- x$ 1))
         (= y y$)
         (= state$ q_4)
         (= transition$ |4|))
    (and (= state q_1) (= x 3) (= y y$) (= state$ q_0) (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: All paths to q_0 are unfeasible.
Depth  27: All paths to q_0 are unfeasible.
Depth  28: All paths to q_0 are unfeasible.
Depth  29: All paths to q_0 are unfeasible.
Depth  30: All paths to q_0 are unfeasible.
Depth  31: All paths to q_0 are unfeasible.
Depth  32: All paths to q_0 are unfeasible.
Depth  33: All paths to q_0 are unfeasible.
Depth  34: All paths to q_0 are unfeasible.
Depth  35: All paths to q_0 are unfeasible.
Depth  36: All paths to q_0 are unfeasible.
Depth  37: All paths to q_0 are unfeasible.
Depth  38: All paths to q_0 are unfeasible.
Depth  39: All paths to q_0 are unfeasible.
Depth  40: All paths to q_0 are unfeasible.
Depth  41: All paths to q_0 are unfeasible.
Depth  42: All paths to q_0 are unfeasible.
Depth  43: All paths to q_0 are unfeasible.
Depth  44: All paths to q_0 are unfeasible.
Depth  45: All paths to q_0 are unfeasible.
Depth  46: All paths to q_0 are unfeasible.
Depth  47: All paths to q_0 are unfeasible.
Depth  48: All paths to q_0 are unfeasible.
Depth  49: All paths to q_0 are unfeasible.
Depth  50: All paths to q_0 are unfeasible.
Depth  51: All paths to q_0 are unfeasible.
Depth  52: All paths to q_0 are unfeasible.
Depth  53: All paths to q_0 are unfeasible.
Depth  54: All paths to q_0 are unfeasible.
Depth  55: All paths to q_0 are unfeasible.
Depth  56: All paths to q_0 are unfeasible.
Depth  57: All paths to q_0 are unfeasible.
Depth  58: All paths to q_0 are unfeasible.
Depth  59: All paths to q_0 are unfeasible.
Depth  60: All paths to q_0 are unfeasible.
Depth  61: All paths to q_0 are unfeasible.
Depth  62: All paths to q_0 are unfeasible.
Depth  63: All paths to q_0 are unfeasible.
Depth  64: All paths to q_0 are unfeasible.
Depth  65: All paths to q_0 are unfeasible.
Depth  66: All paths to q_0 are unfeasible.
Depth  67: All paths to q_0 are unfeasible.
Depth  68: All paths to q_0 are unfeasible.
Depth  69: All paths to q_0 are unfeasible.
Depth  70: All paths to q_0 are unfeasible.
Depth  71: All paths to q_0 are unfeasible.
Depth  72: All paths to q_0 are unfeasible.
Depth  73: All paths to q_0 are unfeasible.
Depth  74: All paths to q_0 are unfeasible.
Depth  75: All paths to q_0 are unfeasible.
Depth  76: All paths to q_0 are unfeasible.
Depth  77: All paths to q_0 are unfeasible.
Depth  78: All paths to q_0 are unfeasible.
Depth  79: All paths to q_0 are unfeasible.
Depth  80: All paths to q_0 are unfeasible.
Depth  81: All paths to q_0 are unfeasible.
Depth  82: All paths to q_0 are unfeasible.
Depth  83: All paths to q_0 are unfeasible.
Depth  84: All paths to q_0 are unfeasible.
Depth  85: All paths to q_0 are unfeasible.
Depth  86: All paths to q_0 are unfeasible.
Depth  87: All paths to q_0 are unfeasible.
Depth  88: All paths to q_0 are unfeasible.
Depth  89: All paths to q_0 are unfeasible.
Depth  90: All paths to q_0 are unfeasible.
Depth  91: All paths to q_0 are unfeasible.
Depth  92: All paths to q_0 are unfeasible.
Depth  93: All paths to q_0 are unfeasible.
Depth  94: All paths to q_0 are unfeasible.
Depth  95: All paths to q_0 are unfeasible.
Depth  96: All paths to q_0 are unfeasible.
Depth  97: All paths to q_0 are unfeasible.
Depth  98: All paths to q_0 are unfeasible.
Depth  99: All paths to q_0 are unfeasible.
Depth 100: All paths to q_0 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/big_integers.aut with bound 5
=============================
Automaton:
   Big_Integers
4 variables:
   max_int, min_int, y, z
8 locations:
   q_0, q_1, q_2, q_bad, q_y_large, q_y_small, q_z_large, q_z_small
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » max_int := 4611686018427387903 » q_1
   q_1
      » min_int := (-4611686018427387903 - 1) » q_2
   q_2
      » y := (max_int + 1) » q_y_large
      » z := (2 * max_int) » q_z_large
      » y := (min_int - 1) » q_y_small
      » z := (2 * min_int) » q_z_small
   q_y_large
      » y <= max_int » q_bad
   q_y_small
      » y >= min_int » q_bad
   q_z_large
      » z <= max_int » q_bad
   q_z_small
      » z >= min_int » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_z_small)
         (= z (* 2 min_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_z_large)
         (= z (* 2 max_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_y_small)
         (= y (- min_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_y_large)
         (= y (+ max_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_bad)
         (<= y max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_y_large)
         (= transition$ |4|))
    (and (= state q_bad)
         (<= z max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_z_large)
         (= transition$ |5|))
    (and (= state q_bad)
         (>= y min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_y_small)
         (= transition$ |6|))
    (and (= state q_bad)
         (>= z min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_z_small)
         (= transition$ |7|))
    (and (= state q_2)
         (= min_int (- (- 4611686018427387903) 1))
         (= max_int max_int$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |8|))
    (and (= state q_1)
         (= max_int 4611686018427387903)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |9|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/big_integers.aut with bound 25
=============================
Automaton:
   Big_Integers
4 variables:
   max_int, min_int, y, z
8 locations:
   q_0, q_1, q_2, q_bad, q_y_large, q_y_small, q_z_large, q_z_small
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » max_int := 4611686018427387903 » q_1
   q_1
      » min_int := (-4611686018427387903 - 1) » q_2
   q_2
      » y := (max_int + 1) » q_y_large
      » z := (2 * max_int) » q_z_large
      » y := (min_int - 1) » q_y_small
      » z := (2 * min_int) » q_z_small
   q_y_large
      » y <= max_int » q_bad
   q_y_small
      » y >= min_int » q_bad
   q_z_large
      » z <= max_int » q_bad
   q_z_small
      » z >= min_int » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_z_small)
         (= z (* 2 min_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_z_large)
         (= z (* 2 max_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_y_small)
         (= y (- min_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_y_large)
         (= y (+ max_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_bad)
         (<= y max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_y_large)
         (= transition$ |4|))
    (and (= state q_bad)
         (<= z max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_z_large)
         (= transition$ |5|))
    (and (= state q_bad)
         (>= y min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_y_small)
         (= transition$ |6|))
    (and (= state q_bad)
         (>= z min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_z_small)
         (= transition$ |7|))
    (and (= state q_2)
         (= min_int (- (- 4611686018427387903) 1))
         (= max_int max_int$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |8|))
    (and (= state q_1)
         (= max_int 4611686018427387903)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |9|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/big_integers.aut with bound 100
=============================
Automaton:
   Big_Integers
4 variables:
   max_int, min_int, y, z
8 locations:
   q_0, q_1, q_2, q_bad, q_y_large, q_y_small, q_z_large, q_z_small
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » max_int := 4611686018427387903 » q_1
   q_1
      » min_int := (-4611686018427387903 - 1) » q_2
   q_2
      » y := (max_int + 1) » q_y_large
      » z := (2 * max_int) » q_z_large
      » y := (min_int - 1) » q_y_small
      » z := (2 * min_int) » q_z_small
   q_y_large
      » y <= max_int » q_bad
   q_y_small
      » y >= min_int » q_bad
   q_z_large
      » z <= max_int » q_bad
   q_z_small
      » z >= min_int » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_z_small)
         (= z (* 2 min_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_z_large)
         (= z (* 2 max_int))
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_y_small)
         (= y (- min_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_y_large)
         (= y (+ max_int 1))
         (= max_int max_int$)
         (= min_int min_int$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_bad)
         (<= y max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_y_large)
         (= transition$ |4|))
    (and (= state q_bad)
         (<= z max_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_z_large)
         (= transition$ |5|))
    (and (= state q_bad)
         (>= y min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_y_small)
         (= transition$ |6|))
    (and (= state q_bad)
         (>= z min_int)
         (= max_int max_int$)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_z_small)
         (= transition$ |7|))
    (and (= state q_2)
         (= min_int (- (- 4611686018427387903) 1))
         (= max_int max_int$)
         (= y y$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |8|))
    (and (= state q_1)
         (= max_int 4611686018427387903)
         (= min_int min_int$)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |9|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/congruence_1.aut with bound 5
=============================
Automaton:
   Congruence_1
3 variables:
   x, y, z
10 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := 5 » q_02
   q_02
      » x != 5 » q_bad
      » x < 2 » q_bad
      » x <= 3 » q_bad
      » x >= 7 » q_bad
      » x > 8 » q_bad
      » (x + 8) != 13 » q_bad
      » (x - 8) != -3 » q_bad
      » (0 * x) != 0 » q_bad
      » (x * 3) != 15 » q_bad
      » (x / 2) != 2 » q_bad
      » (x / 3) != 1 » q_bad
      » (2 / x) != 0 » q_bad
      » (-7 / x) != -1 » q_bad
      » (x * y) == 18 » q_bad
      » (x * y) == 15 » q_03
   q_03
      » (y * z) == x » q_bad
      » ((y * z) - x) == y » q_bad
      » z := (x + y) » q_04
      » z := (y + x) » q_04
      » z == (x + y) » q_04
      » z := (x - y) » q_05
      » x == (y + z) » q_05
      » z := (y - x) » q_06
      » (x + z) == y » q_06
      » z := (x * y) » q_07
      » z := (y * x) » q_07
      » z := (x / y) » q_08
      » z := (y / x) » q_09
   q_04
      » z == (x - y) » q_bad
      » ((x * y) * z) <= ((x + y) + z) » q_bad
      » (z / x) > y » q_bad
   q_05
      » ((x + y) + z) != 10 » q_bad
      » ((x * y) * z) != 30 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and (= state q_bad)
                (not (= (+ x 8) 13))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |5|)))
      (a!2 (and (= state q_bad)
                (not (= (- x 8) (- 3)))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |6|)))
      (a!3 (and (= state q_bad)
                (not (= (* 0 x) 0))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |7|)))
      (a!4 (and (= state q_bad)
                (not (= (* x 3) 15))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |8|)))
      (a!5 (ite (>= x 0) (div x 2) (- (div (- x) 2))))
      (a!6 (ite (>= x 0) (div x 3) (- (div (- x) 3))))
      (a!7 (ite (>= 2 0) (div 2 x) (- (div (- 2) x))))
      (a!8 (ite (>= (- 7) 0) (div (- 7) x) (- (div (- (- 7)) x))))
      (a!9 (and (= state q_bad)
                (= (- (* y z) x) y)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_03)
                (= transition$ |15|)))
      (a!10 (and (= state q_bad)
                 (and (= z (- x y)))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_04)
                 (= transition$ |16|)))
      (a!11 (and (= state q_bad)
                 (<= (* (* x y) z) (+ (+ x y) z))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_04)
                 (= transition$ |17|)))
      (a!12 (ite (>= z 0) (div z x) (- (div (- z) x))))
      (a!13 (not (= (+ (+ x y) z) 10)))
      (a!14 (not (= (* (* x y) z) 30)))
      (a!15 (ite (>= y 0) (div y x) (- (div (- y) x))))
      (a!16 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!17 (and (= state q_05)
                 (and (= z (- x y)))
                 (= x x$)
                 (= y y$)
                 (= state$ q_03)
                 (= transition$ |27|)))
      (a!18 (and (= state q_04)
                 (and (= z (+ x y)))
                 (= x x$)
                 (= y y$)
                 (= state$ q_03)
                 (= transition$ |29|)))
      (a!19 (and (= state q_04)
                 (and (= z (+ x y)))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_03)
                 (= transition$ |31|))))
  (or (and (= state q_bad)
           (not (= x 5))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_bad)
           (< x 2)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |1|))
      (and (= state q_bad)
           (<= x 3)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |2|))
      (and (= state q_bad)
           (>= x 7)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |3|))
      (and (= state q_bad)
           (> x 8)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |4|))
      a!1
      a!2
      a!3
      a!4
      (and (= state q_bad)
           (not (= 2 0))
           (not (= a!5 2))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |9|))
      (and (= state q_bad)
           (not (= 3 0))
           (not (= a!6 1))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |10|))
      (and (= state q_bad)
           (not (= x 0))
           (not (= a!7 0))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |11|))
      (and (= state q_bad)
           (not (= x 0))
           (not (= a!8 (- 1)))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |12|))
      (and (= state q_bad)
           (= (* x y) 18)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |13|))
      (and (= state q_bad)
           (= (* y z) x)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |14|))
      a!9
      a!10
      a!11
      (and (= state q_bad)
           (not (= x 0))
           (> a!12 y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |18|))
      (and (= state q_bad)
           a!13
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |19|))
      (and (= state q_bad)
           a!14
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |20|))
      (and (= state q_09)
           (not (= x 0))
           (= z a!15)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |21|))
      (and (= state q_08)
           (not (= y 0))
           (= z a!16)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |22|))
      (and (= state q_07)
           (= z (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |23|))
      (and (= state q_07)
           (= z (* y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |24|))
      (and (= state q_06)
           (= z (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |25|))
      (and (= state q_06)
           (= (+ x z) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |26|))
      a!17
      (and (= state q_05)
           (= x (+ y z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |28|))
      a!18
      (and (= state q_04)
           (= z (+ y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |30|))
      a!19
      (and (= state q_03)
           (= (* x y) 15)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |32|))
      (and (= state q_02)
           (= x 5)
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |33|))))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_01: No

=============================
aut/congruence_1.aut with bound 25
=============================
Automaton:
   Congruence_1
3 variables:
   x, y, z
10 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := 5 » q_02
   q_02
      » x != 5 » q_bad
      » x < 2 » q_bad
      » x <= 3 » q_bad
      » x >= 7 » q_bad
      » x > 8 » q_bad
      » (x + 8) != 13 » q_bad
      » (x - 8) != -3 » q_bad
      » (0 * x) != 0 » q_bad
      » (x * 3) != 15 » q_bad
      » (x / 2) != 2 » q_bad
      » (x / 3) != 1 » q_bad
      » (2 / x) != 0 » q_bad
      » (-7 / x) != -1 » q_bad
      » (x * y) == 18 » q_bad
      » (x * y) == 15 » q_03
   q_03
      » (y * z) == x » q_bad
      » ((y * z) - x) == y » q_bad
      » z := (x + y) » q_04
      » z := (y + x) » q_04
      » z == (x + y) » q_04
      » z := (x - y) » q_05
      » x == (y + z) » q_05
      » z := (y - x) » q_06
      » (x + z) == y » q_06
      » z := (x * y) » q_07
      » z := (y * x) » q_07
      » z := (x / y) » q_08
      » z := (y / x) » q_09
   q_04
      » z == (x - y) » q_bad
      » ((x * y) * z) <= ((x + y) + z) » q_bad
      » (z / x) > y » q_bad
   q_05
      » ((x + y) + z) != 10 » q_bad
      » ((x * y) * z) != 30 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and (= state q_bad)
                (not (= (+ x 8) 13))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |5|)))
      (a!2 (and (= state q_bad)
                (not (= (- x 8) (- 3)))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |6|)))
      (a!3 (and (= state q_bad)
                (not (= (* 0 x) 0))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |7|)))
      (a!4 (and (= state q_bad)
                (not (= (* x 3) 15))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |8|)))
      (a!5 (ite (>= x 0) (div x 2) (- (div (- x) 2))))
      (a!6 (ite (>= x 0) (div x 3) (- (div (- x) 3))))
      (a!7 (ite (>= 2 0) (div 2 x) (- (div (- 2) x))))
      (a!8 (ite (>= (- 7) 0) (div (- 7) x) (- (div (- (- 7)) x))))
      (a!9 (and (= state q_bad)
                (= (- (* y z) x) y)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_03)
                (= transition$ |15|)))
      (a!10 (and (= state q_bad)
                 (and (= z (- x y)))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_04)
                 (= transition$ |16|)))
      (a!11 (and (= state q_bad)
                 (<= (* (* x y) z) (+ (+ x y) z))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_04)
                 (= transition$ |17|)))
      (a!12 (ite (>= z 0) (div z x) (- (div (- z) x))))
      (a!13 (not (= (+ (+ x y) z) 10)))
      (a!14 (not (= (* (* x y) z) 30)))
      (a!15 (ite (>= y 0) (div y x) (- (div (- y) x))))
      (a!16 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!17 (and (= state q_05)
                 (and (= z (- x y)))
                 (= x x$)
                 (= y y$)
                 (= state$ q_03)
                 (= transition$ |27|)))
      (a!18 (and (= state q_04)
                 (and (= z (+ x y)))
                 (= x x$)
                 (= y y$)
                 (= state$ q_03)
                 (= transition$ |29|)))
      (a!19 (and (= state q_04)
                 (and (= z (+ x y)))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_03)
                 (= transition$ |31|))))
  (or (and (= state q_bad)
           (not (= x 5))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_bad)
           (< x 2)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |1|))
      (and (= state q_bad)
           (<= x 3)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |2|))
      (and (= state q_bad)
           (>= x 7)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |3|))
      (and (= state q_bad)
           (> x 8)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |4|))
      a!1
      a!2
      a!3
      a!4
      (and (= state q_bad)
           (not (= 2 0))
           (not (= a!5 2))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |9|))
      (and (= state q_bad)
           (not (= 3 0))
           (not (= a!6 1))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |10|))
      (and (= state q_bad)
           (not (= x 0))
           (not (= a!7 0))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |11|))
      (and (= state q_bad)
           (not (= x 0))
           (not (= a!8 (- 1)))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |12|))
      (and (= state q_bad)
           (= (* x y) 18)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |13|))
      (and (= state q_bad)
           (= (* y z) x)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |14|))
      a!9
      a!10
      a!11
      (and (= state q_bad)
           (not (= x 0))
           (> a!12 y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |18|))
      (and (= state q_bad)
           a!13
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |19|))
      (and (= state q_bad)
           a!14
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |20|))
      (and (= state q_09)
           (not (= x 0))
           (= z a!15)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |21|))
      (and (= state q_08)
           (not (= y 0))
           (= z a!16)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |22|))
      (and (= state q_07)
           (= z (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |23|))
      (and (= state q_07)
           (= z (* y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |24|))
      (and (= state q_06)
           (= z (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |25|))
      (and (= state q_06)
           (= (+ x z) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |26|))
      a!17
      (and (= state q_05)
           (= x (+ y z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |28|))
      a!18
      (and (= state q_04)
           (= z (+ y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |30|))
      a!19
      (and (= state q_03)
           (= (* x y) 15)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |32|))
      (and (= state q_02)
           (= x 5)
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |33|))))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_01: No

=============================
aut/congruence_1.aut with bound 100
=============================
Automaton:
   Congruence_1
3 variables:
   x, y, z
10 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := 5 » q_02
   q_02
      » x != 5 » q_bad
      » x < 2 » q_bad
      » x <= 3 » q_bad
      » x >= 7 » q_bad
      » x > 8 » q_bad
      » (x + 8) != 13 » q_bad
      » (x - 8) != -3 » q_bad
      » (0 * x) != 0 » q_bad
      » (x * 3) != 15 » q_bad
      » (x / 2) != 2 » q_bad
      » (x / 3) != 1 » q_bad
      » (2 / x) != 0 » q_bad
      » (-7 / x) != -1 » q_bad
      » (x * y) == 18 » q_bad
      » (x * y) == 15 » q_03
   q_03
      » (y * z) == x » q_bad
      » ((y * z) - x) == y » q_bad
      » z := (x + y) » q_04
      » z := (y + x) » q_04
      » z == (x + y) » q_04
      » z := (x - y) » q_05
      » x == (y + z) » q_05
      » z := (y - x) » q_06
      » (x + z) == y » q_06
      » z := (x * y) » q_07
      » z := (y * x) » q_07
      » z := (x / y) » q_08
      » z := (y / x) » q_09
   q_04
      » z == (x - y) » q_bad
      » ((x * y) * z) <= ((x + y) + z) » q_bad
      » (z / x) > y » q_bad
   q_05
      » ((x + y) + z) != 10 » q_bad
      » ((x * y) * z) != 30 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and (= state q_bad)
                (not (= (+ x 8) 13))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |5|)))
      (a!2 (and (= state q_bad)
                (not (= (- x 8) (- 3)))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |6|)))
      (a!3 (and (= state q_bad)
                (not (= (* 0 x) 0))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |7|)))
      (a!4 (and (= state q_bad)
                (not (= (* x 3) 15))
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_02)
                (= transition$ |8|)))
      (a!5 (ite (>= x 0) (div x 2) (- (div (- x) 2))))
      (a!6 (ite (>= x 0) (div x 3) (- (div (- x) 3))))
      (a!7 (ite (>= 2 0) (div 2 x) (- (div (- 2) x))))
      (a!8 (ite (>= (- 7) 0) (div (- 7) x) (- (div (- (- 7)) x))))
      (a!9 (and (= state q_bad)
                (= (- (* y z) x) y)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_03)
                (= transition$ |15|)))
      (a!10 (and (= state q_bad)
                 (and (= z (- x y)))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_04)
                 (= transition$ |16|)))
      (a!11 (and (= state q_bad)
                 (<= (* (* x y) z) (+ (+ x y) z))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_04)
                 (= transition$ |17|)))
      (a!12 (ite (>= z 0) (div z x) (- (div (- z) x))))
      (a!13 (not (= (+ (+ x y) z) 10)))
      (a!14 (not (= (* (* x y) z) 30)))
      (a!15 (ite (>= y 0) (div y x) (- (div (- y) x))))
      (a!16 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!17 (and (= state q_05)
                 (and (= z (- x y)))
                 (= x x$)
                 (= y y$)
                 (= state$ q_03)
                 (= transition$ |27|)))
      (a!18 (and (= state q_04)
                 (and (= z (+ x y)))
                 (= x x$)
                 (= y y$)
                 (= state$ q_03)
                 (= transition$ |29|)))
      (a!19 (and (= state q_04)
                 (and (= z (+ x y)))
                 (= x x$)
                 (= y y$)
                 (= z z$)
                 (= state$ q_03)
                 (= transition$ |31|))))
  (or (and (= state q_bad)
           (not (= x 5))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |0|))
      (and (= state q_bad)
           (< x 2)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |1|))
      (and (= state q_bad)
           (<= x 3)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |2|))
      (and (= state q_bad)
           (>= x 7)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |3|))
      (and (= state q_bad)
           (> x 8)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |4|))
      a!1
      a!2
      a!3
      a!4
      (and (= state q_bad)
           (not (= 2 0))
           (not (= a!5 2))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |9|))
      (and (= state q_bad)
           (not (= 3 0))
           (not (= a!6 1))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |10|))
      (and (= state q_bad)
           (not (= x 0))
           (not (= a!7 0))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |11|))
      (and (= state q_bad)
           (not (= x 0))
           (not (= a!8 (- 1)))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |12|))
      (and (= state q_bad)
           (= (* x y) 18)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |13|))
      (and (= state q_bad)
           (= (* y z) x)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |14|))
      a!9
      a!10
      a!11
      (and (= state q_bad)
           (not (= x 0))
           (> a!12 y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_04)
           (= transition$ |18|))
      (and (= state q_bad)
           a!13
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |19|))
      (and (= state q_bad)
           a!14
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_05)
           (= transition$ |20|))
      (and (= state q_09)
           (not (= x 0))
           (= z a!15)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |21|))
      (and (= state q_08)
           (not (= y 0))
           (= z a!16)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |22|))
      (and (= state q_07)
           (= z (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |23|))
      (and (= state q_07)
           (= z (* y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |24|))
      (and (= state q_06)
           (= z (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |25|))
      (and (= state q_06)
           (= (+ x z) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |26|))
      a!17
      (and (= state q_05)
           (= x (+ y z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |28|))
      a!18
      (and (= state q_04)
           (= z (+ y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |30|))
      a!19
      (and (= state q_03)
           (= (* x y) 15)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |32|))
      (and (= state q_02)
           (= x 5)
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |33|))))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_01: No

=============================
aut/congruence_2.aut with bound 5
=============================
Automaton:
   Congruence_2
3 variables:
   x, y, z
14 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_10, q_11, 
   q_12, q_13, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := -9 » q_02
      » x := 3 » q_02
   q_02
      » y := 10 » q_03
      » y := 18 » q_03
   q_03
      » x := (x + 12) » q_03
      » x := ((x + (3 * y)) - 6) » q_03
      » y := (y - 8) » q_03
      » x == y » q_bad
      » (x - 1) == y » q_04
      » x == (6 * z) » q_bad
      » y == (4 * z) » q_bad
      » (x + y) == (2 * z) » q_bad
      » z := (x + y) » q_05
      » z := (y - x) » q_06
      » z := (x * y) » q_07
      » z := (x / y) » q_08
      » z := (5 / y) » q_09
      » z := (7 / (x - 1)) » q_10
   q_05
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_06
      » ((x + y) + z) == 2 » q_bad
      » ((x * y) * z) == 2 » q_bad
   q_07
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_08
      » (x * y) == 12 » q_bad
   q_09
      » z := (z + 2) » q_09
      » z == 1 » q_bad
   q_10
      » y == z » q_11
      » (x + y) == z » q_12
      » (x + (y * (1 + z))) == -1 » q_13

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and (= (+ (+ x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!2 (and (= (* (* x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!3 (and (= state q_bad)
                (= (+ (+ x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_06)
                (= transition$ |6|)))
      (a!4 (and (= state q_bad)
                (= (* (* x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_06)
                (= transition$ |7|)))
      (a!5 (= (+ x (* y (+ 1 z))) (- 1)))
      (a!6 (ite (>= 7 0) (div 7 (- x 1)) (- (div (- 7) (- x 1)))))
      (a!8 (ite (>= 5 0) (div 5 y) (- (div (- 5) y))))
      (a!9 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!10 (= x (- (+ x$ (* 3 y)) 6))))
(let ((a!7 (and (= state q_10)
                (not (= (- x 1) 0))
                (= z a!6)
                (= x x$)
                (= y y$)
                (= state$ q_03)
                (= transition$ |15|))))
  (or (and (= state q_bad)
           (= x y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |0|))
      (and (= state q_bad)
           (= x (* 6 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |1|))
      (and (= state q_bad)
           (= y (* 4 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |2|))
      (and (= state q_bad)
           (= (+ x y) (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |3|))
      (and (= state q_bad) a!1 (= state$ q_05) (= transition$ |4|))
      (and (= state q_bad) a!2 (= state$ q_05) (= transition$ |5|))
      a!3
      a!4
      (and (= state q_bad) a!1 (= state$ q_07) (= transition$ |8|))
      (and (= state q_bad) a!2 (= state$ q_07) (= transition$ |9|))
      (and (= state q_bad)
           (= (* x y) 12)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_08)
           (= transition$ |10|))
      (and (= state q_bad)
           (= z 1)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_09)
           (= transition$ |11|))
      (and (= state q_13)
           a!5
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |12|))
      (and (= state q_12)
           (= (+ x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |13|))
      (and (= state q_11)
           (= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |14|))
      a!7
      (and (= state q_09)
           (not (= y 0))
           (= z a!8)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |16|))
      (and (= state q_09)
           (= z (+ z$ 2))
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |17|))
      (and (= state q_08)
           (not (= y 0))
           (= z a!9)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |18|))
      (and (= state q_07)
           (= z (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |19|))
      (and (= state q_06)
           (= z (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |20|))
      (and (= state q_05)
           (= z (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |21|))
      (and (= state q_04)
           (= (- x 1) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |22|))
      (and (= state q_03)
           (= y 10)
           (= x x$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |23|))
      (and (= state q_03)
           (= y 18)
           (= x x$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |24|))
      (and (= state q_03)
           (= x (+ x$ 12))
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |25|))
      (and (= state q_03)
           a!10
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |26|))
      (and (= state q_03)
           (= y (- y$ 8))
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |27|))
      (and (= state q_02)
           (= x (- 9))
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |28|))
      (and (= state q_02)
           (= x 3)
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |29|)))))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: All paths to q_01 are unfeasible.
Depth   5: All paths to q_01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_01: Unknown

=============================
aut/congruence_2.aut with bound 25
=============================
Automaton:
   Congruence_2
3 variables:
   x, y, z
14 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_10, q_11, 
   q_12, q_13, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := -9 » q_02
      » x := 3 » q_02
   q_02
      » y := 10 » q_03
      » y := 18 » q_03
   q_03
      » x := (x + 12) » q_03
      » x := ((x + (3 * y)) - 6) » q_03
      » y := (y - 8) » q_03
      » x == y » q_bad
      » (x - 1) == y » q_04
      » x == (6 * z) » q_bad
      » y == (4 * z) » q_bad
      » (x + y) == (2 * z) » q_bad
      » z := (x + y) » q_05
      » z := (y - x) » q_06
      » z := (x * y) » q_07
      » z := (x / y) » q_08
      » z := (5 / y) » q_09
      » z := (7 / (x - 1)) » q_10
   q_05
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_06
      » ((x + y) + z) == 2 » q_bad
      » ((x * y) * z) == 2 » q_bad
   q_07
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_08
      » (x * y) == 12 » q_bad
   q_09
      » z := (z + 2) » q_09
      » z == 1 » q_bad
   q_10
      » y == z » q_11
      » (x + y) == z » q_12
      » (x + (y * (1 + z))) == -1 » q_13

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and (= (+ (+ x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!2 (and (= (* (* x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!3 (and (= state q_bad)
                (= (+ (+ x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_06)
                (= transition$ |6|)))
      (a!4 (and (= state q_bad)
                (= (* (* x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_06)
                (= transition$ |7|)))
      (a!5 (= (+ x (* y (+ 1 z))) (- 1)))
      (a!6 (ite (>= 7 0) (div 7 (- x 1)) (- (div (- 7) (- x 1)))))
      (a!8 (ite (>= 5 0) (div 5 y) (- (div (- 5) y))))
      (a!9 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!10 (= x (- (+ x$ (* 3 y)) 6))))
(let ((a!7 (and (= state q_10)
                (not (= (- x 1) 0))
                (= z a!6)
                (= x x$)
                (= y y$)
                (= state$ q_03)
                (= transition$ |15|))))
  (or (and (= state q_bad)
           (= x y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |0|))
      (and (= state q_bad)
           (= x (* 6 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |1|))
      (and (= state q_bad)
           (= y (* 4 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |2|))
      (and (= state q_bad)
           (= (+ x y) (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |3|))
      (and (= state q_bad) a!1 (= state$ q_05) (= transition$ |4|))
      (and (= state q_bad) a!2 (= state$ q_05) (= transition$ |5|))
      a!3
      a!4
      (and (= state q_bad) a!1 (= state$ q_07) (= transition$ |8|))
      (and (= state q_bad) a!2 (= state$ q_07) (= transition$ |9|))
      (and (= state q_bad)
           (= (* x y) 12)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_08)
           (= transition$ |10|))
      (and (= state q_bad)
           (= z 1)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_09)
           (= transition$ |11|))
      (and (= state q_13)
           a!5
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |12|))
      (and (= state q_12)
           (= (+ x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |13|))
      (and (= state q_11)
           (= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |14|))
      a!7
      (and (= state q_09)
           (not (= y 0))
           (= z a!8)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |16|))
      (and (= state q_09)
           (= z (+ z$ 2))
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |17|))
      (and (= state q_08)
           (not (= y 0))
           (= z a!9)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |18|))
      (and (= state q_07)
           (= z (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |19|))
      (and (= state q_06)
           (= z (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |20|))
      (and (= state q_05)
           (= z (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |21|))
      (and (= state q_04)
           (= (- x 1) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |22|))
      (and (= state q_03)
           (= y 10)
           (= x x$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |23|))
      (and (= state q_03)
           (= y 18)
           (= x x$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |24|))
      (and (= state q_03)
           (= x (+ x$ 12))
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |25|))
      (and (= state q_03)
           a!10
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |26|))
      (and (= state q_03)
           (= y (- y$ 8))
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |27|))
      (and (= state q_02)
           (= x (- 9))
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |28|))
      (and (= state q_02)
           (= x 3)
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |29|)))))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: All paths to q_01 are unfeasible.
Depth   5: All paths to q_01 are unfeasible.
Depth   6: All paths to q_01 are unfeasible.

=============================
aut/congruence_2.aut with bound 100
=============================
Automaton:
   Congruence_2
3 variables:
   x, y, z
14 locations:
   q_01, q_02, q_03, q_04, q_05, q_06, q_07, q_08, q_09, q_10, q_11, 
   q_12, q_13, q_bad
Initial location:
   q_01
Final location:
   q_bad
Transitions:
   q_01
      » x := -9 » q_02
      » x := 3 » q_02
   q_02
      » y := 10 » q_03
      » y := 18 » q_03
   q_03
      » x := (x + 12) » q_03
      » x := ((x + (3 * y)) - 6) » q_03
      » y := (y - 8) » q_03
      » x == y » q_bad
      » (x - 1) == y » q_04
      » x == (6 * z) » q_bad
      » y == (4 * z) » q_bad
      » (x + y) == (2 * z) » q_bad
      » z := (x + y) » q_05
      » z := (y - x) » q_06
      » z := (x * y) » q_07
      » z := (x / y) » q_08
      » z := (5 / y) » q_09
      » z := (7 / (x - 1)) » q_10
   q_05
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_06
      » ((x + y) + z) == 2 » q_bad
      » ((x * y) * z) == 2 » q_bad
   q_07
      » ((x + y) + z) == 0 » q_bad
      » ((x * y) * z) == 0 » q_bad
   q_08
      » (x * y) == 12 » q_bad
   q_09
      » z := (z + 2) » q_09
      » z == 1 » q_bad
   q_10
      » y == z » q_11
      » (x + y) == z » q_12
      » (x + (y * (1 + z))) == -1 » q_13

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and (= (+ (+ x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!2 (and (= (* (* x y) z) 0) (= x x$) (= y y$) (= z z$)))
      (a!3 (and (= state q_bad)
                (= (+ (+ x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_06)
                (= transition$ |6|)))
      (a!4 (and (= state q_bad)
                (= (* (* x y) z) 2)
                (= x x$)
                (= y y$)
                (= z z$)
                (= state$ q_06)
                (= transition$ |7|)))
      (a!5 (= (+ x (* y (+ 1 z))) (- 1)))
      (a!6 (ite (>= 7 0) (div 7 (- x 1)) (- (div (- 7) (- x 1)))))
      (a!8 (ite (>= 5 0) (div 5 y) (- (div (- 5) y))))
      (a!9 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!10 (= x (- (+ x$ (* 3 y)) 6))))
(let ((a!7 (and (= state q_10)
                (not (= (- x 1) 0))
                (= z a!6)
                (= x x$)
                (= y y$)
                (= state$ q_03)
                (= transition$ |15|))))
  (or (and (= state q_bad)
           (= x y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |0|))
      (and (= state q_bad)
           (= x (* 6 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |1|))
      (and (= state q_bad)
           (= y (* 4 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |2|))
      (and (= state q_bad)
           (= (+ x y) (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |3|))
      (and (= state q_bad) a!1 (= state$ q_05) (= transition$ |4|))
      (and (= state q_bad) a!2 (= state$ q_05) (= transition$ |5|))
      a!3
      a!4
      (and (= state q_bad) a!1 (= state$ q_07) (= transition$ |8|))
      (and (= state q_bad) a!2 (= state$ q_07) (= transition$ |9|))
      (and (= state q_bad)
           (= (* x y) 12)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_08)
           (= transition$ |10|))
      (and (= state q_bad)
           (= z 1)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_09)
           (= transition$ |11|))
      (and (= state q_13)
           a!5
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |12|))
      (and (= state q_12)
           (= (+ x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |13|))
      (and (= state q_11)
           (= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_10)
           (= transition$ |14|))
      a!7
      (and (= state q_09)
           (not (= y 0))
           (= z a!8)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |16|))
      (and (= state q_09)
           (= z (+ z$ 2))
           (= x x$)
           (= y y$)
           (= state$ q_09)
           (= transition$ |17|))
      (and (= state q_08)
           (not (= y 0))
           (= z a!9)
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |18|))
      (and (= state q_07)
           (= z (* x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |19|))
      (and (= state q_06)
           (= z (- y x))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |20|))
      (and (= state q_05)
           (= z (+ x y))
           (= x x$)
           (= y y$)
           (= state$ q_03)
           (= transition$ |21|))
      (and (= state q_04)
           (= (- x 1) y)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |22|))
      (and (= state q_03)
           (= y 10)
           (= x x$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |23|))
      (and (= state q_03)
           (= y 18)
           (= x x$)
           (= z z$)
           (= state$ q_02)
           (= transition$ |24|))
      (and (= state q_03)
           (= x (+ x$ 12))
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |25|))
      (and (= state q_03)
           a!10
           (= y y$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |26|))
      (and (= state q_03)
           (= y (- y$ 8))
           (= x x$)
           (= z z$)
           (= state$ q_03)
           (= transition$ |27|))
      (and (= state q_02)
           (= x (- 9))
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |28|))
      (and (= state q_02)
           (= x 3)
           (= y y$)
           (= z z$)
           (= state$ q_01)
           (= transition$ |29|)))))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: All paths to q_01 are unfeasible.
Depth   5: All paths to q_01 are unfeasible.
Depth   6: All paths to q_01 are unfeasible.

=============================
aut/constant_propagation.aut with bound 5
=============================
Automaton:
   Constant_Propagation
3 variables:
   x, y, z
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 1 » q_1
      » x := 2 » q_2
   q_1
      » y := 2 » q_3
   q_2
      » y := 1 » q_3
   q_3
      » z := (x + y) » q_4
   q_4
      » z != 3 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad)
         (not (= z 3))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_4)
         (= z (+ x y))
         (= x x$)
         (= y y$)
         (= state$ q_3)
         (= transition$ |1|))
    (and (= state q_3)
         (= y 2)
         (= x x$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_3)
         (= y 1)
         (= x x$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_2)
         (= x 2)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |4|))
    (and (= state q_1)
         (= x 1)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/constant_propagation.aut with bound 25
=============================
Automaton:
   Constant_Propagation
3 variables:
   x, y, z
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 1 » q_1
      » x := 2 » q_2
   q_1
      » y := 2 » q_3
   q_2
      » y := 1 » q_3
   q_3
      » z := (x + y) » q_4
   q_4
      » z != 3 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad)
         (not (= z 3))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_4)
         (= z (+ x y))
         (= x x$)
         (= y y$)
         (= state$ q_3)
         (= transition$ |1|))
    (and (= state q_3)
         (= y 2)
         (= x x$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_3)
         (= y 1)
         (= x x$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_2)
         (= x 2)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |4|))
    (and (= state q_1)
         (= x 1)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/constant_propagation.aut with bound 100
=============================
Automaton:
   Constant_Propagation
3 variables:
   x, y, z
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 1 » q_1
      » x := 2 » q_2
   q_1
      » y := 2 » q_3
   q_2
      » y := 1 » q_3
   q_3
      » z := (x + y) » q_4
   q_4
      » z != 3 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad)
         (not (= z 3))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_4)
         (= z (+ x y))
         (= x x$)
         (= y y$)
         (= state$ q_3)
         (= transition$ |1|))
    (and (= state q_3)
         (= y 2)
         (= x x$)
         (= z z$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_3)
         (= y 1)
         (= x x$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_2)
         (= x 2)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |4|))
    (and (= state q_1)
         (= x 1)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/division_by_zero.aut with bound 5
=============================
Automaton:
   Division_by_Zero
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_bad, q_bad'
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x <= (3 / 0) » q_bad'
      » x := -1 » q_1
      » x := (x / (y + 2)) » q_2
      » (x / y) > 3 » q_3
   q_1
      » y := (3 / (x + 1)) » q_bad'
   q_2
      » y == -2 » q_bad
   q_3
      » y == 0 » q_bad
   q_bad'
      » skip » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= 3 0) (div 3 0) (- (div (- 3) 0))))
      (a!2 (ite (>= 3 0) (div 3 (+ x 1)) (- (div (- 3) (+ x 1)))))
      (a!4 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!5 (ite (>= x$ 0) (div x$ (+ y 2)) (- (div (- x$) (+ y 2))))))
(let ((a!3 (and (= state |q_bad'|)
                (not (= (+ x 1) 0))
                (= y a!2)
                (= x x$)
                (= state$ q_1)
                (= transition$ |1|)))
      (a!6 (and (= state q_2)
                (not (= (+ y 2) 0))
                (= x a!5)
                (= y y$)
                (= state$ q_0)
                (= transition$ |6|))))
  (or (and (= state |q_bad'|)
           (not (= 0 0))
           (<= x a!1)
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |0|))
      a!3
      (and (= state q_bad)
           true
           (= x x$)
           (= y y$)
           (= state$ |q_bad'|)
           (= transition$ |2|))
      (and (= state q_bad)
           (= y (- 2))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |3|))
      (and (= state q_bad)
           (= y 0)
           (= x x$)
           (= y y$)
           (= state$ q_3)
           (= transition$ |4|))
      (and (= state q_3)
           (not (= y 0))
           (> a!4 3)
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |5|))
      a!6
      (and (= state q_1)
           (= x (- 1))
           (= y y$)
           (= state$ q_0)
           (= transition$ |7|)))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/division_by_zero.aut with bound 25
=============================
Automaton:
   Division_by_Zero
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_bad, q_bad'
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x <= (3 / 0) » q_bad'
      » x := -1 » q_1
      » x := (x / (y + 2)) » q_2
      » (x / y) > 3 » q_3
   q_1
      » y := (3 / (x + 1)) » q_bad'
   q_2
      » y == -2 » q_bad
   q_3
      » y == 0 » q_bad
   q_bad'
      » skip » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= 3 0) (div 3 0) (- (div (- 3) 0))))
      (a!2 (ite (>= 3 0) (div 3 (+ x 1)) (- (div (- 3) (+ x 1)))))
      (a!4 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!5 (ite (>= x$ 0) (div x$ (+ y 2)) (- (div (- x$) (+ y 2))))))
(let ((a!3 (and (= state |q_bad'|)
                (not (= (+ x 1) 0))
                (= y a!2)
                (= x x$)
                (= state$ q_1)
                (= transition$ |1|)))
      (a!6 (and (= state q_2)
                (not (= (+ y 2) 0))
                (= x a!5)
                (= y y$)
                (= state$ q_0)
                (= transition$ |6|))))
  (or (and (= state |q_bad'|)
           (not (= 0 0))
           (<= x a!1)
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |0|))
      a!3
      (and (= state q_bad)
           true
           (= x x$)
           (= y y$)
           (= state$ |q_bad'|)
           (= transition$ |2|))
      (and (= state q_bad)
           (= y (- 2))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |3|))
      (and (= state q_bad)
           (= y 0)
           (= x x$)
           (= y y$)
           (= state$ q_3)
           (= transition$ |4|))
      (and (= state q_3)
           (not (= y 0))
           (> a!4 3)
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |5|))
      a!6
      (and (= state q_1)
           (= x (- 1))
           (= y y$)
           (= state$ q_0)
           (= transition$ |7|)))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/division_by_zero.aut with bound 100
=============================
Automaton:
   Division_by_Zero
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_bad, q_bad'
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x <= (3 / 0) » q_bad'
      » x := -1 » q_1
      » x := (x / (y + 2)) » q_2
      » (x / y) > 3 » q_3
   q_1
      » y := (3 / (x + 1)) » q_bad'
   q_2
      » y == -2 » q_bad
   q_3
      » y == 0 » q_bad
   q_bad'
      » skip » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= 3 0) (div 3 0) (- (div (- 3) 0))))
      (a!2 (ite (>= 3 0) (div 3 (+ x 1)) (- (div (- 3) (+ x 1)))))
      (a!4 (ite (>= x 0) (div x y) (- (div (- x) y))))
      (a!5 (ite (>= x$ 0) (div x$ (+ y 2)) (- (div (- x$) (+ y 2))))))
(let ((a!3 (and (= state |q_bad'|)
                (not (= (+ x 1) 0))
                (= y a!2)
                (= x x$)
                (= state$ q_1)
                (= transition$ |1|)))
      (a!6 (and (= state q_2)
                (not (= (+ y 2) 0))
                (= x a!5)
                (= y y$)
                (= state$ q_0)
                (= transition$ |6|))))
  (or (and (= state |q_bad'|)
           (not (= 0 0))
           (<= x a!1)
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |0|))
      a!3
      (and (= state q_bad)
           true
           (= x x$)
           (= y y$)
           (= state$ |q_bad'|)
           (= transition$ |2|))
      (and (= state q_bad)
           (= y (- 2))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |3|))
      (and (= state q_bad)
           (= y 0)
           (= x x$)
           (= y y$)
           (= state$ q_3)
           (= transition$ |4|))
      (and (= state q_3)
           (not (= y 0))
           (> a!4 3)
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |5|))
      a!6
      (and (= state q_1)
           (= x (- 1))
           (= y y$)
           (= state$ q_0)
           (= transition$ |7|)))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/inductive_invariants_exercise_1.aut with bound 5
=============================
Automaton:
   Exercise_1
2 variables:
   x, y
3 locations:
   q_0, q_1, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » x := (x * y) » q_1
      » x := (x + 3) » q_1
      » x == 10 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad)
         (= x 10)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= x 0) (= y y$) (= state$ q_0) (= transition$ |1|))
    (and (= state q_1)
         (= x (* x$ y))
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (= x (+ x$ 3))
         (= y y$)
         (= state$ q_1)
         (= transition$ |3|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariants_exercise_1.aut with bound 25
=============================
Automaton:
   Exercise_1
2 variables:
   x, y
3 locations:
   q_0, q_1, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » x := (x * y) » q_1
      » x := (x + 3) » q_1
      » x == 10 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad)
         (= x 10)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= x 0) (= y y$) (= state$ q_0) (= transition$ |1|))
    (and (= state q_1)
         (= x (* x$ y))
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (= x (+ x$ 3))
         (= y y$)
         (= state$ q_1)
         (= transition$ |3|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.

=============================
aut/inductive_invariants_exercise_1.aut with bound 100
=============================
Automaton:
   Exercise_1
2 variables:
   x, y
3 locations:
   q_0, q_1, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » x := (x * y) » q_1
      » x := (x + 3) » q_1
      » x == 10 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad)
         (= x 10)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |0|))
    (and (= state q_1) (= x 0) (= y y$) (= state$ q_0) (= transition$ |1|))
    (and (= state q_1)
         (= x (* x$ y))
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (= x (+ x$ 3))
         (= y y$)
         (= state$ q_1)
         (= transition$ |3|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.

=============================
aut/inductive_invariants_exercise_2.aut with bound 5
=============================
Automaton:
   Exercise_2
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » y > 0 » q_1
   q_1
      » x := 0 » q_2
   q_2
      » x := (x + y) » q_3
      » y == 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad)
         (and (= x 0))
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_4)
         (= y 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_3)
         (= x (+ x$ y))
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_2)
         (and (= x 0))
         (= y y$)
         (= state$ q_1)
         (= transition$ |3|))
    (and (= state q_2)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_3)
         (= transition$ |4|))
    (and (= state q_1)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ q_0)
         (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariants_exercise_2.aut with bound 25
=============================
Automaton:
   Exercise_2
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » y > 0 » q_1
   q_1
      » x := 0 » q_2
   q_2
      » x := (x + y) » q_3
      » y == 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad)
         (and (= x 0))
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_4)
         (= y 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_3)
         (= x (+ x$ y))
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_2)
         (and (= x 0))
         (= y y$)
         (= state$ q_1)
         (= transition$ |3|))
    (and (= state q_2)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_3)
         (= transition$ |4|))
    (and (= state q_1)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ q_0)
         (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariants_exercise_2.aut with bound 100
=============================
Automaton:
   Exercise_2
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » y > 0 » q_1
   q_1
      » x := 0 » q_2
   q_2
      » x := (x + y) » q_3
      » y == 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad)
         (and (= x 0))
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_4)
         (= y 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_3)
         (= x (+ x$ y))
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_2)
         (and (= x 0))
         (= y y$)
         (= state$ q_1)
         (= transition$ |3|))
    (and (= state q_2)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_3)
         (= transition$ |4|))
    (and (= state q_1)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ q_0)
         (= transition$ |5|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: All paths to q_0 are unfeasible.
Depth  27: All paths to q_0 are unfeasible.
Depth  28: All paths to q_0 are unfeasible.
Depth  29: All paths to q_0 are unfeasible.
Depth  30: All paths to q_0 are unfeasible.
Depth  31: All paths to q_0 are unfeasible.
Depth  32: All paths to q_0 are unfeasible.
Depth  33: All paths to q_0 are unfeasible.
Depth  34: All paths to q_0 are unfeasible.
Depth  35: All paths to q_0 are unfeasible.
Depth  36: All paths to q_0 are unfeasible.
Depth  37: All paths to q_0 are unfeasible.
Depth  38: All paths to q_0 are unfeasible.
Depth  39: All paths to q_0 are unfeasible.
Depth  40: All paths to q_0 are unfeasible.
Depth  41: All paths to q_0 are unfeasible.
Depth  42: All paths to q_0 are unfeasible.
Depth  43: All paths to q_0 are unfeasible.
Depth  44: All paths to q_0 are unfeasible.
Depth  45: All paths to q_0 are unfeasible.
Depth  46: All paths to q_0 are unfeasible.
Depth  47: All paths to q_0 are unfeasible.
Depth  48: All paths to q_0 are unfeasible.
Depth  49: All paths to q_0 are unfeasible.
Depth  50: All paths to q_0 are unfeasible.
Depth  51: All paths to q_0 are unfeasible.
Depth  52: All paths to q_0 are unfeasible.
Depth  53: All paths to q_0 are unfeasible.
Depth  54: All paths to q_0 are unfeasible.
Depth  55: All paths to q_0 are unfeasible.
Depth  56: All paths to q_0 are unfeasible.
Depth  57: All paths to q_0 are unfeasible.
Depth  58: All paths to q_0 are unfeasible.
Depth  59: All paths to q_0 are unfeasible.
Depth  60: All paths to q_0 are unfeasible.
Depth  61: All paths to q_0 are unfeasible.
Depth  62: All paths to q_0 are unfeasible.
Depth  63: All paths to q_0 are unfeasible.
Depth  64: All paths to q_0 are unfeasible.
Depth  65: All paths to q_0 are unfeasible.
Depth  66: All paths to q_0 are unfeasible.
Depth  67: All paths to q_0 are unfeasible.
Depth  68: All paths to q_0 are unfeasible.
Depth  69: All paths to q_0 are unfeasible.
Depth  70: All paths to q_0 are unfeasible.
Depth  71: All paths to q_0 are unfeasible.
Depth  72: All paths to q_0 are unfeasible.
Depth  73: All paths to q_0 are unfeasible.
Depth  74: All paths to q_0 are unfeasible.
Depth  75: All paths to q_0 are unfeasible.
Depth  76: All paths to q_0 are unfeasible.
Depth  77: All paths to q_0 are unfeasible.
Depth  78: All paths to q_0 are unfeasible.
Depth  79: All paths to q_0 are unfeasible.
Depth  80: All paths to q_0 are unfeasible.
Depth  81: All paths to q_0 are unfeasible.
Depth  82: All paths to q_0 are unfeasible.
Depth  83: All paths to q_0 are unfeasible.
Depth  84: All paths to q_0 are unfeasible.
Depth  85: All paths to q_0 are unfeasible.
Depth  86: All paths to q_0 are unfeasible.
Depth  87: All paths to q_0 are unfeasible.
Depth  88: All paths to q_0 are unfeasible.
Depth  89: All paths to q_0 are unfeasible.
Depth  90: All paths to q_0 are unfeasible.
Depth  91: All paths to q_0 are unfeasible.
Depth  92: All paths to q_0 are unfeasible.
Depth  93: All paths to q_0 are unfeasible.
Depth  94: All paths to q_0 are unfeasible.
Depth  95: All paths to q_0 are unfeasible.
Depth  96: All paths to q_0 are unfeasible.
Depth  97: All paths to q_0 are unfeasible.
Depth  98: All paths to q_0 are unfeasible.
Depth  99: All paths to q_0 are unfeasible.
Depth 100: All paths to q_0 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/inductive_invariant_simple.aut with bound 5
=============================
Automaton:
   Example
1 variables:
   x
3 locations:
   A, B, C
Initial location:
   A
Final location:
   C
Transitions:
   A
      » x := 1 » B
   B
      » x := (5 * x) » B
      » x := (x + 2) » B
      » x < 0 » C

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state C) (< x 0) (= x x$) (= state$ B) (= transition$ |0|))
    (and (= state B) (= x 1) (= state$ A) (= transition$ |1|))
    (and (= state B) (= x (* 5 x$)) (= state$ B) (= transition$ |2|))
    (and (= state B) (= x (+ x$ 2)) (= state$ B) (= transition$ |3|)))

Depth   1: All paths to A are unfeasible.
Depth   2: All paths to A are unfeasible.
Depth   3: All paths to A are unfeasible.
Depth   4: All paths to A are unfeasible.
Depth   5: All paths to A are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location C reachable from initial location A: Unknown

=============================
aut/inductive_invariant_simple.aut with bound 25
=============================
Automaton:
   Example
1 variables:
   x
3 locations:
   A, B, C
Initial location:
   A
Final location:
   C
Transitions:
   A
      » x := 1 » B
   B
      » x := (5 * x) » B
      » x := (x + 2) » B
      » x < 0 » C

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state C) (< x 0) (= x x$) (= state$ B) (= transition$ |0|))
    (and (= state B) (= x 1) (= state$ A) (= transition$ |1|))
    (and (= state B) (= x (* 5 x$)) (= state$ B) (= transition$ |2|))
    (and (= state B) (= x (+ x$ 2)) (= state$ B) (= transition$ |3|)))

Depth   1: All paths to A are unfeasible.
Depth   2: All paths to A are unfeasible.
Depth   3: All paths to A are unfeasible.
Depth   4: All paths to A are unfeasible.
Depth   5: All paths to A are unfeasible.
Depth   6: All paths to A are unfeasible.
Depth   7: All paths to A are unfeasible.
Depth   8: All paths to A are unfeasible.
Depth   9: All paths to A are unfeasible.
Depth  10: All paths to A are unfeasible.
Depth  11: All paths to A are unfeasible.
Depth  12: All paths to A are unfeasible.
Depth  13: All paths to A are unfeasible.
Depth  14: All paths to A are unfeasible.
Depth  15: All paths to A are unfeasible.
Depth  16: All paths to A are unfeasible.
Depth  17: All paths to A are unfeasible.
Depth  18: All paths to A are unfeasible.
Depth  19: All paths to A are unfeasible.
Depth  20: All paths to A are unfeasible.
Depth  21: All paths to A are unfeasible.
Depth  22: All paths to A are unfeasible.
Depth  23: All paths to A are unfeasible.
Depth  24: All paths to A are unfeasible.
Depth  25: All paths to A are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location C reachable from initial location A: Unknown

=============================
aut/inductive_invariant_simple.aut with bound 100
=============================
Automaton:
   Example
1 variables:
   x
3 locations:
   A, B, C
Initial location:
   A
Final location:
   C
Transitions:
   A
      » x := 1 » B
   B
      » x := (5 * x) » B
      » x := (x + 2) » B
      » x < 0 » C

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state C) (< x 0) (= x x$) (= state$ B) (= transition$ |0|))
    (and (= state B) (= x 1) (= state$ A) (= transition$ |1|))
    (and (= state B) (= x (* 5 x$)) (= state$ B) (= transition$ |2|))
    (and (= state B) (= x (+ x$ 2)) (= state$ B) (= transition$ |3|)))

Depth   1: All paths to A are unfeasible.
Depth   2: All paths to A are unfeasible.
Depth   3: All paths to A are unfeasible.
Depth   4: All paths to A are unfeasible.
Depth   5: All paths to A are unfeasible.
Depth   6: All paths to A are unfeasible.
Depth   7: All paths to A are unfeasible.
Depth   8: All paths to A are unfeasible.
Depth   9: All paths to A are unfeasible.
Depth  10: All paths to A are unfeasible.
Depth  11: All paths to A are unfeasible.
Depth  12: All paths to A are unfeasible.
Depth  13: All paths to A are unfeasible.
Depth  14: All paths to A are unfeasible.
Depth  15: All paths to A are unfeasible.
Depth  16: All paths to A are unfeasible.
Depth  17: All paths to A are unfeasible.
Depth  18: All paths to A are unfeasible.
Depth  19: All paths to A are unfeasible.
Depth  20: All paths to A are unfeasible.
Depth  21: All paths to A are unfeasible.
Depth  22: All paths to A are unfeasible.
Depth  23: All paths to A are unfeasible.
Depth  24: All paths to A are unfeasible.
Depth  25: All paths to A are unfeasible.
Depth  26: All paths to A are unfeasible.
Depth  27: All paths to A are unfeasible.
Depth  28: All paths to A are unfeasible.
Depth  29: All paths to A are unfeasible.
Depth  30: All paths to A are unfeasible.
Depth  31: All paths to A are unfeasible.
Depth  32: All paths to A are unfeasible.
Depth  33: All paths to A are unfeasible.
Depth  34: All paths to A are unfeasible.
Depth  35: All paths to A are unfeasible.
Depth  36: All paths to A are unfeasible.
Depth  37: All paths to A are unfeasible.
Depth  38: All paths to A are unfeasible.
Depth  39: All paths to A are unfeasible.
Depth  40: All paths to A are unfeasible.
Depth  41: All paths to A are unfeasible.
Depth  42: All paths to A are unfeasible.
Depth  43: All paths to A are unfeasible.
Depth  44: All paths to A are unfeasible.
Depth  45: All paths to A are unfeasible.
Depth  46: All paths to A are unfeasible.
Depth  47: All paths to A are unfeasible.
Depth  48: All paths to A are unfeasible.
Depth  49: All paths to A are unfeasible.
Depth  50: All paths to A are unfeasible.
Depth  51: All paths to A are unfeasible.
Depth  52: All paths to A are unfeasible.
Depth  53: All paths to A are unfeasible.
Depth  54: All paths to A are unfeasible.
Depth  55: All paths to A are unfeasible.
Depth  56: All paths to A are unfeasible.
Depth  57: All paths to A are unfeasible.
Depth  58: All paths to A are unfeasible.
Depth  59: All paths to A are unfeasible.
Depth  60: All paths to A are unfeasible.
Depth  61: All paths to A are unfeasible.
Depth  62: All paths to A are unfeasible.
Depth  63: All paths to A are unfeasible.
Depth  64: All paths to A are unfeasible.
Depth  65: All paths to A are unfeasible.
Depth  66: All paths to A are unfeasible.
Depth  67: All paths to A are unfeasible.
Depth  68: All paths to A are unfeasible.
Depth  69: All paths to A are unfeasible.
Depth  70: All paths to A are unfeasible.
Depth  71: All paths to A are unfeasible.
Depth  72: All paths to A are unfeasible.
Depth  73: All paths to A are unfeasible.
Depth  74: All paths to A are unfeasible.
Depth  75: All paths to A are unfeasible.
Depth  76: All paths to A are unfeasible.
Depth  77: All paths to A are unfeasible.
Depth  78: All paths to A are unfeasible.
Depth  79: All paths to A are unfeasible.
Depth  80: All paths to A are unfeasible.
Depth  81: All paths to A are unfeasible.
Depth  82: All paths to A are unfeasible.
Depth  83: All paths to A are unfeasible.
Depth  84: All paths to A are unfeasible.
Depth  85: All paths to A are unfeasible.
Depth  86: All paths to A are unfeasible.
Depth  87: All paths to A are unfeasible.
Depth  88: All paths to A are unfeasible.
Depth  89: All paths to A are unfeasible.
Depth  90: All paths to A are unfeasible.
Depth  91: All paths to A are unfeasible.
Depth  92: All paths to A are unfeasible.
Depth  93: All paths to A are unfeasible.
Depth  94: All paths to A are unfeasible.
Depth  95: All paths to A are unfeasible.
Depth  96: All paths to A are unfeasible.
Depth  97: All paths to A are unfeasible.
Depth  98: All paths to A are unfeasible.
Depth  99: All paths to A are unfeasible.
Depth 100: All paths to A are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location C reachable from initial location A: Unknown

=============================
aut/infinite_descent.aut with bound 5
=============================
Automaton:
   Infinite_Descent
1 variables:
   x
4 locations:
   q_0, q_1, q_2, r
Initial location:
   q_0
Final location:
   r
Transitions:
   q_0
      » skip » q_2
      » x := 0 » q_1
   q_1
      » x == 3 » r
   q_2
      » x := 1 » q_1
   r
      » x := (x + 1) » r

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state r) (= x 3) (= x x$) (= state$ q_1) (= transition$ |0|))
    (and (= state r) (= x (+ x$ 1)) (= state$ r) (= transition$ |1|))
    (and (= state q_2) true (= x x$) (= state$ q_0) (= transition$ |2|))
    (and (= state q_1) (= x 0) (= state$ q_0) (= transition$ |3|))
    (and (= state q_1) (= x 1) (= state$ q_2) (= transition$ |4|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location r reachable from initial location q_0: Unknown

=============================
aut/infinite_descent.aut with bound 25
=============================
Automaton:
   Infinite_Descent
1 variables:
   x
4 locations:
   q_0, q_1, q_2, r
Initial location:
   q_0
Final location:
   r
Transitions:
   q_0
      » skip » q_2
      » x := 0 » q_1
   q_1
      » x == 3 » r
   q_2
      » x := 1 » q_1
   r
      » x := (x + 1) » r

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state r) (= x 3) (= x x$) (= state$ q_1) (= transition$ |0|))
    (and (= state r) (= x (+ x$ 1)) (= state$ r) (= transition$ |1|))
    (and (= state q_2) true (= x x$) (= state$ q_0) (= transition$ |2|))
    (and (= state q_1) (= x 0) (= state$ q_0) (= transition$ |3|))
    (and (= state q_1) (= x 1) (= state$ q_2) (= transition$ |4|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location r reachable from initial location q_0: Unknown

=============================
aut/infinite_descent.aut with bound 100
=============================
Automaton:
   Infinite_Descent
1 variables:
   x
4 locations:
   q_0, q_1, q_2, r
Initial location:
   q_0
Final location:
   r
Transitions:
   q_0
      » skip » q_2
      » x := 0 » q_1
   q_1
      » x == 3 » r
   q_2
      » x := 1 » q_1
   r
      » x := (x + 1) » r

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state r) (= x 3) (= x x$) (= state$ q_1) (= transition$ |0|))
    (and (= state r) (= x (+ x$ 1)) (= state$ r) (= transition$ |1|))
    (and (= state q_2) true (= x x$) (= state$ q_0) (= transition$ |2|))
    (and (= state q_1) (= x 0) (= state$ q_0) (= transition$ |3|))
    (and (= state q_1) (= x 1) (= state$ q_2) (= transition$ |4|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: All paths to q_0 are unfeasible.
Depth  27: All paths to q_0 are unfeasible.
Depth  28: All paths to q_0 are unfeasible.
Depth  29: All paths to q_0 are unfeasible.
Depth  30: All paths to q_0 are unfeasible.
Depth  31: All paths to q_0 are unfeasible.
Depth  32: All paths to q_0 are unfeasible.
Depth  33: All paths to q_0 are unfeasible.
Depth  34: All paths to q_0 are unfeasible.
Depth  35: All paths to q_0 are unfeasible.
Depth  36: All paths to q_0 are unfeasible.
Depth  37: All paths to q_0 are unfeasible.
Depth  38: All paths to q_0 are unfeasible.
Depth  39: All paths to q_0 are unfeasible.
Depth  40: All paths to q_0 are unfeasible.
Depth  41: All paths to q_0 are unfeasible.
Depth  42: All paths to q_0 are unfeasible.
Depth  43: All paths to q_0 are unfeasible.
Depth  44: All paths to q_0 are unfeasible.
Depth  45: All paths to q_0 are unfeasible.
Depth  46: All paths to q_0 are unfeasible.
Depth  47: All paths to q_0 are unfeasible.
Depth  48: All paths to q_0 are unfeasible.
Depth  49: All paths to q_0 are unfeasible.
Depth  50: All paths to q_0 are unfeasible.
Depth  51: All paths to q_0 are unfeasible.
Depth  52: All paths to q_0 are unfeasible.
Depth  53: All paths to q_0 are unfeasible.
Depth  54: All paths to q_0 are unfeasible.
Depth  55: All paths to q_0 are unfeasible.
Depth  56: All paths to q_0 are unfeasible.
Depth  57: All paths to q_0 are unfeasible.
Depth  58: All paths to q_0 are unfeasible.
Depth  59: All paths to q_0 are unfeasible.
Depth  60: All paths to q_0 are unfeasible.
Depth  61: All paths to q_0 are unfeasible.
Depth  62: All paths to q_0 are unfeasible.
Depth  63: All paths to q_0 are unfeasible.
Depth  64: All paths to q_0 are unfeasible.
Depth  65: All paths to q_0 are unfeasible.
Depth  66: All paths to q_0 are unfeasible.
Depth  67: All paths to q_0 are unfeasible.
Depth  68: All paths to q_0 are unfeasible.
Depth  69: All paths to q_0 are unfeasible.
Depth  70: All paths to q_0 are unfeasible.
Depth  71: All paths to q_0 are unfeasible.
Depth  72: All paths to q_0 are unfeasible.
Depth  73: All paths to q_0 are unfeasible.
Depth  74: All paths to q_0 are unfeasible.
Depth  75: All paths to q_0 are unfeasible.
Depth  76: All paths to q_0 are unfeasible.
Depth  77: All paths to q_0 are unfeasible.
Depth  78: All paths to q_0 are unfeasible.
Depth  79: All paths to q_0 are unfeasible.
Depth  80: All paths to q_0 are unfeasible.
Depth  81: All paths to q_0 are unfeasible.
Depth  82: All paths to q_0 are unfeasible.
Depth  83: All paths to q_0 are unfeasible.
Depth  84: All paths to q_0 are unfeasible.
Depth  85: All paths to q_0 are unfeasible.
Depth  86: All paths to q_0 are unfeasible.
Depth  87: All paths to q_0 are unfeasible.
Depth  88: All paths to q_0 are unfeasible.
Depth  89: All paths to q_0 are unfeasible.
Depth  90: All paths to q_0 are unfeasible.
Depth  91: All paths to q_0 are unfeasible.
Depth  92: All paths to q_0 are unfeasible.
Depth  93: All paths to q_0 are unfeasible.
Depth  94: All paths to q_0 are unfeasible.
Depth  95: All paths to q_0 are unfeasible.
Depth  96: All paths to q_0 are unfeasible.
Depth  97: All paths to q_0 are unfeasible.
Depth  98: All paths to q_0 are unfeasible.
Depth  99: All paths to q_0 are unfeasible.
Depth 100: All paths to q_0 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location r reachable from initial location q_0: Unknown

=============================
aut/negative_division.aut with bound 5
=============================
Automaton:
   Negative_Division
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := -5 » q_1
   q_1
      » y := (x / 2) » q_2
   q_2
      » y != -2 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 2) (- (div (- x) 2)))))
  (or (and (= state q_bad)
           (not (= y (- 2)))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |0|))
      (and (= state q_2)
           (not (= 2 0))
           (= y a!1)
           (= x x$)
           (= state$ q_1)
           (= transition$ |1|))
      (and (= state q_1)
           (= x (- 5))
           (= y y$)
           (= state$ q_0)
           (= transition$ |2|))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/negative_division.aut with bound 25
=============================
Automaton:
   Negative_Division
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := -5 » q_1
   q_1
      » y := (x / 2) » q_2
   q_2
      » y != -2 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 2) (- (div (- x) 2)))))
  (or (and (= state q_bad)
           (not (= y (- 2)))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |0|))
      (and (= state q_2)
           (not (= 2 0))
           (= y a!1)
           (= x x$)
           (= state$ q_1)
           (= transition$ |1|))
      (and (= state q_1)
           (= x (- 5))
           (= y y$)
           (= state$ q_0)
           (= transition$ |2|))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/negative_division.aut with bound 100
=============================
Automaton:
   Negative_Division
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := -5 » q_1
   q_1
      » y := (x / 2) » q_2
   q_2
      » y != -2 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 2) (- (div (- x) 2)))))
  (or (and (= state q_bad)
           (not (= y (- 2)))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |0|))
      (and (= state q_2)
           (not (= 2 0))
           (= y a!1)
           (= x x$)
           (= state$ q_1)
           (= transition$ |1|))
      (and (= state q_1)
           (= x (- 5))
           (= y y$)
           (= state$ q_0)
           (= transition$ |2|))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/predicates-01.aut with bound 5
=============================
Automaton:
   Predicates_1
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x := (x + 1) » q_3
      » x > 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » (x + y) < 0 » q_bad
      » (x + y) > 0 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad)
         (< (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_bad)
         (> (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |1|))
    (and (= state q_4)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_3)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_2) (= y 0) (= x x$) (= state$ q_1) (= transition$ |4|))
    (and (= state q_2)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_3)
         (= transition$ |5|))
    (and (= state q_1) (= x 0) (= y y$) (= state$ q_0) (= transition$ |6|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/predicates-01.aut with bound 25
=============================
Automaton:
   Predicates_1
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x := (x + 1) » q_3
      » x > 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » (x + y) < 0 » q_bad
      » (x + y) > 0 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad)
         (< (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_bad)
         (> (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |1|))
    (and (= state q_4)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_3)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_2) (= y 0) (= x x$) (= state$ q_1) (= transition$ |4|))
    (and (= state q_2)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_3)
         (= transition$ |5|))
    (and (= state q_1) (= x 0) (= y y$) (= state$ q_0) (= transition$ |6|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/predicates-01.aut with bound 100
=============================
Automaton:
   Predicates_1
2 variables:
   x, y
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 0 » q_1
   q_1
      » y := 0 » q_2
   q_2
      » x := (x + 1) » q_3
      » x > 0 » q_4
   q_3
      » y := (y - 1) » q_2
   q_4
      » (x + y) < 0 » q_bad
      » (x + y) > 0 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad)
         (< (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |0|))
    (and (= state q_bad)
         (> (+ x y) 0)
         (= x x$)
         (= y y$)
         (= state$ q_4)
         (= transition$ |1|))
    (and (= state q_4)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |2|))
    (and (= state q_3)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ q_2)
         (= transition$ |3|))
    (and (= state q_2) (= y 0) (= x x$) (= state$ q_1) (= transition$ |4|))
    (and (= state q_2)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_3)
         (= transition$ |5|))
    (and (= state q_1) (= x 0) (= y y$) (= state$ q_0) (= transition$ |6|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: All paths to q_0 are unfeasible.
Depth  27: All paths to q_0 are unfeasible.
Depth  28: All paths to q_0 are unfeasible.
Depth  29: All paths to q_0 are unfeasible.
Depth  30: All paths to q_0 are unfeasible.
Depth  31: All paths to q_0 are unfeasible.
Depth  32: All paths to q_0 are unfeasible.
Depth  33: All paths to q_0 are unfeasible.
Depth  34: All paths to q_0 are unfeasible.
Depth  35: All paths to q_0 are unfeasible.
Depth  36: All paths to q_0 are unfeasible.
Depth  37: All paths to q_0 are unfeasible.
Depth  38: All paths to q_0 are unfeasible.
Depth  39: All paths to q_0 are unfeasible.
Depth  40: All paths to q_0 are unfeasible.
Depth  41: All paths to q_0 are unfeasible.
Depth  42: All paths to q_0 are unfeasible.
Depth  43: All paths to q_0 are unfeasible.
Depth  44: All paths to q_0 are unfeasible.
Depth  45: All paths to q_0 are unfeasible.
Depth  46: All paths to q_0 are unfeasible.
Depth  47: All paths to q_0 are unfeasible.
Depth  48: All paths to q_0 are unfeasible.
Depth  49: All paths to q_0 are unfeasible.
Depth  50: All paths to q_0 are unfeasible.
Depth  51: All paths to q_0 are unfeasible.
Depth  52: All paths to q_0 are unfeasible.
Depth  53: All paths to q_0 are unfeasible.
Depth  54: All paths to q_0 are unfeasible.
Depth  55: All paths to q_0 are unfeasible.
Depth  56: All paths to q_0 are unfeasible.
Depth  57: All paths to q_0 are unfeasible.
Depth  58: All paths to q_0 are unfeasible.
Depth  59: All paths to q_0 are unfeasible.
Depth  60: All paths to q_0 are unfeasible.
Depth  61: All paths to q_0 are unfeasible.
Depth  62: All paths to q_0 are unfeasible.
Depth  63: All paths to q_0 are unfeasible.
Depth  64: All paths to q_0 are unfeasible.
Depth  65: All paths to q_0 are unfeasible.
Depth  66: All paths to q_0 are unfeasible.
Depth  67: All paths to q_0 are unfeasible.
Depth  68: All paths to q_0 are unfeasible.
Depth  69: All paths to q_0 are unfeasible.
Depth  70: All paths to q_0 are unfeasible.
Depth  71: All paths to q_0 are unfeasible.
Depth  72: All paths to q_0 are unfeasible.
Depth  73: All paths to q_0 are unfeasible.
Depth  74: All paths to q_0 are unfeasible.
Depth  75: All paths to q_0 are unfeasible.
Depth  76: All paths to q_0 are unfeasible.
Depth  77: All paths to q_0 are unfeasible.
Depth  78: All paths to q_0 are unfeasible.
Depth  79: All paths to q_0 are unfeasible.
Depth  80: All paths to q_0 are unfeasible.
Depth  81: All paths to q_0 are unfeasible.
Depth  82: All paths to q_0 are unfeasible.
Depth  83: All paths to q_0 are unfeasible.
Depth  84: All paths to q_0 are unfeasible.
Depth  85: All paths to q_0 are unfeasible.
Depth  86: All paths to q_0 are unfeasible.
Depth  87: All paths to q_0 are unfeasible.
Depth  88: All paths to q_0 are unfeasible.
Depth  89: All paths to q_0 are unfeasible.
Depth  90: All paths to q_0 are unfeasible.
Depth  91: All paths to q_0 are unfeasible.
Depth  92: All paths to q_0 are unfeasible.
Depth  93: All paths to q_0 are unfeasible.
Depth  94: All paths to q_0 are unfeasible.
Depth  95: All paths to q_0 are unfeasible.
Depth  96: All paths to q_0 are unfeasible.
Depth  97: All paths to q_0 are unfeasible.
Depth  98: All paths to q_0 are unfeasible.
Depth  99: All paths to q_0 are unfeasible.
Depth 100: All paths to q_0 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/predicates-02.aut with bound 5
=============================
Automaton:
   Predicates_2
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
   q_1
      » y := x » q_2
   q_2
      » y < 0 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_2) (= y x) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_1)
         (>= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_0)
         (= transition$ |2|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/predicates-02.aut with bound 25
=============================
Automaton:
   Predicates_2
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
   q_1
      » y := x » q_2
   q_2
      » y < 0 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_2) (= y x) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_1)
         (>= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_0)
         (= transition$ |2|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/predicates-02.aut with bound 100
=============================
Automaton:
   Predicates_2
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
   q_1
      » y := x » q_2
   q_2
      » y < 0 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ q_2)
         (= transition$ |0|))
    (and (= state q_2) (= y x) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_1)
         (>= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_0)
         (= transition$ |2|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: No feasible path of length 3. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/pre_only.aut with bound 5
=============================
Automaton:
   Pre_Only
3 variables:
   x, y, z
5 locations:
   q_0, q_1, q_2, q_3, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » (x * y) >= 0 » q_1
   q_1
      » z := y » q_2
   q_2
      » x < 0 » q_3
   q_3
      » z >= 3 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad)
         (>= z 3)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |0|))
    (and (= state q_3)
         (< x 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (= z y)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (>= (* x y) 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |3|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/pre_only.aut with bound 25
=============================
Automaton:
   Pre_Only
3 variables:
   x, y, z
5 locations:
   q_0, q_1, q_2, q_3, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » (x * y) >= 0 » q_1
   q_1
      » z := y » q_2
   q_2
      » x < 0 » q_3
   q_3
      » z >= 3 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad)
         (>= z 3)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |0|))
    (and (= state q_3)
         (< x 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (= z y)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (>= (* x y) 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |3|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/pre_only.aut with bound 100
=============================
Automaton:
   Pre_Only
3 variables:
   x, y, z
5 locations:
   q_0, q_1, q_2, q_3, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » (x * y) >= 0 » q_1
   q_1
      » z := y » q_2
   q_2
      » x < 0 » q_3
   q_3
      » z >= 3 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad)
         (>= z 3)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_3)
         (= transition$ |0|))
    (and (= state q_3)
         (< x 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_2)
         (= transition$ |1|))
    (and (= state q_2)
         (= z y)
         (= x x$)
         (= y y$)
         (= state$ q_1)
         (= transition$ |2|))
    (and (= state q_1)
         (>= (* x y) 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ q_0)
         (= transition$ |3|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_bad reachable from initial location q_0: No

=============================
aut/running_example.aut with bound 5
=============================
Automaton:
   Running_Example
2 variables:
   x, y
9 locations:
   q_01, q_02, q_03, q_06, q_07, q_08, q_11, q_12, q_13
Initial location:
   q_01
Final location:
   q_13
Transitions:
   q_01
      » x := 1 » q_02
   q_02
      » y <= 10 » q_03
      » y > 10 » q_06
   q_03
      » y := 10 » q_11
   q_06
      » x < y » q_07
      » x >= y » q_11
   q_07
      » x := (2 * x) » q_08
   q_08
      » y := (y - 1) » q_06
   q_11
      » x := (y + 1) » q_12
   q_12
      » x <= 0 » q_13

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_13)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_12)
         (= transition$ |0|))
    (and (= state q_12)
         (= x (+ y 1))
         (= y y$)
         (= state$ q_11)
         (= transition$ |1|))
    (and (= state q_11) (= y 10) (= x x$) (= state$ q_03) (= transition$ |2|))
    (and (= state q_11)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |3|))
    (and (= state q_08)
         (= x (* 2 x$))
         (= y y$)
         (= state$ q_07)
         (= transition$ |4|))
    (and (= state q_07)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |5|))
    (and (= state q_06)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ q_02)
         (= transition$ |6|))
    (and (= state q_06)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_08)
         (= transition$ |7|))
    (and (= state q_03)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ q_02)
         (= transition$ |8|))
    (and (= state q_02) (= x 1) (= y y$) (= state$ q_01) (= transition$ |9|)))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: All paths to q_01 are unfeasible.
Depth   5: All paths to q_01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_13 reachable from initial location q_01: Unknown

=============================
aut/running_example.aut with bound 25
=============================
Automaton:
   Running_Example
2 variables:
   x, y
9 locations:
   q_01, q_02, q_03, q_06, q_07, q_08, q_11, q_12, q_13
Initial location:
   q_01
Final location:
   q_13
Transitions:
   q_01
      » x := 1 » q_02
   q_02
      » y <= 10 » q_03
      » y > 10 » q_06
   q_03
      » y := 10 » q_11
   q_06
      » x < y » q_07
      » x >= y » q_11
   q_07
      » x := (2 * x) » q_08
   q_08
      » y := (y - 1) » q_06
   q_11
      » x := (y + 1) » q_12
   q_12
      » x <= 0 » q_13

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_13)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_12)
         (= transition$ |0|))
    (and (= state q_12)
         (= x (+ y 1))
         (= y y$)
         (= state$ q_11)
         (= transition$ |1|))
    (and (= state q_11) (= y 10) (= x x$) (= state$ q_03) (= transition$ |2|))
    (and (= state q_11)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |3|))
    (and (= state q_08)
         (= x (* 2 x$))
         (= y y$)
         (= state$ q_07)
         (= transition$ |4|))
    (and (= state q_07)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |5|))
    (and (= state q_06)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ q_02)
         (= transition$ |6|))
    (and (= state q_06)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_08)
         (= transition$ |7|))
    (and (= state q_03)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ q_02)
         (= transition$ |8|))
    (and (= state q_02) (= x 1) (= y y$) (= state$ q_01) (= transition$ |9|)))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: All paths to q_01 are unfeasible.
Depth   5: All paths to q_01 are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_13 reachable from initial location q_01: No

=============================
aut/running_example.aut with bound 100
=============================
Automaton:
   Running_Example
2 variables:
   x, y
9 locations:
   q_01, q_02, q_03, q_06, q_07, q_08, q_11, q_12, q_13
Initial location:
   q_01
Final location:
   q_13
Transitions:
   q_01
      » x := 1 » q_02
   q_02
      » y <= 10 » q_03
      » y > 10 » q_06
   q_03
      » y := 10 » q_11
   q_06
      » x < y » q_07
      » x >= y » q_11
   q_07
      » x := (2 * x) » q_08
   q_08
      » y := (y - 1) » q_06
   q_11
      » x := (y + 1) » q_12
   q_12
      » x <= 0 » q_13

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_13)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ q_12)
         (= transition$ |0|))
    (and (= state q_12)
         (= x (+ y 1))
         (= y y$)
         (= state$ q_11)
         (= transition$ |1|))
    (and (= state q_11) (= y 10) (= x x$) (= state$ q_03) (= transition$ |2|))
    (and (= state q_11)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |3|))
    (and (= state q_08)
         (= x (* 2 x$))
         (= y y$)
         (= state$ q_07)
         (= transition$ |4|))
    (and (= state q_07)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ q_06)
         (= transition$ |5|))
    (and (= state q_06)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ q_02)
         (= transition$ |6|))
    (and (= state q_06)
         (= y (- y$ 1))
         (= x x$)
         (= state$ q_08)
         (= transition$ |7|))
    (and (= state q_03)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ q_02)
         (= transition$ |8|))
    (and (= state q_02) (= x 1) (= y y$) (= state$ q_01) (= transition$ |9|)))

Depth   1: All paths to q_01 are unfeasible.
Depth   2: All paths to q_01 are unfeasible.
Depth   3: All paths to q_01 are unfeasible.
Depth   4: All paths to q_01 are unfeasible.
Depth   5: All paths to q_01 are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location q_13 reachable from initial location q_01: No

=============================
aut/sign_nonzero_crucial.aut with bound 5
=============================
Automaton:
   Sign_Nonzero
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
      » x < 0 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad) (= x 0) (= x x$) (= state$ q_4) (= transition$ |0|))
    (and (= state q_4) (>= x 10) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_4) (<= x 10) (= x x$) (= state$ q_3) (= transition$ |2|))
    (and (= state q_3) (< x 0) (= x x$) (= state$ q_0) (= transition$ |3|))
    (and (= state q_3) (= x (- x$ 1)) (= state$ q_3) (= transition$ |4|))
    (and (= state q_2) (< x 10) (= x x$) (= state$ q_1) (= transition$ |5|))
    (and (= state q_1) (>= x 0) (= x x$) (= state$ q_0) (= transition$ |6|))
    (and (= state q_1) (= x (+ x$ 1)) (= state$ q_2) (= transition$ |7|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial.aut with bound 25
=============================
Automaton:
   Sign_Nonzero
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
      » x < 0 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad) (= x 0) (= x x$) (= state$ q_4) (= transition$ |0|))
    (and (= state q_4) (>= x 10) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_4) (<= x 10) (= x x$) (= state$ q_3) (= transition$ |2|))
    (and (= state q_3) (< x 0) (= x x$) (= state$ q_0) (= transition$ |3|))
    (and (= state q_3) (= x (- x$ 1)) (= state$ q_3) (= transition$ |4|))
    (and (= state q_2) (< x 10) (= x x$) (= state$ q_1) (= transition$ |5|))
    (and (= state q_1) (>= x 0) (= x x$) (= state$ q_0) (= transition$ |6|))
    (and (= state q_1) (= x (+ x$ 1)) (= state$ q_2) (= transition$ |7|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial.aut with bound 100
=============================
Automaton:
   Sign_Nonzero
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x >= 0 » q_1
      » x < 0 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad) (= x 0) (= x x$) (= state$ q_4) (= transition$ |0|))
    (and (= state q_4) (>= x 10) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_4) (<= x 10) (= x x$) (= state$ q_3) (= transition$ |2|))
    (and (= state q_3) (< x 0) (= x x$) (= state$ q_0) (= transition$ |3|))
    (and (= state q_3) (= x (- x$ 1)) (= state$ q_3) (= transition$ |4|))
    (and (= state q_2) (< x 10) (= x x$) (= state$ q_1) (= transition$ |5|))
    (and (= state q_1) (>= x 0) (= x x$) (= state$ q_0) (= transition$ |6|))
    (and (= state q_1) (= x (+ x$ 1)) (= state$ q_2) (= transition$ |7|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: All paths to q_0 are unfeasible.
Depth  27: All paths to q_0 are unfeasible.
Depth  28: All paths to q_0 are unfeasible.
Depth  29: All paths to q_0 are unfeasible.
Depth  30: All paths to q_0 are unfeasible.
Depth  31: All paths to q_0 are unfeasible.
Depth  32: All paths to q_0 are unfeasible.
Depth  33: All paths to q_0 are unfeasible.
Depth  34: All paths to q_0 are unfeasible.
Depth  35: All paths to q_0 are unfeasible.
Depth  36: All paths to q_0 are unfeasible.
Depth  37: All paths to q_0 are unfeasible.
Depth  38: All paths to q_0 are unfeasible.
Depth  39: All paths to q_0 are unfeasible.
Depth  40: All paths to q_0 are unfeasible.
Depth  41: All paths to q_0 are unfeasible.
Depth  42: All paths to q_0 are unfeasible.
Depth  43: All paths to q_0 are unfeasible.
Depth  44: All paths to q_0 are unfeasible.
Depth  45: All paths to q_0 are unfeasible.
Depth  46: All paths to q_0 are unfeasible.
Depth  47: All paths to q_0 are unfeasible.
Depth  48: All paths to q_0 are unfeasible.
Depth  49: All paths to q_0 are unfeasible.
Depth  50: All paths to q_0 are unfeasible.
Depth  51: All paths to q_0 are unfeasible.
Depth  52: All paths to q_0 are unfeasible.
Depth  53: All paths to q_0 are unfeasible.
Depth  54: All paths to q_0 are unfeasible.
Depth  55: All paths to q_0 are unfeasible.
Depth  56: All paths to q_0 are unfeasible.
Depth  57: All paths to q_0 are unfeasible.
Depth  58: All paths to q_0 are unfeasible.
Depth  59: All paths to q_0 are unfeasible.
Depth  60: All paths to q_0 are unfeasible.
Depth  61: All paths to q_0 are unfeasible.
Depth  62: All paths to q_0 are unfeasible.
Depth  63: All paths to q_0 are unfeasible.
Depth  64: All paths to q_0 are unfeasible.
Depth  65: All paths to q_0 are unfeasible.
Depth  66: All paths to q_0 are unfeasible.
Depth  67: All paths to q_0 are unfeasible.
Depth  68: All paths to q_0 are unfeasible.
Depth  69: All paths to q_0 are unfeasible.
Depth  70: All paths to q_0 are unfeasible.
Depth  71: All paths to q_0 are unfeasible.
Depth  72: All paths to q_0 are unfeasible.
Depth  73: All paths to q_0 are unfeasible.
Depth  74: All paths to q_0 are unfeasible.
Depth  75: All paths to q_0 are unfeasible.
Depth  76: All paths to q_0 are unfeasible.
Depth  77: All paths to q_0 are unfeasible.
Depth  78: All paths to q_0 are unfeasible.
Depth  79: All paths to q_0 are unfeasible.
Depth  80: All paths to q_0 are unfeasible.
Depth  81: All paths to q_0 are unfeasible.
Depth  82: All paths to q_0 are unfeasible.
Depth  83: All paths to q_0 are unfeasible.
Depth  84: All paths to q_0 are unfeasible.
Depth  85: All paths to q_0 are unfeasible.
Depth  86: All paths to q_0 are unfeasible.
Depth  87: All paths to q_0 are unfeasible.
Depth  88: All paths to q_0 are unfeasible.
Depth  89: All paths to q_0 are unfeasible.
Depth  90: All paths to q_0 are unfeasible.
Depth  91: All paths to q_0 are unfeasible.
Depth  92: All paths to q_0 are unfeasible.
Depth  93: All paths to q_0 are unfeasible.
Depth  94: All paths to q_0 are unfeasible.
Depth  95: All paths to q_0 are unfeasible.
Depth  96: All paths to q_0 are unfeasible.
Depth  97: All paths to q_0 are unfeasible.
Depth  98: All paths to q_0 are unfeasible.
Depth  99: All paths to q_0 are unfeasible.
Depth 100: All paths to q_0 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial_variant.aut with bound 5
=============================
Automaton:
   Sign_Nonzero_Variant
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 2 » q_1
      » x := -3 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state q_bad) (= x 0) (= x x$) (= state$ q_4) (= transition$ |0|))
    (and (= state q_4) (>= x 10) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_4) (<= x 10) (= x x$) (= state$ q_3) (= transition$ |2|))
    (and (= state q_3) (= x (- 3)) (= state$ q_0) (= transition$ |3|))
    (and (= state q_3) (= x (- x$ 1)) (= state$ q_3) (= transition$ |4|))
    (and (= state q_2) (< x 10) (= x x$) (= state$ q_1) (= transition$ |5|))
    (and (= state q_1) (= x 2) (= state$ q_0) (= transition$ |6|))
    (and (= state q_1) (= x (+ x$ 1)) (= state$ q_2) (= transition$ |7|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial_variant.aut with bound 25
=============================
Automaton:
   Sign_Nonzero_Variant
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 2 » q_1
      » x := -3 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state q_bad) (= x 0) (= x x$) (= state$ q_4) (= transition$ |0|))
    (and (= state q_4) (>= x 10) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_4) (<= x 10) (= x x$) (= state$ q_3) (= transition$ |2|))
    (and (= state q_3) (= x (- 3)) (= state$ q_0) (= transition$ |3|))
    (and (= state q_3) (= x (- x$ 1)) (= state$ q_3) (= transition$ |4|))
    (and (= state q_2) (< x 10) (= x x$) (= state$ q_1) (= transition$ |5|))
    (and (= state q_1) (= x 2) (= state$ q_0) (= transition$ |6|))
    (and (= state q_1) (= x (+ x$ 1)) (= state$ q_2) (= transition$ |7|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/sign_nonzero_crucial_variant.aut with bound 100
=============================
Automaton:
   Sign_Nonzero_Variant
1 variables:
   x
6 locations:
   q_0, q_1, q_2, q_3, q_4, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x := 2 » q_1
      » x := -3 » q_3
   q_1
      » x < 10 » q_2
      » x >= 10 » q_4
   q_2
      » x := (x + 1) » q_1
   q_3
      » x := (x - 1) » q_3
      » x <= 10 » q_4
   q_4
      » x == 0 » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state q_bad) (= x 0) (= x x$) (= state$ q_4) (= transition$ |0|))
    (and (= state q_4) (>= x 10) (= x x$) (= state$ q_1) (= transition$ |1|))
    (and (= state q_4) (<= x 10) (= x x$) (= state$ q_3) (= transition$ |2|))
    (and (= state q_3) (= x (- 3)) (= state$ q_0) (= transition$ |3|))
    (and (= state q_3) (= x (- x$ 1)) (= state$ q_3) (= transition$ |4|))
    (and (= state q_2) (< x 10) (= x x$) (= state$ q_1) (= transition$ |5|))
    (and (= state q_1) (= x 2) (= state$ q_0) (= transition$ |6|))
    (and (= state q_1) (= x (+ x$ 1)) (= state$ q_2) (= transition$ |7|)))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: All paths to q_0 are unfeasible.
Depth   4: All paths to q_0 are unfeasible.
Depth   5: All paths to q_0 are unfeasible.
Depth   6: All paths to q_0 are unfeasible.
Depth   7: All paths to q_0 are unfeasible.
Depth   8: All paths to q_0 are unfeasible.
Depth   9: All paths to q_0 are unfeasible.
Depth  10: All paths to q_0 are unfeasible.
Depth  11: All paths to q_0 are unfeasible.
Depth  12: All paths to q_0 are unfeasible.
Depth  13: All paths to q_0 are unfeasible.
Depth  14: All paths to q_0 are unfeasible.
Depth  15: All paths to q_0 are unfeasible.
Depth  16: All paths to q_0 are unfeasible.
Depth  17: All paths to q_0 are unfeasible.
Depth  18: All paths to q_0 are unfeasible.
Depth  19: All paths to q_0 are unfeasible.
Depth  20: All paths to q_0 are unfeasible.
Depth  21: All paths to q_0 are unfeasible.
Depth  22: All paths to q_0 are unfeasible.
Depth  23: All paths to q_0 are unfeasible.
Depth  24: All paths to q_0 are unfeasible.
Depth  25: All paths to q_0 are unfeasible.
Depth  26: All paths to q_0 are unfeasible.
Depth  27: All paths to q_0 are unfeasible.
Depth  28: All paths to q_0 are unfeasible.
Depth  29: All paths to q_0 are unfeasible.
Depth  30: All paths to q_0 are unfeasible.
Depth  31: All paths to q_0 are unfeasible.
Depth  32: All paths to q_0 are unfeasible.
Depth  33: All paths to q_0 are unfeasible.
Depth  34: All paths to q_0 are unfeasible.
Depth  35: All paths to q_0 are unfeasible.
Depth  36: All paths to q_0 are unfeasible.
Depth  37: All paths to q_0 are unfeasible.
Depth  38: All paths to q_0 are unfeasible.
Depth  39: All paths to q_0 are unfeasible.
Depth  40: All paths to q_0 are unfeasible.
Depth  41: All paths to q_0 are unfeasible.
Depth  42: All paths to q_0 are unfeasible.
Depth  43: All paths to q_0 are unfeasible.
Depth  44: All paths to q_0 are unfeasible.
Depth  45: All paths to q_0 are unfeasible.
Depth  46: All paths to q_0 are unfeasible.
Depth  47: All paths to q_0 are unfeasible.
Depth  48: All paths to q_0 are unfeasible.
Depth  49: All paths to q_0 are unfeasible.
Depth  50: All paths to q_0 are unfeasible.
Depth  51: All paths to q_0 are unfeasible.
Depth  52: All paths to q_0 are unfeasible.
Depth  53: All paths to q_0 are unfeasible.
Depth  54: All paths to q_0 are unfeasible.
Depth  55: All paths to q_0 are unfeasible.
Depth  56: All paths to q_0 are unfeasible.
Depth  57: All paths to q_0 are unfeasible.
Depth  58: All paths to q_0 are unfeasible.
Depth  59: All paths to q_0 are unfeasible.
Depth  60: All paths to q_0 are unfeasible.
Depth  61: All paths to q_0 are unfeasible.
Depth  62: All paths to q_0 are unfeasible.
Depth  63: All paths to q_0 are unfeasible.
Depth  64: All paths to q_0 are unfeasible.
Depth  65: All paths to q_0 are unfeasible.
Depth  66: All paths to q_0 are unfeasible.
Depth  67: All paths to q_0 are unfeasible.
Depth  68: All paths to q_0 are unfeasible.
Depth  69: All paths to q_0 are unfeasible.
Depth  70: All paths to q_0 are unfeasible.
Depth  71: All paths to q_0 are unfeasible.
Depth  72: All paths to q_0 are unfeasible.
Depth  73: All paths to q_0 are unfeasible.
Depth  74: All paths to q_0 are unfeasible.
Depth  75: All paths to q_0 are unfeasible.
Depth  76: All paths to q_0 are unfeasible.
Depth  77: All paths to q_0 are unfeasible.
Depth  78: All paths to q_0 are unfeasible.
Depth  79: All paths to q_0 are unfeasible.
Depth  80: All paths to q_0 are unfeasible.
Depth  81: All paths to q_0 are unfeasible.
Depth  82: All paths to q_0 are unfeasible.
Depth  83: All paths to q_0 are unfeasible.
Depth  84: All paths to q_0 are unfeasible.
Depth  85: All paths to q_0 are unfeasible.
Depth  86: All paths to q_0 are unfeasible.
Depth  87: All paths to q_0 are unfeasible.
Depth  88: All paths to q_0 are unfeasible.
Depth  89: All paths to q_0 are unfeasible.
Depth  90: All paths to q_0 are unfeasible.
Depth  91: All paths to q_0 are unfeasible.
Depth  92: All paths to q_0 are unfeasible.
Depth  93: All paths to q_0 are unfeasible.
Depth  94: All paths to q_0 are unfeasible.
Depth  95: All paths to q_0 are unfeasible.
Depth  96: All paths to q_0 are unfeasible.
Depth  97: All paths to q_0 are unfeasible.
Depth  98: All paths to q_0 are unfeasible.
Depth  99: All paths to q_0 are unfeasible.
Depth 100: All paths to q_0 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/single_path_hard_for_z3.aut with bound 5
=============================
Automaton:
   Single_Path_Hard_for_Z3
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x == (3 * (x / 3)) » q_1
   q_1
      » x := (x * y) » q_2
   q_2
      » (x - 1) == (3 * (x / 3)) » q_bad

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 3) (- (div (- x) 3)))))
  (or (and (= state q_bad)
           (not (= 3 0))
           (= (- x 1) (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |0|))
      (and (= state q_2)
           (= x (* x$ y))
           (= y y$)
           (= state$ q_1)
           (= transition$ |1|))
      (and (= state q_1)
           (not (= 3 0))
           (= x (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |2|))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: Some path to q_0 might be feasible.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/single_path_hard_for_z3.aut with bound 25
=============================
Automaton:
   Single_Path_Hard_for_Z3
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x == (3 * (x / 3)) » q_1
   q_1
      » x := (x * y) » q_2
   q_2
      » (x - 1) == (3 * (x / 3)) » q_bad

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 3) (- (div (- x) 3)))))
  (or (and (= state q_bad)
           (not (= 3 0))
           (= (- x 1) (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |0|))
      (and (= state q_2)
           (= x (* x$ y))
           (= y y$)
           (= state$ q_1)
           (= transition$ |1|))
      (and (= state q_1)
           (not (= 3 0))
           (= x (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |2|))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: Some path to q_0 might be feasible.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
aut/single_path_hard_for_z3.aut with bound 100
=============================
Automaton:
   Single_Path_Hard_for_Z3
2 variables:
   x, y
4 locations:
   q_0, q_1, q_2, q_bad
Initial location:
   q_0
Final location:
   q_bad
Transitions:
   q_0
      » x == (3 * (x / 3)) » q_1
   q_1
      » x := (x * y) » q_2
   q_2
      » (x - 1) == (3 * (x / 3)) » q_bad

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= x 0) (div x 3) (- (div (- x) 3)))))
  (or (and (= state q_bad)
           (not (= 3 0))
           (= (- x 1) (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_2)
           (= transition$ |0|))
      (and (= state q_2)
           (= x (* x$ y))
           (= y y$)
           (= state$ q_1)
           (= transition$ |1|))
      (and (= state q_1)
           (not (= 3 0))
           (= x (* 3 a!1))
           (= x x$)
           (= y y$)
           (= state$ q_0)
           (= transition$ |2|))))

Depth   1: All paths to q_0 are unfeasible.
Depth   2: All paths to q_0 are unfeasible.
Depth   3: Some path to q_0 might be feasible.

Feasible path:
   None, not exhaustive

Final location q_bad reachable from initial location q_0: Unknown

=============================
prg/bfs_shorter.c with bound 5
=============================
Automaton:
   bfs_sorter
1 variables:
   x
8 locations:
   l07-c01, l08-c01, l10-c02, l12-c03, l16-c03, l18-c02, l20-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » 1 != 0 » l10-c02
      » 1 == 0 » l20-c00
   l10-c02
      » skip » l12-c03
      » skip » l16-c03
   l12-c03
      » skip » l18-c02
   l16-c03
      » x := (x + 1) » l18-c02
   l18-c02
      » x <= 10 » l08-c01
      » x > 10 » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state ~assert)
         (> x 10)
         (= x x$)
         (= state$ l18-c02)
         (= transition$ |0|))
    (and (= state l20-c00)
         (= 1 0)
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |1|))
    (and (= state l18-c02)
         (and true (= x x$))
         (= state$ l12-c03)
         (= transition$ |2|))
    (and (= state l18-c02)
         (= x (+ x$ 1))
         (= state$ l16-c03)
         (= transition$ |3|))
    (and (= state l16-c03)
         (and true (= x x$))
         (= state$ l10-c02)
         (= transition$ |4|))
    (and (= state l12-c03)
         (and true (= x x$))
         (= state$ l10-c02)
         (= transition$ |5|))
    (and (= state l10-c02)
         (not (= 1 0))
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |6|))
    (and (= state l08-c01)
         (<= x 10)
         (= x x$)
         (= state$ l18-c02)
         (= transition$ |7|))
    (and (= state l08-c01) (= x 0) (= state$ l07-c01) (= transition$ |8|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bfs_shorter.c with bound 25
=============================
Automaton:
   bfs_sorter
1 variables:
   x
8 locations:
   l07-c01, l08-c01, l10-c02, l12-c03, l16-c03, l18-c02, l20-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » 1 != 0 » l10-c02
      » 1 == 0 » l20-c00
   l10-c02
      » skip » l12-c03
      » skip » l16-c03
   l12-c03
      » skip » l18-c02
   l16-c03
      » x := (x + 1) » l18-c02
   l18-c02
      » x <= 10 » l08-c01
      » x > 10 » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state ~assert)
         (> x 10)
         (= x x$)
         (= state$ l18-c02)
         (= transition$ |0|))
    (and (= state l20-c00)
         (= 1 0)
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |1|))
    (and (= state l18-c02)
         (and true (= x x$))
         (= state$ l12-c03)
         (= transition$ |2|))
    (and (= state l18-c02)
         (= x (+ x$ 1))
         (= state$ l16-c03)
         (= transition$ |3|))
    (and (= state l16-c03)
         (and true (= x x$))
         (= state$ l10-c02)
         (= transition$ |4|))
    (and (= state l12-c03)
         (and true (= x x$))
         (= state$ l10-c02)
         (= transition$ |5|))
    (and (= state l10-c02)
         (not (= 1 0))
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |6|))
    (and (= state l08-c01)
         (<= x 10)
         (= x x$)
         (= state$ l18-c02)
         (= transition$ |7|))
    (and (= state l08-c01) (= x 0) (= state$ l07-c01) (= transition$ |8|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bfs_shorter.c with bound 100
=============================
Automaton:
   bfs_sorter
1 variables:
   x
8 locations:
   l07-c01, l08-c01, l10-c02, l12-c03, l16-c03, l18-c02, l20-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » 1 != 0 » l10-c02
      » 1 == 0 » l20-c00
   l10-c02
      » skip » l12-c03
      » skip » l16-c03
   l12-c03
      » skip » l18-c02
   l16-c03
      » x := (x + 1) » l18-c02
   l18-c02
      » x <= 10 » l08-c01
      » x > 10 » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state ~assert)
         (> x 10)
         (= x x$)
         (= state$ l18-c02)
         (= transition$ |0|))
    (and (= state l20-c00)
         (= 1 0)
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |1|))
    (and (= state l18-c02)
         (and true (= x x$))
         (= state$ l12-c03)
         (= transition$ |2|))
    (and (= state l18-c02)
         (= x (+ x$ 1))
         (= state$ l16-c03)
         (= transition$ |3|))
    (and (= state l16-c03)
         (and true (= x x$))
         (= state$ l10-c02)
         (= transition$ |4|))
    (and (= state l12-c03)
         (and true (= x x$))
         (= state$ l10-c02)
         (= transition$ |5|))
    (and (= state l10-c02)
         (not (= 1 0))
         (= x x$)
         (= state$ l08-c01)
         (= transition$ |6|))
    (and (= state l08-c01)
         (<= x 10)
         (= x x$)
         (= state$ l18-c02)
         (= transition$ |7|))
    (and (= state l08-c01) (= x 0) (= state$ l07-c01) (= transition$ |8|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: All paths to l07-c01 are unfeasible.
Depth  27: All paths to l07-c01 are unfeasible.
Depth  28: All paths to l07-c01 are unfeasible.
Depth  29: All paths to l07-c01 are unfeasible.
Depth  30: All paths to l07-c01 are unfeasible.
Depth  31: All paths to l07-c01 are unfeasible.
Depth  32: All paths to l07-c01 are unfeasible.
Depth  33: All paths to l07-c01 are unfeasible.
Depth  34: All paths to l07-c01 are unfeasible.
Depth  35: All paths to l07-c01 are unfeasible.
Depth  36: All paths to l07-c01 are unfeasible.
Depth  37: All paths to l07-c01 are unfeasible.
Depth  38: All paths to l07-c01 are unfeasible.
Depth  39: All paths to l07-c01 are unfeasible.
Depth  40: All paths to l07-c01 are unfeasible.
Depth  41: All paths to l07-c01 are unfeasible.
Depth  42: All paths to l07-c01 are unfeasible.
Depth  43: All paths to l07-c01 are unfeasible.
Depth  44: All paths to l07-c01 are unfeasible.
Depth  45: Feasible path found at depth 45.

Feasible path (of length 45):
   l07-c01
      » x := 0 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x <= 10 »
   l08-c01
      » 1 != 0 »
   l10-c02
      » skip »
   l16-c03
      » x := (x + 1) »
   l18-c02
      » x > 10 »
   ~assert

Final location ~assert reachable from initial location l07-c01: Yes

=============================
prg/bin_sum.c with bound 5
=============================
Automaton:
   bin_sum
4 variables:
   x, y, zbin, zun
17 locations:
   l07-c01, l09-c01, l11-c01, l12-c02, l13-c02, l16-c01, l17-c02, l18-c02,
   l21-c01, l22-c02, l23-c02, l26-c01, l27-c02, l28-c02, l31-c01, l32-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » zbin := (x + y) » l09-c01
   l09-c01
      » zun := 0 » l11-c01
   l11-c01
      » x > 0 » l12-c02
      » x <= 0 » l16-c01
   l12-c02
      » x := (x - 1) » l13-c02
   l13-c02
      » zun := (zun + 1) » l11-c01
   l16-c01
      » x < 0 » l17-c02
      » x >= 0 » l21-c01
   l17-c02
      » x := (x + 1) » l18-c02
   l18-c02
      » zun := (zun - 1) » l16-c01
   l21-c01
      » y > 0 » l22-c02
      » y <= 0 » l26-c01
   l22-c02
      » y := (y - 1) » l23-c02
   l23-c02
      » zun := (zun + 1) » l21-c01
   l26-c01
      » y < 0 » l27-c02
      » y >= 0 » l31-c01
   l27-c02
      » y := (y + 1) » l28-c02
   l28-c02
      » zun := (zun - 1) » l26-c01
   l31-c01
      » zbin == zun » l32-c00
      » zbin != zun » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and (= zun (- zun$ 1)) (= x x$) (= y y$) (= zbin zbin$)))
      (a!2 (and (= zun (+ zun$ 1)) (= x x$) (= y y$) (= zbin zbin$))))
  (or (and (= state ~assert)
           (not (= zbin zun))
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |0|))
      (and (= state l32-c00)
           (= zbin zun)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |1|))
      (and (= state l31-c01)
           (>= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |2|))
      (and (= state l28-c02)
           (= y (+ y$ 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l27-c02)
           (= transition$ |3|))
      (and (= state l27-c02)
           (< y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |4|))
      (and (= state l26-c01) a!1 (= state$ l28-c02) (= transition$ |5|))
      (and (= state l26-c01)
           (<= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |6|))
      (and (= state l23-c02)
           (= y (- y$ 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l22-c02)
           (= transition$ |7|))
      (and (= state l22-c02)
           (> y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |8|))
      (and (= state l21-c01) a!2 (= state$ l23-c02) (= transition$ |9|))
      (and (= state l21-c01)
           (>= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |10|))
      (and (= state l18-c02)
           (= x (+ x$ 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l17-c02)
           (= transition$ |11|))
      (and (= state l17-c02)
           (< x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |12|))
      (and (= state l16-c01) a!1 (= state$ l18-c02) (= transition$ |13|))
      (and (= state l16-c01)
           (<= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l11-c01)
           (= transition$ |14|))
      (and (= state l13-c02)
           (= x (- x$ 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l12-c02)
           (= transition$ |15|))
      (and (= state l12-c02)
           (> x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l11-c01)
           (= transition$ |16|))
      (and (= state l11-c01) a!2 (= state$ l13-c02) (= transition$ |17|))
      (and (= state l11-c01)
           (= zun 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= state$ l09-c01)
           (= transition$ |18|))
      (and (= state l09-c01)
           (= zbin (+ x y))
           (= x x$)
           (= y y$)
           (= zun zun$)
           (= state$ l07-c01)
           (= transition$ |19|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bin_sum.c with bound 25
=============================
Automaton:
   bin_sum
4 variables:
   x, y, zbin, zun
17 locations:
   l07-c01, l09-c01, l11-c01, l12-c02, l13-c02, l16-c01, l17-c02, l18-c02,
   l21-c01, l22-c02, l23-c02, l26-c01, l27-c02, l28-c02, l31-c01, l32-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » zbin := (x + y) » l09-c01
   l09-c01
      » zun := 0 » l11-c01
   l11-c01
      » x > 0 » l12-c02
      » x <= 0 » l16-c01
   l12-c02
      » x := (x - 1) » l13-c02
   l13-c02
      » zun := (zun + 1) » l11-c01
   l16-c01
      » x < 0 » l17-c02
      » x >= 0 » l21-c01
   l17-c02
      » x := (x + 1) » l18-c02
   l18-c02
      » zun := (zun - 1) » l16-c01
   l21-c01
      » y > 0 » l22-c02
      » y <= 0 » l26-c01
   l22-c02
      » y := (y - 1) » l23-c02
   l23-c02
      » zun := (zun + 1) » l21-c01
   l26-c01
      » y < 0 » l27-c02
      » y >= 0 » l31-c01
   l27-c02
      » y := (y + 1) » l28-c02
   l28-c02
      » zun := (zun - 1) » l26-c01
   l31-c01
      » zbin == zun » l32-c00
      » zbin != zun » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and (= zun (- zun$ 1)) (= x x$) (= y y$) (= zbin zbin$)))
      (a!2 (and (= zun (+ zun$ 1)) (= x x$) (= y y$) (= zbin zbin$))))
  (or (and (= state ~assert)
           (not (= zbin zun))
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |0|))
      (and (= state l32-c00)
           (= zbin zun)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |1|))
      (and (= state l31-c01)
           (>= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |2|))
      (and (= state l28-c02)
           (= y (+ y$ 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l27-c02)
           (= transition$ |3|))
      (and (= state l27-c02)
           (< y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |4|))
      (and (= state l26-c01) a!1 (= state$ l28-c02) (= transition$ |5|))
      (and (= state l26-c01)
           (<= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |6|))
      (and (= state l23-c02)
           (= y (- y$ 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l22-c02)
           (= transition$ |7|))
      (and (= state l22-c02)
           (> y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |8|))
      (and (= state l21-c01) a!2 (= state$ l23-c02) (= transition$ |9|))
      (and (= state l21-c01)
           (>= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |10|))
      (and (= state l18-c02)
           (= x (+ x$ 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l17-c02)
           (= transition$ |11|))
      (and (= state l17-c02)
           (< x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |12|))
      (and (= state l16-c01) a!1 (= state$ l18-c02) (= transition$ |13|))
      (and (= state l16-c01)
           (<= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l11-c01)
           (= transition$ |14|))
      (and (= state l13-c02)
           (= x (- x$ 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l12-c02)
           (= transition$ |15|))
      (and (= state l12-c02)
           (> x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l11-c01)
           (= transition$ |16|))
      (and (= state l11-c01) a!2 (= state$ l13-c02) (= transition$ |17|))
      (and (= state l11-c01)
           (= zun 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= state$ l09-c01)
           (= transition$ |18|))
      (and (= state l09-c01)
           (= zbin (+ x y))
           (= x x$)
           (= y y$)
           (= zun zun$)
           (= state$ l07-c01)
           (= transition$ |19|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/bin_sum.c with bound 100
=============================
Automaton:
   bin_sum
4 variables:
   x, y, zbin, zun
17 locations:
   l07-c01, l09-c01, l11-c01, l12-c02, l13-c02, l16-c01, l17-c02, l18-c02,
   l21-c01, l22-c02, l23-c02, l26-c01, l27-c02, l28-c02, l31-c01, l32-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » zbin := (x + y) » l09-c01
   l09-c01
      » zun := 0 » l11-c01
   l11-c01
      » x > 0 » l12-c02
      » x <= 0 » l16-c01
   l12-c02
      » x := (x - 1) » l13-c02
   l13-c02
      » zun := (zun + 1) » l11-c01
   l16-c01
      » x < 0 » l17-c02
      » x >= 0 » l21-c01
   l17-c02
      » x := (x + 1) » l18-c02
   l18-c02
      » zun := (zun - 1) » l16-c01
   l21-c01
      » y > 0 » l22-c02
      » y <= 0 » l26-c01
   l22-c02
      » y := (y - 1) » l23-c02
   l23-c02
      » zun := (zun + 1) » l21-c01
   l26-c01
      » y < 0 » l27-c02
      » y >= 0 » l31-c01
   l27-c02
      » y := (y + 1) » l28-c02
   l28-c02
      » zun := (zun - 1) » l26-c01
   l31-c01
      » zbin == zun » l32-c00
      » zbin != zun » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and (= zun (- zun$ 1)) (= x x$) (= y y$) (= zbin zbin$)))
      (a!2 (and (= zun (+ zun$ 1)) (= x x$) (= y y$) (= zbin zbin$))))
  (or (and (= state ~assert)
           (not (= zbin zun))
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |0|))
      (and (= state l32-c00)
           (= zbin zun)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l31-c01)
           (= transition$ |1|))
      (and (= state l31-c01)
           (>= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |2|))
      (and (= state l28-c02)
           (= y (+ y$ 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l27-c02)
           (= transition$ |3|))
      (and (= state l27-c02)
           (< y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l26-c01)
           (= transition$ |4|))
      (and (= state l26-c01) a!1 (= state$ l28-c02) (= transition$ |5|))
      (and (= state l26-c01)
           (<= y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |6|))
      (and (= state l23-c02)
           (= y (- y$ 1))
           (= x x$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l22-c02)
           (= transition$ |7|))
      (and (= state l22-c02)
           (> y 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l21-c01)
           (= transition$ |8|))
      (and (= state l21-c01) a!2 (= state$ l23-c02) (= transition$ |9|))
      (and (= state l21-c01)
           (>= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |10|))
      (and (= state l18-c02)
           (= x (+ x$ 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l17-c02)
           (= transition$ |11|))
      (and (= state l17-c02)
           (< x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l16-c01)
           (= transition$ |12|))
      (and (= state l16-c01) a!1 (= state$ l18-c02) (= transition$ |13|))
      (and (= state l16-c01)
           (<= x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l11-c01)
           (= transition$ |14|))
      (and (= state l13-c02)
           (= x (- x$ 1))
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l12-c02)
           (= transition$ |15|))
      (and (= state l12-c02)
           (> x 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= zun zun$)
           (= state$ l11-c01)
           (= transition$ |16|))
      (and (= state l11-c01) a!2 (= state$ l13-c02) (= transition$ |17|))
      (and (= state l11-c01)
           (= zun 0)
           (= x x$)
           (= y y$)
           (= zbin zbin$)
           (= state$ l09-c01)
           (= transition$ |18|))
      (and (= state l09-c01)
           (= zbin (+ x y))
           (= x x$)
           (= y y$)
           (= zun zun$)
           (= state$ l07-c01)
           (= transition$ |19|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: All paths to l07-c01 are unfeasible.
Depth  27: All paths to l07-c01 are unfeasible.
Depth  28: All paths to l07-c01 are unfeasible.
Depth  29: All paths to l07-c01 are unfeasible.
Depth  30: All paths to l07-c01 are unfeasible.
Depth  31: All paths to l07-c01 are unfeasible.
Depth  32: All paths to l07-c01 are unfeasible.
Depth  33: All paths to l07-c01 are unfeasible.
Depth  34: All paths to l07-c01 are unfeasible.
Depth  35: All paths to l07-c01 are unfeasible.
Depth  36: All paths to l07-c01 are unfeasible.
Depth  37: All paths to l07-c01 are unfeasible.
Depth  38: All paths to l07-c01 are unfeasible.
Depth  39: All paths to l07-c01 are unfeasible.
Depth  40: All paths to l07-c01 are unfeasible.
Depth  41: All paths to l07-c01 are unfeasible.
Depth  42: All paths to l07-c01 are unfeasible.
Depth  43: All paths to l07-c01 are unfeasible.
Depth  44: All paths to l07-c01 are unfeasible.
Depth  45: All paths to l07-c01 are unfeasible.
Depth  46: All paths to l07-c01 are unfeasible.
Depth  47: All paths to l07-c01 are unfeasible.
Depth  48: All paths to l07-c01 are unfeasible.
Depth  49: All paths to l07-c01 are unfeasible.

=============================
prg/classic_for_loop.c with bound 5
=============================
Automaton:
   classic
1 variables:
   x
6 locations:
   l08-c06, l08-c12, l08-c23, l09-c01, l10-c00, ~assert
Initial location:
   l08-c06
Final location:
   ~assert
Transitions:
   l08-c06
      » x := 1 » l08-c12
   l08-c12
      » x <= 100 » l08-c23
      » x > 100 » l09-c01
   l08-c23
      » x := (x + 1) » l08-c12
   l09-c01
      » x < 150 » l10-c00
      » x >= 150 » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state ~assert)
         (>= x 150)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |0|))
    (and (= state l10-c00)
         (< x 150)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |1|))
    (and (= state l09-c01)
         (> x 100)
         (= x x$)
         (= state$ l08-c12)
         (= transition$ |2|))
    (and (= state l08-c23)
         (<= x 100)
         (= x x$)
         (= state$ l08-c12)
         (= transition$ |3|))
    (and (= state l08-c12)
         (= x (+ x$ 1))
         (= state$ l08-c23)
         (= transition$ |4|))
    (and (= state l08-c12) (= x 1) (= state$ l08-c06) (= transition$ |5|)))

Depth   1: All paths to l08-c06 are unfeasible.
Depth   2: All paths to l08-c06 are unfeasible.
Depth   3: All paths to l08-c06 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c06: No

=============================
prg/classic_for_loop.c with bound 25
=============================
Automaton:
   classic
1 variables:
   x
6 locations:
   l08-c06, l08-c12, l08-c23, l09-c01, l10-c00, ~assert
Initial location:
   l08-c06
Final location:
   ~assert
Transitions:
   l08-c06
      » x := 1 » l08-c12
   l08-c12
      » x <= 100 » l08-c23
      » x > 100 » l09-c01
   l08-c23
      » x := (x + 1) » l08-c12
   l09-c01
      » x < 150 » l10-c00
      » x >= 150 » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state ~assert)
         (>= x 150)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |0|))
    (and (= state l10-c00)
         (< x 150)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |1|))
    (and (= state l09-c01)
         (> x 100)
         (= x x$)
         (= state$ l08-c12)
         (= transition$ |2|))
    (and (= state l08-c23)
         (<= x 100)
         (= x x$)
         (= state$ l08-c12)
         (= transition$ |3|))
    (and (= state l08-c12)
         (= x (+ x$ 1))
         (= state$ l08-c23)
         (= transition$ |4|))
    (and (= state l08-c12) (= x 1) (= state$ l08-c06) (= transition$ |5|)))

Depth   1: All paths to l08-c06 are unfeasible.
Depth   2: All paths to l08-c06 are unfeasible.
Depth   3: All paths to l08-c06 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c06: No

=============================
prg/classic_for_loop.c with bound 100
=============================
Automaton:
   classic
1 variables:
   x
6 locations:
   l08-c06, l08-c12, l08-c23, l09-c01, l10-c00, ~assert
Initial location:
   l08-c06
Final location:
   ~assert
Transitions:
   l08-c06
      » x := 1 » l08-c12
   l08-c12
      » x <= 100 » l08-c23
      » x > 100 » l09-c01
   l08-c23
      » x := (x + 1) » l08-c12
   l09-c01
      » x < 150 » l10-c00
      » x >= 150 » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state ~assert)
         (>= x 150)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |0|))
    (and (= state l10-c00)
         (< x 150)
         (= x x$)
         (= state$ l09-c01)
         (= transition$ |1|))
    (and (= state l09-c01)
         (> x 100)
         (= x x$)
         (= state$ l08-c12)
         (= transition$ |2|))
    (and (= state l08-c23)
         (<= x 100)
         (= x x$)
         (= state$ l08-c12)
         (= transition$ |3|))
    (and (= state l08-c12)
         (= x (+ x$ 1))
         (= state$ l08-c23)
         (= transition$ |4|))
    (and (= state l08-c12) (= x 1) (= state$ l08-c06) (= transition$ |5|)))

Depth   1: All paths to l08-c06 are unfeasible.
Depth   2: All paths to l08-c06 are unfeasible.
Depth   3: All paths to l08-c06 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c06: No

=============================
prg/dichotomy.c with bound 5
=============================
Automaton:
   dichotomy
2 variables:
   x, y
8 locations:
   l08-c01, l09-c02, l10-c03, l11-c04, l13-c04, l15-c02, l17-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x < y » l09-c02
      » x >= y » l17-c00
   l09-c02
      » x < y » l10-c03
      » x >= y » l15-c02
   l10-c03
      » skip » l11-c04
      » skip » l13-c04
   l11-c04
      » x := ((x + y) / 2) » l09-c02
   l13-c04
      » y := ((x + y) / 2) » l09-c02
   l15-c02
      » x == y » l17-c00
      » x != y » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and (>= x y) (= x x$) (= y y$)))
      (a!2 (and (< x y) (= x x$) (= y y$)))
      (a!3 (- (div (- (+ x$ y)) 2)))
      (a!5 (- (div (- (+ x y$)) 2))))
(let ((a!4 (= x (ite (>= (+ x$ y) 0) (div (+ x$ y) 2) a!3)))
      (a!6 (= y (ite (>= (+ x y$) 0) (div (+ x y$) 2) a!5))))
  (or (and (= state ~assert)
           (not (= x y))
           (= x x$)
           (= y y$)
           (= state$ l15-c02)
           (= transition$ |0|))
      (and (= state l17-c00)
           (= x y)
           (= x x$)
           (= y y$)
           (= state$ l15-c02)
           (= transition$ |1|))
      (and (= state l17-c00) a!1 (= state$ l08-c01) (= transition$ |2|))
      (and (= state l15-c02) a!1 (= state$ l09-c02) (= transition$ |3|))
      (and (= state l13-c04)
           (and true (= x x$) (= y y$))
           (= state$ l10-c03)
           (= transition$ |4|))
      (and (= state l11-c04)
           (and true (= x x$) (= y y$))
           (= state$ l10-c03)
           (= transition$ |5|))
      (and (= state l10-c03) a!2 (= state$ l09-c02) (= transition$ |6|))
      (and (= state l09-c02)
           (not (= 2 0))
           a!4
           (= y y$)
           (= state$ l11-c04)
           (= transition$ |7|))
      (and (= state l09-c02)
           (not (= 2 0))
           a!6
           (= x x$)
           (= state$ l13-c04)
           (= transition$ |8|))
      (and (= state l09-c02) a!2 (= state$ l08-c01) (= transition$ |9|)))))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: No feasible path of length 5. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c01: No

=============================
prg/dichotomy.c with bound 25
=============================
Automaton:
   dichotomy
2 variables:
   x, y
8 locations:
   l08-c01, l09-c02, l10-c03, l11-c04, l13-c04, l15-c02, l17-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x < y » l09-c02
      » x >= y » l17-c00
   l09-c02
      » x < y » l10-c03
      » x >= y » l15-c02
   l10-c03
      » skip » l11-c04
      » skip » l13-c04
   l11-c04
      » x := ((x + y) / 2) » l09-c02
   l13-c04
      » y := ((x + y) / 2) » l09-c02
   l15-c02
      » x == y » l17-c00
      » x != y » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and (>= x y) (= x x$) (= y y$)))
      (a!2 (and (< x y) (= x x$) (= y y$)))
      (a!3 (- (div (- (+ x$ y)) 2)))
      (a!5 (- (div (- (+ x y$)) 2))))
(let ((a!4 (= x (ite (>= (+ x$ y) 0) (div (+ x$ y) 2) a!3)))
      (a!6 (= y (ite (>= (+ x y$) 0) (div (+ x y$) 2) a!5))))
  (or (and (= state ~assert)
           (not (= x y))
           (= x x$)
           (= y y$)
           (= state$ l15-c02)
           (= transition$ |0|))
      (and (= state l17-c00)
           (= x y)
           (= x x$)
           (= y y$)
           (= state$ l15-c02)
           (= transition$ |1|))
      (and (= state l17-c00) a!1 (= state$ l08-c01) (= transition$ |2|))
      (and (= state l15-c02) a!1 (= state$ l09-c02) (= transition$ |3|))
      (and (= state l13-c04)
           (and true (= x x$) (= y y$))
           (= state$ l10-c03)
           (= transition$ |4|))
      (and (= state l11-c04)
           (and true (= x x$) (= y y$))
           (= state$ l10-c03)
           (= transition$ |5|))
      (and (= state l10-c03) a!2 (= state$ l09-c02) (= transition$ |6|))
      (and (= state l09-c02)
           (not (= 2 0))
           a!4
           (= y y$)
           (= state$ l11-c04)
           (= transition$ |7|))
      (and (= state l09-c02)
           (not (= 2 0))
           a!6
           (= x x$)
           (= state$ l13-c04)
           (= transition$ |8|))
      (and (= state l09-c02) a!2 (= state$ l08-c01) (= transition$ |9|)))))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: No feasible path of length 5. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c01: No

=============================
prg/dichotomy.c with bound 100
=============================
Automaton:
   dichotomy
2 variables:
   x, y
8 locations:
   l08-c01, l09-c02, l10-c03, l11-c04, l13-c04, l15-c02, l17-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x < y » l09-c02
      » x >= y » l17-c00
   l09-c02
      » x < y » l10-c03
      » x >= y » l15-c02
   l10-c03
      » skip » l11-c04
      » skip » l13-c04
   l11-c04
      » x := ((x + y) / 2) » l09-c02
   l13-c04
      » y := ((x + y) / 2) » l09-c02
   l15-c02
      » x == y » l17-c00
      » x != y » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and (>= x y) (= x x$) (= y y$)))
      (a!2 (and (< x y) (= x x$) (= y y$)))
      (a!3 (- (div (- (+ x$ y)) 2)))
      (a!5 (- (div (- (+ x y$)) 2))))
(let ((a!4 (= x (ite (>= (+ x$ y) 0) (div (+ x$ y) 2) a!3)))
      (a!6 (= y (ite (>= (+ x y$) 0) (div (+ x y$) 2) a!5))))
  (or (and (= state ~assert)
           (not (= x y))
           (= x x$)
           (= y y$)
           (= state$ l15-c02)
           (= transition$ |0|))
      (and (= state l17-c00)
           (= x y)
           (= x x$)
           (= y y$)
           (= state$ l15-c02)
           (= transition$ |1|))
      (and (= state l17-c00) a!1 (= state$ l08-c01) (= transition$ |2|))
      (and (= state l15-c02) a!1 (= state$ l09-c02) (= transition$ |3|))
      (and (= state l13-c04)
           (and true (= x x$) (= y y$))
           (= state$ l10-c03)
           (= transition$ |4|))
      (and (= state l11-c04)
           (and true (= x x$) (= y y$))
           (= state$ l10-c03)
           (= transition$ |5|))
      (and (= state l10-c03) a!2 (= state$ l09-c02) (= transition$ |6|))
      (and (= state l09-c02)
           (not (= 2 0))
           a!4
           (= y y$)
           (= state$ l11-c04)
           (= transition$ |7|))
      (and (= state l09-c02)
           (not (= 2 0))
           a!6
           (= x x$)
           (= state$ l13-c04)
           (= transition$ |8|))
      (and (= state l09-c02) a!2 (= state$ l08-c01) (= transition$ |9|)))))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: No feasible path of length 5. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c01: No

=============================
prg/division.c with bound 5
=============================
Automaton:
   division
2 variables:
   x, y
8 locations:
   l05-c04, l06-c04, l07-c04, l08-c08, l09-c08, l10-c08, l12-c00, ~assert
Initial location:
   l05-c04
Final location:
   ~assert
Transitions:
   l05-c04
      » x := 30 » l06-c04
   l06-c04
      » y := 10 » l07-c04
   l07-c04
      » x > 1 » l08-c08
      » x <= 1 » l12-c00
   l08-c08
      » x := (x / y) » l09-c08
   l09-c08
      » y := (y + 1) » l10-c08
   l10-c08
      » x < y » l07-c04
      » x >= y » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (ite (>= x$ 0) (div x$ y) (- (div (- x$) y)))))
  (or (and (= state ~assert)
           (>= x y)
           (= x x$)
           (= y y$)
           (= state$ l10-c08)
           (= transition$ |0|))
      (and (= state l12-c00)
           (<= x 1)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |1|))
      (and (= state l10-c08)
           (= y (+ y$ 1))
           (= x x$)
           (= state$ l09-c08)
           (= transition$ |2|))
      (and (= state l09-c08)
           (not (= y 0))
           (= x a!1)
           (= y y$)
           (= state$ l08-c08)
           (= transition$ |3|))
      (and (= state l08-c08)
           (> x 1)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |4|))
      (and (= state l07-c04)
           (< x y)
           (= x x$)
           (= y y$)
           (= state$ l10-c08)
           (= transition$ |5|))
      (and (= state l07-c04)
           (= y 10)
           (= x x$)
           (= state$ l06-c04)
           (= transition$ |6|))
      (and (= state l06-c04)
           (= x 30)
           (= y y$)
           (= state$ l05-c04)
           (= transition$ |7|))))

Depth   1: All paths to l05-c04 are unfeasible.
Depth   2: All paths to l05-c04 are unfeasible.
Depth   3: All paths to l05-c04 are unfeasible.
Depth   4: All paths to l05-c04 are unfeasible.
Depth   5: All paths to l05-c04 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l05-c04: Unknown

=============================
prg/division.c with bound 25
=============================
Automaton:
   division
2 variables:
   x, y
8 locations:
   l05-c04, l06-c04, l07-c04, l08-c08, l09-c08, l10-c08, l12-c00, ~assert
Initial location:
   l05-c04
Final location:
   ~assert
Transitions:
   l05-c04
      » x := 30 » l06-c04
   l06-c04
      » y := 10 » l07-c04
   l07-c04
      » x > 1 » l08-c08
      » x <= 1 » l12-c00
   l08-c08
      » x := (x / y) » l09-c08
   l09-c08
      » y := (y + 1) » l10-c08
   l10-c08
      » x < y » l07-c04
      » x >= y » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (ite (>= x$ 0) (div x$ y) (- (div (- x$) y)))))
  (or (and (= state ~assert)
           (>= x y)
           (= x x$)
           (= y y$)
           (= state$ l10-c08)
           (= transition$ |0|))
      (and (= state l12-c00)
           (<= x 1)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |1|))
      (and (= state l10-c08)
           (= y (+ y$ 1))
           (= x x$)
           (= state$ l09-c08)
           (= transition$ |2|))
      (and (= state l09-c08)
           (not (= y 0))
           (= x a!1)
           (= y y$)
           (= state$ l08-c08)
           (= transition$ |3|))
      (and (= state l08-c08)
           (> x 1)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |4|))
      (and (= state l07-c04)
           (< x y)
           (= x x$)
           (= y y$)
           (= state$ l10-c08)
           (= transition$ |5|))
      (and (= state l07-c04)
           (= y 10)
           (= x x$)
           (= state$ l06-c04)
           (= transition$ |6|))
      (and (= state l06-c04)
           (= x 30)
           (= y y$)
           (= state$ l05-c04)
           (= transition$ |7|))))

Depth   1: All paths to l05-c04 are unfeasible.
Depth   2: All paths to l05-c04 are unfeasible.
Depth   3: All paths to l05-c04 are unfeasible.
Depth   4: All paths to l05-c04 are unfeasible.
Depth   5: All paths to l05-c04 are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l05-c04: No

=============================
prg/division.c with bound 100
=============================
Automaton:
   division
2 variables:
   x, y
8 locations:
   l05-c04, l06-c04, l07-c04, l08-c08, l09-c08, l10-c08, l12-c00, ~assert
Initial location:
   l05-c04
Final location:
   ~assert
Transitions:
   l05-c04
      » x := 30 » l06-c04
   l06-c04
      » y := 10 » l07-c04
   l07-c04
      » x > 1 » l08-c08
      » x <= 1 » l12-c00
   l08-c08
      » x := (x / y) » l09-c08
   l09-c08
      » y := (y + 1) » l10-c08
   l10-c08
      » x < y » l07-c04
      » x >= y » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (ite (>= x$ 0) (div x$ y) (- (div (- x$) y)))))
  (or (and (= state ~assert)
           (>= x y)
           (= x x$)
           (= y y$)
           (= state$ l10-c08)
           (= transition$ |0|))
      (and (= state l12-c00)
           (<= x 1)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |1|))
      (and (= state l10-c08)
           (= y (+ y$ 1))
           (= x x$)
           (= state$ l09-c08)
           (= transition$ |2|))
      (and (= state l09-c08)
           (not (= y 0))
           (= x a!1)
           (= y y$)
           (= state$ l08-c08)
           (= transition$ |3|))
      (and (= state l08-c08)
           (> x 1)
           (= x x$)
           (= y y$)
           (= state$ l07-c04)
           (= transition$ |4|))
      (and (= state l07-c04)
           (< x y)
           (= x x$)
           (= y y$)
           (= state$ l10-c08)
           (= transition$ |5|))
      (and (= state l07-c04)
           (= y 10)
           (= x x$)
           (= state$ l06-c04)
           (= transition$ |6|))
      (and (= state l06-c04)
           (= x 30)
           (= y y$)
           (= state$ l05-c04)
           (= transition$ |7|))))

Depth   1: All paths to l05-c04 are unfeasible.
Depth   2: All paths to l05-c04 are unfeasible.
Depth   3: All paths to l05-c04 are unfeasible.
Depth   4: All paths to l05-c04 are unfeasible.
Depth   5: All paths to l05-c04 are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l05-c04: No

=============================
prg/locking.c with bound 5
=============================
Automaton:
   locking
3 variables:
   L, old, new
11 locations:
   l09-c01, l10-c01, l13-c02, l14-c02, l15-c02, l16-c02, l19-c03, l20-c03,
   l21-c03, l24-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new != old » l13-c02
      » new == old » l24-c00
   l13-c02
      » L == 0 » l14-c02
      » L != 0 » ~assert
   l14-c02
      » L := 1 » l15-c02
   l15-c02
      » old := new » l16-c02
   l16-c02
      » skip » l19-c03
      » skip » l10-c01
   l19-c03
      » L == 1 » l20-c03
      » L != 1 » ~assert
   l20-c03
      » L := 0 » l21-c03
   l21-c03
      » new := (new + 1) » l10-c01

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and (and (= L 0)) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state ~assert)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l19-c03)
           (= transition$ |0|))
      (and (= state ~assert)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |1|))
      (and (= state l24-c00)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l10-c01)
           (= transition$ |2|))
      (and (= state l21-c03) a!1 (= state$ l20-c03) (= transition$ |3|))
      (and (= state l20-c03)
           (and (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l19-c03)
           (= transition$ |4|))
      (and (= state l19-c03) a!2 (= state$ l16-c02) (= transition$ |5|))
      (and (= state l16-c02)
           (= old new)
           (= L L$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |6|))
      (and (= state l15-c02)
           (and (= L 1))
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |7|))
      (and (= state l14-c02)
           (and (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |8|))
      (and (= state l13-c02)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l10-c01)
           (= transition$ |9|))
      (and (= state l10-c01)
           (= new (+ new$ 1))
           (= L L$)
           (= old old$)
           (= state$ l21-c03)
           (= transition$ |10|))
      (and (= state l10-c01) a!2 (= state$ l16-c02) (= transition$ |11|))
      (and (= state l10-c01) a!1 (= state$ l09-c01) (= transition$ |12|))))

Depth   1: All paths to l09-c01 are unfeasible.
Depth   2: All paths to l09-c01 are unfeasible.
Depth   3: All paths to l09-c01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l09-c01: No

=============================
prg/locking.c with bound 25
=============================
Automaton:
   locking
3 variables:
   L, old, new
11 locations:
   l09-c01, l10-c01, l13-c02, l14-c02, l15-c02, l16-c02, l19-c03, l20-c03,
   l21-c03, l24-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new != old » l13-c02
      » new == old » l24-c00
   l13-c02
      » L == 0 » l14-c02
      » L != 0 » ~assert
   l14-c02
      » L := 1 » l15-c02
   l15-c02
      » old := new » l16-c02
   l16-c02
      » skip » l19-c03
      » skip » l10-c01
   l19-c03
      » L == 1 » l20-c03
      » L != 1 » ~assert
   l20-c03
      » L := 0 » l21-c03
   l21-c03
      » new := (new + 1) » l10-c01

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and (and (= L 0)) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state ~assert)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l19-c03)
           (= transition$ |0|))
      (and (= state ~assert)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |1|))
      (and (= state l24-c00)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l10-c01)
           (= transition$ |2|))
      (and (= state l21-c03) a!1 (= state$ l20-c03) (= transition$ |3|))
      (and (= state l20-c03)
           (and (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l19-c03)
           (= transition$ |4|))
      (and (= state l19-c03) a!2 (= state$ l16-c02) (= transition$ |5|))
      (and (= state l16-c02)
           (= old new)
           (= L L$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |6|))
      (and (= state l15-c02)
           (and (= L 1))
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |7|))
      (and (= state l14-c02)
           (and (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |8|))
      (and (= state l13-c02)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l10-c01)
           (= transition$ |9|))
      (and (= state l10-c01)
           (= new (+ new$ 1))
           (= L L$)
           (= old old$)
           (= state$ l21-c03)
           (= transition$ |10|))
      (and (= state l10-c01) a!2 (= state$ l16-c02) (= transition$ |11|))
      (and (= state l10-c01) a!1 (= state$ l09-c01) (= transition$ |12|))))

Depth   1: All paths to l09-c01 are unfeasible.
Depth   2: All paths to l09-c01 are unfeasible.
Depth   3: All paths to l09-c01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l09-c01: No

=============================
prg/locking.c with bound 100
=============================
Automaton:
   locking
3 variables:
   L, old, new
11 locations:
   l09-c01, l10-c01, l13-c02, l14-c02, l15-c02, l16-c02, l19-c03, l20-c03,
   l21-c03, l24-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new != old » l13-c02
      » new == old » l24-c00
   l13-c02
      » L == 0 » l14-c02
      » L != 0 » ~assert
   l14-c02
      » L := 1 » l15-c02
   l15-c02
      » old := new » l16-c02
   l16-c02
      » skip » l19-c03
      » skip » l10-c01
   l19-c03
      » L == 1 » l20-c03
      » L != 1 » ~assert
   l20-c03
      » L := 0 » l21-c03
   l21-c03
      » new := (new + 1) » l10-c01

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and (and (= L 0)) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state ~assert)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l19-c03)
           (= transition$ |0|))
      (and (= state ~assert)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |1|))
      (and (= state l24-c00)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l10-c01)
           (= transition$ |2|))
      (and (= state l21-c03) a!1 (= state$ l20-c03) (= transition$ |3|))
      (and (= state l20-c03)
           (and (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l19-c03)
           (= transition$ |4|))
      (and (= state l19-c03) a!2 (= state$ l16-c02) (= transition$ |5|))
      (and (= state l16-c02)
           (= old new)
           (= L L$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |6|))
      (and (= state l15-c02)
           (and (= L 1))
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |7|))
      (and (= state l14-c02)
           (and (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l13-c02)
           (= transition$ |8|))
      (and (= state l13-c02)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l10-c01)
           (= transition$ |9|))
      (and (= state l10-c01)
           (= new (+ new$ 1))
           (= L L$)
           (= old old$)
           (= state$ l21-c03)
           (= transition$ |10|))
      (and (= state l10-c01) a!2 (= state$ l16-c02) (= transition$ |11|))
      (and (= state l10-c01) a!1 (= state$ l09-c01) (= transition$ |12|))))

Depth   1: All paths to l09-c01 are unfeasible.
Depth   2: All paths to l09-c01 are unfeasible.
Depth   3: All paths to l09-c01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l09-c01: No

=============================
prg/locking_variant.c with bound 5
=============================
Automaton:
   locking
3 variables:
   L, old, new
12 locations:
   l09-c01, l10-c01, l11-c01, l14-c02, l15-c02, l16-c02, l17-c02, l20-c03,
   l21-c03, l22-c03, l25-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new := (old + 1) » l11-c01
   l11-c01
      » new != old » l14-c02
      » new == old » l25-c00
   l14-c02
      » L == 0 » l15-c02
      » L != 0 » ~assert
   l15-c02
      » L := 1 » l16-c02
   l16-c02
      » old := new » l17-c02
   l17-c02
      » skip » l20-c03
      » skip » l11-c01
   l20-c03
      » L == 1 » l21-c03
      » L != 1 » ~assert
   l21-c03
      » L := 0 » l22-c03
   l22-c03
      » new := (new + 1) » l11-c01

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and (and (= L 0)) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state ~assert)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |0|))
      (and (= state ~assert)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |1|))
      (and (= state l25-c00)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l11-c01)
           (= transition$ |2|))
      (and (= state l22-c03) a!1 (= state$ l21-c03) (= transition$ |3|))
      (and (= state l21-c03)
           (and (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |4|))
      (and (= state l20-c03) a!2 (= state$ l17-c02) (= transition$ |5|))
      (and (= state l17-c02)
           (= old new)
           (= L L$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02)
           (and (= L 1))
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |7|))
      (and (= state l15-c02)
           (and (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |8|))
      (and (= state l14-c02)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l11-c01)
           (= transition$ |9|))
      (and (= state l11-c01)
           (= new (+ new$ 1))
           (= L L$)
           (= old old$)
           (= state$ l22-c03)
           (= transition$ |10|))
      (and (= state l11-c01) a!2 (= state$ l17-c02) (= transition$ |11|))
      (and (= state l11-c01)
           (= new (+ old 1))
           (= L L$)
           (= old old$)
           (= state$ l10-c01)
           (= transition$ |12|))
      (and (= state l10-c01) a!1 (= state$ l09-c01) (= transition$ |13|))))

Depth   1: All paths to l09-c01 are unfeasible.
Depth   2: All paths to l09-c01 are unfeasible.
Depth   3: All paths to l09-c01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l09-c01: No

=============================
prg/locking_variant.c with bound 25
=============================
Automaton:
   locking
3 variables:
   L, old, new
12 locations:
   l09-c01, l10-c01, l11-c01, l14-c02, l15-c02, l16-c02, l17-c02, l20-c03,
   l21-c03, l22-c03, l25-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new := (old + 1) » l11-c01
   l11-c01
      » new != old » l14-c02
      » new == old » l25-c00
   l14-c02
      » L == 0 » l15-c02
      » L != 0 » ~assert
   l15-c02
      » L := 1 » l16-c02
   l16-c02
      » old := new » l17-c02
   l17-c02
      » skip » l20-c03
      » skip » l11-c01
   l20-c03
      » L == 1 » l21-c03
      » L != 1 » ~assert
   l21-c03
      » L := 0 » l22-c03
   l22-c03
      » new := (new + 1) » l11-c01

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and (and (= L 0)) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state ~assert)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |0|))
      (and (= state ~assert)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |1|))
      (and (= state l25-c00)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l11-c01)
           (= transition$ |2|))
      (and (= state l22-c03) a!1 (= state$ l21-c03) (= transition$ |3|))
      (and (= state l21-c03)
           (and (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |4|))
      (and (= state l20-c03) a!2 (= state$ l17-c02) (= transition$ |5|))
      (and (= state l17-c02)
           (= old new)
           (= L L$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02)
           (and (= L 1))
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |7|))
      (and (= state l15-c02)
           (and (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |8|))
      (and (= state l14-c02)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l11-c01)
           (= transition$ |9|))
      (and (= state l11-c01)
           (= new (+ new$ 1))
           (= L L$)
           (= old old$)
           (= state$ l22-c03)
           (= transition$ |10|))
      (and (= state l11-c01) a!2 (= state$ l17-c02) (= transition$ |11|))
      (and (= state l11-c01)
           (= new (+ old 1))
           (= L L$)
           (= old old$)
           (= state$ l10-c01)
           (= transition$ |12|))
      (and (= state l10-c01) a!1 (= state$ l09-c01) (= transition$ |13|))))

Depth   1: All paths to l09-c01 are unfeasible.
Depth   2: All paths to l09-c01 are unfeasible.
Depth   3: All paths to l09-c01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l09-c01: No

=============================
prg/locking_variant.c with bound 100
=============================
Automaton:
   locking
3 variables:
   L, old, new
12 locations:
   l09-c01, l10-c01, l11-c01, l14-c02, l15-c02, l16-c02, l17-c02, l20-c03,
   l21-c03, l22-c03, l25-c00, ~assert
Initial location:
   l09-c01
Final location:
   ~assert
Transitions:
   l09-c01
      » L := 0 » l10-c01
   l10-c01
      » new := (old + 1) » l11-c01
   l11-c01
      » new != old » l14-c02
      » new == old » l25-c00
   l14-c02
      » L == 0 » l15-c02
      » L != 0 » ~assert
   l15-c02
      » L := 1 » l16-c02
   l16-c02
      » old := new » l17-c02
   l17-c02
      » skip » l20-c03
      » skip » l11-c01
   l20-c03
      » L == 1 » l21-c03
      » L != 1 » ~assert
   l21-c03
      » L := 0 » l22-c03
   l22-c03
      » new := (new + 1) » l11-c01

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and (and (= L 0)) (= old old$) (= new new$)))
      (a!2 (and true (= L L$) (= old old$) (= new new$))))
  (or (and (= state ~assert)
           (not (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |0|))
      (and (= state ~assert)
           (not (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |1|))
      (and (= state l25-c00)
           (= new old)
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l11-c01)
           (= transition$ |2|))
      (and (= state l22-c03) a!1 (= state$ l21-c03) (= transition$ |3|))
      (and (= state l21-c03)
           (and (= L 1))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l20-c03)
           (= transition$ |4|))
      (and (= state l20-c03) a!2 (= state$ l17-c02) (= transition$ |5|))
      (and (= state l17-c02)
           (= old new)
           (= L L$)
           (= new new$)
           (= state$ l16-c02)
           (= transition$ |6|))
      (and (= state l16-c02)
           (and (= L 1))
           (= old old$)
           (= new new$)
           (= state$ l15-c02)
           (= transition$ |7|))
      (and (= state l15-c02)
           (and (= L 0))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l14-c02)
           (= transition$ |8|))
      (and (= state l14-c02)
           (not (= new old))
           (= L L$)
           (= old old$)
           (= new new$)
           (= state$ l11-c01)
           (= transition$ |9|))
      (and (= state l11-c01)
           (= new (+ new$ 1))
           (= L L$)
           (= old old$)
           (= state$ l22-c03)
           (= transition$ |10|))
      (and (= state l11-c01) a!2 (= state$ l17-c02) (= transition$ |11|))
      (and (= state l11-c01)
           (= new (+ old 1))
           (= L L$)
           (= old old$)
           (= state$ l10-c01)
           (= transition$ |12|))
      (and (= state l10-c01) a!1 (= state$ l09-c01) (= transition$ |13|))))

Depth   1: All paths to l09-c01 are unfeasible.
Depth   2: All paths to l09-c01 are unfeasible.
Depth   3: All paths to l09-c01 are unfeasible.
Depth   4: No feasible path of length 4. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l09-c01: No

=============================
prg/long_to_violate.c with bound 5
=============================
Automaton:
   long_to_violate
2 variables:
   x, y
11 locations:
   l07-c01, l08-c01, l10-c02, l11-c03, l13-c03, l14-c02, l15-c03, l16-c02,
   l18-c01, l19-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 20 » l10-c02
      » x >= 20 » l18-c01
   l10-c02
      » y < 0 » l11-c03
      » y >= 0 » l13-c03
   l11-c03
      » y := (y + x) » l14-c02
   l13-c03
      » y := (y - x) » l14-c02
   l14-c02
      » skip » l15-c03
      » skip » l16-c02
   l15-c03
      » y := (y + 200) » l16-c02
   l16-c02
      » x := (x + 1) » l08-c01
   l18-c01
      » y > 0 » l19-c00
      » y <= 0 » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state ~assert)
         (<= y 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |0|))
    (and (= state l19-c00)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |1|))
    (and (= state l18-c01)
         (>= x 20)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |2|))
    (and (= state l16-c02)
         (= y (+ y$ 200))
         (= x x$)
         (= state$ l15-c03)
         (= transition$ |3|))
    (and (= state l16-c02)
         (and true (= x x$) (= y y$))
         (= state$ l14-c02)
         (= transition$ |4|))
    (and (= state l15-c03)
         (and true (= x x$) (= y y$))
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l14-c02)
         (= y (+ y$ x))
         (= x x$)
         (= state$ l11-c03)
         (= transition$ |6|))
    (and (= state l14-c02)
         (= y (- y$ x))
         (= x x$)
         (= state$ l13-c03)
         (= transition$ |7|))
    (and (= state l13-c03)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |8|))
    (and (= state l11-c03)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |9|))
    (and (= state l10-c02)
         (< x 20)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |10|))
    (and (= state l08-c01)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ l16-c02)
         (= transition$ |11|))
    (and (= state l08-c01)
         (= x 0)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |12|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/long_to_violate.c with bound 25
=============================
Automaton:
   long_to_violate
2 variables:
   x, y
11 locations:
   l07-c01, l08-c01, l10-c02, l11-c03, l13-c03, l14-c02, l15-c03, l16-c02,
   l18-c01, l19-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 20 » l10-c02
      » x >= 20 » l18-c01
   l10-c02
      » y < 0 » l11-c03
      » y >= 0 » l13-c03
   l11-c03
      » y := (y + x) » l14-c02
   l13-c03
      » y := (y - x) » l14-c02
   l14-c02
      » skip » l15-c03
      » skip » l16-c02
   l15-c03
      » y := (y + 200) » l16-c02
   l16-c02
      » x := (x + 1) » l08-c01
   l18-c01
      » y > 0 » l19-c00
      » y <= 0 » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state ~assert)
         (<= y 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |0|))
    (and (= state l19-c00)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |1|))
    (and (= state l18-c01)
         (>= x 20)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |2|))
    (and (= state l16-c02)
         (= y (+ y$ 200))
         (= x x$)
         (= state$ l15-c03)
         (= transition$ |3|))
    (and (= state l16-c02)
         (and true (= x x$) (= y y$))
         (= state$ l14-c02)
         (= transition$ |4|))
    (and (= state l15-c03)
         (and true (= x x$) (= y y$))
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l14-c02)
         (= y (+ y$ x))
         (= x x$)
         (= state$ l11-c03)
         (= transition$ |6|))
    (and (= state l14-c02)
         (= y (- y$ x))
         (= x x$)
         (= state$ l13-c03)
         (= transition$ |7|))
    (and (= state l13-c03)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |8|))
    (and (= state l11-c03)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |9|))
    (and (= state l10-c02)
         (< x 20)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |10|))
    (and (= state l08-c01)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ l16-c02)
         (= transition$ |11|))
    (and (= state l08-c01)
         (= x 0)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |12|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/long_to_violate.c with bound 100
=============================
Automaton:
   long_to_violate
2 variables:
   x, y
11 locations:
   l07-c01, l08-c01, l10-c02, l11-c03, l13-c03, l14-c02, l15-c03, l16-c02,
   l18-c01, l19-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 20 » l10-c02
      » x >= 20 » l18-c01
   l10-c02
      » y < 0 » l11-c03
      » y >= 0 » l13-c03
   l11-c03
      » y := (y + x) » l14-c02
   l13-c03
      » y := (y - x) » l14-c02
   l14-c02
      » skip » l15-c03
      » skip » l16-c02
   l15-c03
      » y := (y + 200) » l16-c02
   l16-c02
      » x := (x + 1) » l08-c01
   l18-c01
      » y > 0 » l19-c00
      » y <= 0 » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state ~assert)
         (<= y 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |0|))
    (and (= state l19-c00)
         (> y 0)
         (= x x$)
         (= y y$)
         (= state$ l18-c01)
         (= transition$ |1|))
    (and (= state l18-c01)
         (>= x 20)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |2|))
    (and (= state l16-c02)
         (= y (+ y$ 200))
         (= x x$)
         (= state$ l15-c03)
         (= transition$ |3|))
    (and (= state l16-c02)
         (and true (= x x$) (= y y$))
         (= state$ l14-c02)
         (= transition$ |4|))
    (and (= state l15-c03)
         (and true (= x x$) (= y y$))
         (= state$ l14-c02)
         (= transition$ |5|))
    (and (= state l14-c02)
         (= y (+ y$ x))
         (= x x$)
         (= state$ l11-c03)
         (= transition$ |6|))
    (and (= state l14-c02)
         (= y (- y$ x))
         (= x x$)
         (= state$ l13-c03)
         (= transition$ |7|))
    (and (= state l13-c03)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |8|))
    (and (= state l11-c03)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c02)
         (= transition$ |9|))
    (and (= state l10-c02)
         (< x 20)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |10|))
    (and (= state l08-c01)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ l16-c02)
         (= transition$ |11|))
    (and (= state l08-c01)
         (= x 0)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |12|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: All paths to l07-c01 are unfeasible.
Depth  27: All paths to l07-c01 are unfeasible.
Depth  28: All paths to l07-c01 are unfeasible.
Depth  29: All paths to l07-c01 are unfeasible.
Depth  30: All paths to l07-c01 are unfeasible.
Depth  31: All paths to l07-c01 are unfeasible.
Depth  32: All paths to l07-c01 are unfeasible.
Depth  33: All paths to l07-c01 are unfeasible.
Depth  34: All paths to l07-c01 are unfeasible.
Depth  35: All paths to l07-c01 are unfeasible.
Depth  36: All paths to l07-c01 are unfeasible.
Depth  37: All paths to l07-c01 are unfeasible.
Depth  38: All paths to l07-c01 are unfeasible.
Depth  39: All paths to l07-c01 are unfeasible.
Depth  40: All paths to l07-c01 are unfeasible.
Depth  41: All paths to l07-c01 are unfeasible.
Depth  42: All paths to l07-c01 are unfeasible.
Depth  43: All paths to l07-c01 are unfeasible.
Depth  44: All paths to l07-c01 are unfeasible.
Depth  45: All paths to l07-c01 are unfeasible.
Depth  46: All paths to l07-c01 are unfeasible.
Depth  47: All paths to l07-c01 are unfeasible.
Depth  48: All paths to l07-c01 are unfeasible.
Depth  49: All paths to l07-c01 are unfeasible.
Depth  50: All paths to l07-c01 are unfeasible.
Depth  51: All paths to l07-c01 are unfeasible.
Depth  52: All paths to l07-c01 are unfeasible.
Depth  53: All paths to l07-c01 are unfeasible.
Depth  54: All paths to l07-c01 are unfeasible.
Depth  55: All paths to l07-c01 are unfeasible.
Depth  56: All paths to l07-c01 are unfeasible.
Depth  57: All paths to l07-c01 are unfeasible.
Depth  58: All paths to l07-c01 are unfeasible.
Depth  59: All paths to l07-c01 are unfeasible.

=============================
prg/must_unfold_loop.c with bound 5
=============================
Automaton:
   must_unfold_loop
3 variables:
   x, y, z
11 locations:
   l07-c01, l08-c01, l09-c01, l10-c06, l10-c12, l10-c21, l12-c02, l13-c03,
   l14-c02, l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » z := 20 » l09-c01
   l09-c01
      » y := 0 » l10-c06
   l10-c06
      » x := 0 » l10-c12
   l10-c12
      » x < 20 » l12-c02
      » x >= 20 » l16-c00
   l10-c21
      » x := (x + 1) » l10-c12
   l12-c02
      » skip » l13-c03
      » skip » l14-c02
   l13-c03
      » y := (y + 1) » l14-c02
   l14-c02
      » (x * y) < z » l10-c21
      » (x * y) >= z » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$)))
      (a!2 (and (= x 0) (= y y$) (= z z$))))
  (or (and (= state ~assert)
           (>= (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |0|))
      (and (= state l16-c00)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |1|))
      (and (= state l14-c02)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l13-c03)
           (= transition$ |2|))
      (and (= state l14-c02) a!1 (= state$ l12-c02) (= transition$ |3|))
      (and (= state l13-c03) a!1 (= state$ l12-c02) (= transition$ |4|))
      (and (= state l12-c02)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |5|))
      (and (= state l10-c21)
           (< (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |6|))
      (and (= state l10-c12)
           (= x (+ x$ 1))
           (= y y$)
           (= z z$)
           (= state$ l10-c21)
           (= transition$ |7|))
      (and (= state l10-c12) a!2 (= state$ l10-c06) (= transition$ |8|))
      (and (= state l10-c06)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c01)
           (= transition$ |9|))
      (and (= state l09-c01)
           (= z 20)
           (= x x$)
           (= y y$)
           (= state$ l08-c01)
           (= transition$ |10|))
      (and (= state l08-c01) a!2 (= state$ l07-c01) (= transition$ |11|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/must_unfold_loop.c with bound 25
=============================
Automaton:
   must_unfold_loop
3 variables:
   x, y, z
11 locations:
   l07-c01, l08-c01, l09-c01, l10-c06, l10-c12, l10-c21, l12-c02, l13-c03,
   l14-c02, l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » z := 20 » l09-c01
   l09-c01
      » y := 0 » l10-c06
   l10-c06
      » x := 0 » l10-c12
   l10-c12
      » x < 20 » l12-c02
      » x >= 20 » l16-c00
   l10-c21
      » x := (x + 1) » l10-c12
   l12-c02
      » skip » l13-c03
      » skip » l14-c02
   l13-c03
      » y := (y + 1) » l14-c02
   l14-c02
      » (x * y) < z » l10-c21
      » (x * y) >= z » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$)))
      (a!2 (and (= x 0) (= y y$) (= z z$))))
  (or (and (= state ~assert)
           (>= (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |0|))
      (and (= state l16-c00)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |1|))
      (and (= state l14-c02)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l13-c03)
           (= transition$ |2|))
      (and (= state l14-c02) a!1 (= state$ l12-c02) (= transition$ |3|))
      (and (= state l13-c03) a!1 (= state$ l12-c02) (= transition$ |4|))
      (and (= state l12-c02)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |5|))
      (and (= state l10-c21)
           (< (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |6|))
      (and (= state l10-c12)
           (= x (+ x$ 1))
           (= y y$)
           (= z z$)
           (= state$ l10-c21)
           (= transition$ |7|))
      (and (= state l10-c12) a!2 (= state$ l10-c06) (= transition$ |8|))
      (and (= state l10-c06)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c01)
           (= transition$ |9|))
      (and (= state l09-c01)
           (= z 20)
           (= x x$)
           (= y y$)
           (= state$ l08-c01)
           (= transition$ |10|))
      (and (= state l08-c01) a!2 (= state$ l07-c01) (= transition$ |11|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/must_unfold_loop.c with bound 100
=============================
Automaton:
   must_unfold_loop
3 variables:
   x, y, z
11 locations:
   l07-c01, l08-c01, l09-c01, l10-c06, l10-c12, l10-c21, l12-c02, l13-c03,
   l14-c02, l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » z := 20 » l09-c01
   l09-c01
      » y := 0 » l10-c06
   l10-c06
      » x := 0 » l10-c12
   l10-c12
      » x < 20 » l12-c02
      » x >= 20 » l16-c00
   l10-c21
      » x := (x + 1) » l10-c12
   l12-c02
      » skip » l13-c03
      » skip » l14-c02
   l13-c03
      » y := (y + 1) » l14-c02
   l14-c02
      » (x * y) < z » l10-c21
      » (x * y) >= z » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$)))
      (a!2 (and (= x 0) (= y y$) (= z z$))))
  (or (and (= state ~assert)
           (>= (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |0|))
      (and (= state l16-c00)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |1|))
      (and (= state l14-c02)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l13-c03)
           (= transition$ |2|))
      (and (= state l14-c02) a!1 (= state$ l12-c02) (= transition$ |3|))
      (and (= state l13-c03) a!1 (= state$ l12-c02) (= transition$ |4|))
      (and (= state l12-c02)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l10-c12)
           (= transition$ |5|))
      (and (= state l10-c21)
           (< (* x y) z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l14-c02)
           (= transition$ |6|))
      (and (= state l10-c12)
           (= x (+ x$ 1))
           (= y y$)
           (= z z$)
           (= state$ l10-c21)
           (= transition$ |7|))
      (and (= state l10-c12) a!2 (= state$ l10-c06) (= transition$ |8|))
      (and (= state l10-c06)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c01)
           (= transition$ |9|))
      (and (= state l09-c01)
           (= z 20)
           (= x x$)
           (= y y$)
           (= state$ l08-c01)
           (= transition$ |10|))
      (and (= state l08-c01) a!2 (= state$ l07-c01) (= transition$ |11|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: All paths to l07-c01 are unfeasible.
Depth  27: All paths to l07-c01 are unfeasible.
Depth  28: Feasible path found at depth 28.

Feasible path (of length 28):
   l07-c01
      » x := 0 »
   l08-c01
      » z := 20 »
   l09-c01
      » y := 0 »
   l10-c06
      » x := 0 »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) < z »
   l10-c21
      » x := (x + 1) »
   l10-c12
      » x < 20 »
   l12-c02
      » skip »
   l13-c03
      » y := (y + 1) »
   l14-c02
      » (x * y) >= z »
   ~assert

Final location ~assert reachable from initial location l07-c01: Yes

=============================
prg/no_assert.c with bound 5
=============================
Automaton:
   no_assert
3 variables:
   x, y, z
11 locations:
   l07-c06, l07-c12, l07-c21, l09-c07, l09-c13, l09-c23, l11-c03, l12-c04,
   l14-c04, l17-c00, ~assert
Initial location:
   l07-c06
Final location:
   ~assert
Transitions:
   l07-c06
      » x := 0 » l07-c12
   l07-c12
      » x < 20 » l09-c07
      » x >= 20 » l17-c00
   l07-c21
      » x := (x + 1) » l07-c12
   l09-c07
      » y := 0 » l09-c13
   l09-c13
      » y < (x * x) » l11-c03
      » y >= (x * x) » l07-c21
   l09-c23
      » y := (y + 1) » l09-c13
   l11-c03
      » skip » l12-c04
      » skip » l14-c04
   l12-c04
      » z := (z + 1) » l09-c23
   l14-c04
      » z := (z - 1) » l09-c23

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l17-c00)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |0|))
      (and (= state l14-c04) a!1 (= state$ l11-c03) (= transition$ |1|))
      (and (= state l12-c04) a!1 (= state$ l11-c03) (= transition$ |2|))
      (and (= state l11-c03)
           (< y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |3|))
      (and (= state l09-c23)
           (= z (+ z$ 1))
           (= x x$)
           (= y y$)
           (= state$ l12-c04)
           (= transition$ |4|))
      (and (= state l09-c23)
           (= z (- z$ 1))
           (= x x$)
           (= y y$)
           (= state$ l14-c04)
           (= transition$ |5|))
      (and (= state l09-c13)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l09-c23)
           (= transition$ |6|))
      (and (= state l09-c13)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c07)
           (= transition$ |7|))
      (and (= state l09-c07)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |8|))
      (and (= state l07-c21)
           (>= y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |9|))
      (and (= state l07-c12)
           (= x (+ x$ 1))
           (= y y$)
           (= z z$)
           (= state$ l07-c21)
           (= transition$ |10|))
      (and (= state l07-c12)
           (= x 0)
           (= y y$)
           (= z z$)
           (= state$ l07-c06)
           (= transition$ |11|))))

Depth   1: No feasible path of length 1. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c06: No

=============================
prg/no_assert.c with bound 25
=============================
Automaton:
   no_assert
3 variables:
   x, y, z
11 locations:
   l07-c06, l07-c12, l07-c21, l09-c07, l09-c13, l09-c23, l11-c03, l12-c04,
   l14-c04, l17-c00, ~assert
Initial location:
   l07-c06
Final location:
   ~assert
Transitions:
   l07-c06
      » x := 0 » l07-c12
   l07-c12
      » x < 20 » l09-c07
      » x >= 20 » l17-c00
   l07-c21
      » x := (x + 1) » l07-c12
   l09-c07
      » y := 0 » l09-c13
   l09-c13
      » y < (x * x) » l11-c03
      » y >= (x * x) » l07-c21
   l09-c23
      » y := (y + 1) » l09-c13
   l11-c03
      » skip » l12-c04
      » skip » l14-c04
   l12-c04
      » z := (z + 1) » l09-c23
   l14-c04
      » z := (z - 1) » l09-c23

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l17-c00)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |0|))
      (and (= state l14-c04) a!1 (= state$ l11-c03) (= transition$ |1|))
      (and (= state l12-c04) a!1 (= state$ l11-c03) (= transition$ |2|))
      (and (= state l11-c03)
           (< y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |3|))
      (and (= state l09-c23)
           (= z (+ z$ 1))
           (= x x$)
           (= y y$)
           (= state$ l12-c04)
           (= transition$ |4|))
      (and (= state l09-c23)
           (= z (- z$ 1))
           (= x x$)
           (= y y$)
           (= state$ l14-c04)
           (= transition$ |5|))
      (and (= state l09-c13)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l09-c23)
           (= transition$ |6|))
      (and (= state l09-c13)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c07)
           (= transition$ |7|))
      (and (= state l09-c07)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |8|))
      (and (= state l07-c21)
           (>= y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |9|))
      (and (= state l07-c12)
           (= x (+ x$ 1))
           (= y y$)
           (= z z$)
           (= state$ l07-c21)
           (= transition$ |10|))
      (and (= state l07-c12)
           (= x 0)
           (= y y$)
           (= z z$)
           (= state$ l07-c06)
           (= transition$ |11|))))

Depth   1: No feasible path of length 1. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c06: No

=============================
prg/no_assert.c with bound 100
=============================
Automaton:
   no_assert
3 variables:
   x, y, z
11 locations:
   l07-c06, l07-c12, l07-c21, l09-c07, l09-c13, l09-c23, l11-c03, l12-c04,
   l14-c04, l17-c00, ~assert
Initial location:
   l07-c06
Final location:
   ~assert
Transitions:
   l07-c06
      » x := 0 » l07-c12
   l07-c12
      » x < 20 » l09-c07
      » x >= 20 » l17-c00
   l07-c21
      » x := (x + 1) » l07-c12
   l09-c07
      » y := 0 » l09-c13
   l09-c13
      » y < (x * x) » l11-c03
      » y >= (x * x) » l07-c21
   l09-c23
      » y := (y + 1) » l09-c13
   l11-c03
      » skip » l12-c04
      » skip » l14-c04
   l12-c04
      » z := (z + 1) » l09-c23
   l14-c04
      » z := (z - 1) » l09-c23

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state l17-c00)
           (>= x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |0|))
      (and (= state l14-c04) a!1 (= state$ l11-c03) (= transition$ |1|))
      (and (= state l12-c04) a!1 (= state$ l11-c03) (= transition$ |2|))
      (and (= state l11-c03)
           (< y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |3|))
      (and (= state l09-c23)
           (= z (+ z$ 1))
           (= x x$)
           (= y y$)
           (= state$ l12-c04)
           (= transition$ |4|))
      (and (= state l09-c23)
           (= z (- z$ 1))
           (= x x$)
           (= y y$)
           (= state$ l14-c04)
           (= transition$ |5|))
      (and (= state l09-c13)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l09-c23)
           (= transition$ |6|))
      (and (= state l09-c13)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l09-c07)
           (= transition$ |7|))
      (and (= state l09-c07)
           (< x 20)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l07-c12)
           (= transition$ |8|))
      (and (= state l07-c21)
           (>= y (* x x))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l09-c13)
           (= transition$ |9|))
      (and (= state l07-c12)
           (= x (+ x$ 1))
           (= y y$)
           (= z z$)
           (= state$ l07-c21)
           (= transition$ |10|))
      (and (= state l07-c12)
           (= x 0)
           (= y y$)
           (= z z$)
           (= state$ l07-c06)
           (= transition$ |11|))))

Depth   1: No feasible path of length 1. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c06: No

=============================
prg/not_reachable.c with bound 5
=============================
Automaton:
   not_rechable
3 variables:
   x, y, z
12 locations:
   l08-c01, l09-c01, l11-c07, l11-c13, l11-c21, l13-c08, l13-c14, l13-c23,
   l15-c04, l17-c03, l20-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x := 0 » l09-c01
   l09-c01
      » x < 10 » l11-c07
      » x >= 10 » l20-c00
   l11-c07
      » y := x » l11-c13
   l11-c13
      » y < 0 » l13-c08
      » y >= 0 » l09-c01
   l11-c21
      » y := (y + 1) » l11-c13
   l13-c08
      » z := 0 » l13-c14
   l13-c14
      » z < 10 » l15-c04
      » z >= 10 » l17-c03
   l13-c23
      » z := (z + 1) » l13-c14
   l15-c04
      » x := (x + 1) » l13-c23
   l17-c03
      » 0 == 1 » l11-c21
      » 0 != 1 » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state ~assert)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |0|))
    (and (= state l20-c00)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |1|))
    (and (= state l17-c03)
         (>= z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c14)
         (= transition$ |2|))
    (and (= state l15-c04)
         (< z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c14)
         (= transition$ |3|))
    (and (= state l13-c23)
         (= x (+ x$ 1))
         (= y y$)
         (= z z$)
         (= state$ l15-c04)
         (= transition$ |4|))
    (and (= state l13-c14)
         (= z (+ z$ 1))
         (= x x$)
         (= y y$)
         (= state$ l13-c23)
         (= transition$ |5|))
    (and (= state l13-c14)
         (= z 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c08)
         (= transition$ |6|))
    (and (= state l13-c08)
         (< y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |7|))
    (and (= state l11-c21)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |8|))
    (and (= state l11-c13)
         (= y (+ y$ 1))
         (= x x$)
         (= z z$)
         (= state$ l11-c21)
         (= transition$ |9|))
    (and (= state l11-c13)
         (= y x)
         (= x x$)
         (= z z$)
         (= state$ l11-c07)
         (= transition$ |10|))
    (and (= state l11-c07)
         (< x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |11|))
    (and (= state l09-c01)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |12|))
    (and (= state l09-c01)
         (= x 0)
         (= y y$)
         (= z z$)
         (= state$ l08-c01)
         (= transition$ |13|)))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: All paths to l08-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/not_reachable.c with bound 25
=============================
Automaton:
   not_rechable
3 variables:
   x, y, z
12 locations:
   l08-c01, l09-c01, l11-c07, l11-c13, l11-c21, l13-c08, l13-c14, l13-c23,
   l15-c04, l17-c03, l20-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x := 0 » l09-c01
   l09-c01
      » x < 10 » l11-c07
      » x >= 10 » l20-c00
   l11-c07
      » y := x » l11-c13
   l11-c13
      » y < 0 » l13-c08
      » y >= 0 » l09-c01
   l11-c21
      » y := (y + 1) » l11-c13
   l13-c08
      » z := 0 » l13-c14
   l13-c14
      » z < 10 » l15-c04
      » z >= 10 » l17-c03
   l13-c23
      » z := (z + 1) » l13-c14
   l15-c04
      » x := (x + 1) » l13-c23
   l17-c03
      » 0 == 1 » l11-c21
      » 0 != 1 » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state ~assert)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |0|))
    (and (= state l20-c00)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |1|))
    (and (= state l17-c03)
         (>= z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c14)
         (= transition$ |2|))
    (and (= state l15-c04)
         (< z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c14)
         (= transition$ |3|))
    (and (= state l13-c23)
         (= x (+ x$ 1))
         (= y y$)
         (= z z$)
         (= state$ l15-c04)
         (= transition$ |4|))
    (and (= state l13-c14)
         (= z (+ z$ 1))
         (= x x$)
         (= y y$)
         (= state$ l13-c23)
         (= transition$ |5|))
    (and (= state l13-c14)
         (= z 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c08)
         (= transition$ |6|))
    (and (= state l13-c08)
         (< y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |7|))
    (and (= state l11-c21)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |8|))
    (and (= state l11-c13)
         (= y (+ y$ 1))
         (= x x$)
         (= z z$)
         (= state$ l11-c21)
         (= transition$ |9|))
    (and (= state l11-c13)
         (= y x)
         (= x x$)
         (= z z$)
         (= state$ l11-c07)
         (= transition$ |10|))
    (and (= state l11-c07)
         (< x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |11|))
    (and (= state l09-c01)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |12|))
    (and (= state l09-c01)
         (= x 0)
         (= y y$)
         (= z z$)
         (= state$ l08-c01)
         (= transition$ |13|)))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: All paths to l08-c01 are unfeasible.
Depth   6: All paths to l08-c01 are unfeasible.
Depth   7: All paths to l08-c01 are unfeasible.
Depth   8: All paths to l08-c01 are unfeasible.
Depth   9: All paths to l08-c01 are unfeasible.
Depth  10: All paths to l08-c01 are unfeasible.
Depth  11: All paths to l08-c01 are unfeasible.
Depth  12: All paths to l08-c01 are unfeasible.
Depth  13: All paths to l08-c01 are unfeasible.
Depth  14: All paths to l08-c01 are unfeasible.
Depth  15: All paths to l08-c01 are unfeasible.
Depth  16: All paths to l08-c01 are unfeasible.
Depth  17: All paths to l08-c01 are unfeasible.
Depth  18: All paths to l08-c01 are unfeasible.
Depth  19: All paths to l08-c01 are unfeasible.
Depth  20: All paths to l08-c01 are unfeasible.
Depth  21: All paths to l08-c01 are unfeasible.
Depth  22: All paths to l08-c01 are unfeasible.
Depth  23: All paths to l08-c01 are unfeasible.
Depth  24: All paths to l08-c01 are unfeasible.
Depth  25: All paths to l08-c01 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/not_reachable.c with bound 100
=============================
Automaton:
   not_rechable
3 variables:
   x, y, z
12 locations:
   l08-c01, l09-c01, l11-c07, l11-c13, l11-c21, l13-c08, l13-c14, l13-c23,
   l15-c04, l17-c03, l20-c00, ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » x := 0 » l09-c01
   l09-c01
      » x < 10 » l11-c07
      » x >= 10 » l20-c00
   l11-c07
      » y := x » l11-c13
   l11-c13
      » y < 0 » l13-c08
      » y >= 0 » l09-c01
   l11-c21
      » y := (y + 1) » l11-c13
   l13-c08
      » z := 0 » l13-c14
   l13-c14
      » z < 10 » l15-c04
      » z >= 10 » l17-c03
   l13-c23
      » z := (z + 1) » l13-c14
   l15-c04
      » x := (x + 1) » l13-c23
   l17-c03
      » 0 == 1 » l11-c21
      » 0 != 1 » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state ~assert)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |0|))
    (and (= state l20-c00)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |1|))
    (and (= state l17-c03)
         (>= z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c14)
         (= transition$ |2|))
    (and (= state l15-c04)
         (< z 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l13-c14)
         (= transition$ |3|))
    (and (= state l13-c23)
         (= x (+ x$ 1))
         (= y y$)
         (= z z$)
         (= state$ l15-c04)
         (= transition$ |4|))
    (and (= state l13-c14)
         (= z (+ z$ 1))
         (= x x$)
         (= y y$)
         (= state$ l13-c23)
         (= transition$ |5|))
    (and (= state l13-c14)
         (= z 0)
         (= x x$)
         (= y y$)
         (= state$ l13-c08)
         (= transition$ |6|))
    (and (= state l13-c08)
         (< y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |7|))
    (and (= state l11-c21)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l17-c03)
         (= transition$ |8|))
    (and (= state l11-c13)
         (= y (+ y$ 1))
         (= x x$)
         (= z z$)
         (= state$ l11-c21)
         (= transition$ |9|))
    (and (= state l11-c13)
         (= y x)
         (= x x$)
         (= z z$)
         (= state$ l11-c07)
         (= transition$ |10|))
    (and (= state l11-c07)
         (< x 10)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l09-c01)
         (= transition$ |11|))
    (and (= state l09-c01)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= z z$)
         (= state$ l11-c13)
         (= transition$ |12|))
    (and (= state l09-c01)
         (= x 0)
         (= y y$)
         (= z z$)
         (= state$ l08-c01)
         (= transition$ |13|)))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: All paths to l08-c01 are unfeasible.
Depth   6: All paths to l08-c01 are unfeasible.
Depth   7: All paths to l08-c01 are unfeasible.
Depth   8: All paths to l08-c01 are unfeasible.
Depth   9: All paths to l08-c01 are unfeasible.
Depth  10: All paths to l08-c01 are unfeasible.
Depth  11: All paths to l08-c01 are unfeasible.
Depth  12: All paths to l08-c01 are unfeasible.
Depth  13: All paths to l08-c01 are unfeasible.
Depth  14: All paths to l08-c01 are unfeasible.
Depth  15: All paths to l08-c01 are unfeasible.
Depth  16: All paths to l08-c01 are unfeasible.
Depth  17: All paths to l08-c01 are unfeasible.
Depth  18: All paths to l08-c01 are unfeasible.
Depth  19: All paths to l08-c01 are unfeasible.
Depth  20: All paths to l08-c01 are unfeasible.
Depth  21: All paths to l08-c01 are unfeasible.
Depth  22: All paths to l08-c01 are unfeasible.
Depth  23: All paths to l08-c01 are unfeasible.
Depth  24: All paths to l08-c01 are unfeasible.
Depth  25: All paths to l08-c01 are unfeasible.
Depth  26: All paths to l08-c01 are unfeasible.
Depth  27: All paths to l08-c01 are unfeasible.
Depth  28: All paths to l08-c01 are unfeasible.
Depth  29: All paths to l08-c01 are unfeasible.
Depth  30: All paths to l08-c01 are unfeasible.
Depth  31: All paths to l08-c01 are unfeasible.
Depth  32: All paths to l08-c01 are unfeasible.
Depth  33: All paths to l08-c01 are unfeasible.
Depth  34: All paths to l08-c01 are unfeasible.
Depth  35: All paths to l08-c01 are unfeasible.
Depth  36: All paths to l08-c01 are unfeasible.
Depth  37: All paths to l08-c01 are unfeasible.
Depth  38: All paths to l08-c01 are unfeasible.
Depth  39: All paths to l08-c01 are unfeasible.
Depth  40: All paths to l08-c01 are unfeasible.
Depth  41: All paths to l08-c01 are unfeasible.
Depth  42: All paths to l08-c01 are unfeasible.
Depth  43: All paths to l08-c01 are unfeasible.
Depth  44: All paths to l08-c01 are unfeasible.
Depth  45: All paths to l08-c01 are unfeasible.
Depth  46: All paths to l08-c01 are unfeasible.
Depth  47: All paths to l08-c01 are unfeasible.
Depth  48: All paths to l08-c01 are unfeasible.
Depth  49: All paths to l08-c01 are unfeasible.
Depth  50: All paths to l08-c01 are unfeasible.
Depth  51: All paths to l08-c01 are unfeasible.
Depth  52: All paths to l08-c01 are unfeasible.
Depth  53: All paths to l08-c01 are unfeasible.
Depth  54: All paths to l08-c01 are unfeasible.
Depth  55: All paths to l08-c01 are unfeasible.
Depth  56: All paths to l08-c01 are unfeasible.
Depth  57: All paths to l08-c01 are unfeasible.
Depth  58: All paths to l08-c01 are unfeasible.
Depth  59: All paths to l08-c01 are unfeasible.
Depth  60: All paths to l08-c01 are unfeasible.
Depth  61: All paths to l08-c01 are unfeasible.
Depth  62: All paths to l08-c01 are unfeasible.
Depth  63: All paths to l08-c01 are unfeasible.
Depth  64: All paths to l08-c01 are unfeasible.
Depth  65: All paths to l08-c01 are unfeasible.
Depth  66: All paths to l08-c01 are unfeasible.
Depth  67: All paths to l08-c01 are unfeasible.
Depth  68: All paths to l08-c01 are unfeasible.
Depth  69: All paths to l08-c01 are unfeasible.
Depth  70: All paths to l08-c01 are unfeasible.
Depth  71: All paths to l08-c01 are unfeasible.
Depth  72: All paths to l08-c01 are unfeasible.
Depth  73: All paths to l08-c01 are unfeasible.
Depth  74: All paths to l08-c01 are unfeasible.
Depth  75: All paths to l08-c01 are unfeasible.
Depth  76: All paths to l08-c01 are unfeasible.
Depth  77: All paths to l08-c01 are unfeasible.
Depth  78: All paths to l08-c01 are unfeasible.
Depth  79: All paths to l08-c01 are unfeasible.
Depth  80: All paths to l08-c01 are unfeasible.
Depth  81: All paths to l08-c01 are unfeasible.
Depth  82: All paths to l08-c01 are unfeasible.
Depth  83: All paths to l08-c01 are unfeasible.
Depth  84: All paths to l08-c01 are unfeasible.
Depth  85: All paths to l08-c01 are unfeasible.
Depth  86: All paths to l08-c01 are unfeasible.
Depth  87: All paths to l08-c01 are unfeasible.
Depth  88: All paths to l08-c01 are unfeasible.
Depth  89: All paths to l08-c01 are unfeasible.
Depth  90: All paths to l08-c01 are unfeasible.
Depth  91: All paths to l08-c01 are unfeasible.
Depth  92: All paths to l08-c01 are unfeasible.
Depth  93: All paths to l08-c01 are unfeasible.
Depth  94: All paths to l08-c01 are unfeasible.
Depth  95: All paths to l08-c01 are unfeasible.
Depth  96: All paths to l08-c01 are unfeasible.
Depth  97: All paths to l08-c01 are unfeasible.
Depth  98: All paths to l08-c01 are unfeasible.
Depth  99: All paths to l08-c01 are unfeasible.
Depth 100: All paths to l08-c01 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/not_reachable_tractable.c with bound 5
=============================
Automaton:
   not_rechable
2 variables:
   x, y
9 locations:
   l07-c01, l08-c01, l10-c07, l10-c13, l10-c21, l12-c03, l14-c02, l16-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 10 » l10-c07
      » x >= 10 » l16-c00
   l10-c07
      » y := x » l10-c13
   l10-c13
      » y < 0 » l12-c03
      » y >= 0 » l14-c02
   l10-c21
      » y := (y + 1) » l10-c13
   l12-c03
      » 0 == 1 » l10-c21
      » 0 != 1 » ~assert
   l14-c02
      » x := (x + 1) » l08-c01

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state ~assert)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |0|))
    (and (= state l16-c00)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |1|))
    (and (= state l14-c02)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c13)
         (= transition$ |2|))
    (and (= state l12-c03)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c13)
         (= transition$ |3|))
    (and (= state l10-c21)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |4|))
    (and (= state l10-c13)
         (= y (+ y$ 1))
         (= x x$)
         (= state$ l10-c21)
         (= transition$ |5|))
    (and (= state l10-c13)
         (= y x)
         (= x x$)
         (= state$ l10-c07)
         (= transition$ |6|))
    (and (= state l10-c07)
         (< x 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |7|))
    (and (= state l08-c01)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ l14-c02)
         (= transition$ |8|))
    (and (= state l08-c01)
         (= x 0)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |9|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/not_reachable_tractable.c with bound 25
=============================
Automaton:
   not_rechable
2 variables:
   x, y
9 locations:
   l07-c01, l08-c01, l10-c07, l10-c13, l10-c21, l12-c03, l14-c02, l16-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 10 » l10-c07
      » x >= 10 » l16-c00
   l10-c07
      » y := x » l10-c13
   l10-c13
      » y < 0 » l12-c03
      » y >= 0 » l14-c02
   l10-c21
      » y := (y + 1) » l10-c13
   l12-c03
      » 0 == 1 » l10-c21
      » 0 != 1 » ~assert
   l14-c02
      » x := (x + 1) » l08-c01

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state ~assert)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |0|))
    (and (= state l16-c00)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |1|))
    (and (= state l14-c02)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c13)
         (= transition$ |2|))
    (and (= state l12-c03)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c13)
         (= transition$ |3|))
    (and (= state l10-c21)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |4|))
    (and (= state l10-c13)
         (= y (+ y$ 1))
         (= x x$)
         (= state$ l10-c21)
         (= transition$ |5|))
    (and (= state l10-c13)
         (= y x)
         (= x x$)
         (= state$ l10-c07)
         (= transition$ |6|))
    (and (= state l10-c07)
         (< x 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |7|))
    (and (= state l08-c01)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ l14-c02)
         (= transition$ |8|))
    (and (= state l08-c01)
         (= x 0)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |9|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: No feasible path of length 8. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c01: No

=============================
prg/not_reachable_tractable.c with bound 100
=============================
Automaton:
   not_rechable
2 variables:
   x, y
9 locations:
   l07-c01, l08-c01, l10-c07, l10-c13, l10-c21, l12-c03, l14-c02, l16-c00,
   ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 0 » l08-c01
   l08-c01
      » x < 10 » l10-c07
      » x >= 10 » l16-c00
   l10-c07
      » y := x » l10-c13
   l10-c13
      » y < 0 » l12-c03
      » y >= 0 » l14-c02
   l10-c21
      » y := (y + 1) » l10-c13
   l12-c03
      » 0 == 1 » l10-c21
      » 0 != 1 » ~assert
   l14-c02
      » x := (x + 1) » l08-c01

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state ~assert)
         (not (= 0 1))
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |0|))
    (and (= state l16-c00)
         (>= x 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |1|))
    (and (= state l14-c02)
         (>= y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c13)
         (= transition$ |2|))
    (and (= state l12-c03)
         (< y 0)
         (= x x$)
         (= y y$)
         (= state$ l10-c13)
         (= transition$ |3|))
    (and (= state l10-c21)
         (= 0 1)
         (= x x$)
         (= y y$)
         (= state$ l12-c03)
         (= transition$ |4|))
    (and (= state l10-c13)
         (= y (+ y$ 1))
         (= x x$)
         (= state$ l10-c21)
         (= transition$ |5|))
    (and (= state l10-c13)
         (= y x)
         (= x x$)
         (= state$ l10-c07)
         (= transition$ |6|))
    (and (= state l10-c07)
         (< x 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |7|))
    (and (= state l08-c01)
         (= x (+ x$ 1))
         (= y y$)
         (= state$ l14-c02)
         (= transition$ |8|))
    (and (= state l08-c01)
         (= x 0)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |9|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: No feasible path of length 8. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c01: No

=============================
prg/pigeon.c with bound 5
=============================
Automaton:
   pigeon
5 variables:
   pigeon, n1, n2, n3, n4
17 locations:
   l08-c01, l09-c01, l10-c01, l11-c01, l12-c01, l14-c01, l15-c02, l16-c02,
   l17-c03, l19-c03, l20-c04, l22-c04, l23-c05, l25-c05, l26-c02, l28-c00,
   ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » pigeon := 0 » l09-c01
   l09-c01
      » n1 := 0 » l10-c01
   l10-c01
      » n2 := 0 » l11-c01
   l11-c01
      » n3 := 0 » l12-c01
   l12-c01
      » n4 := 0 » l14-c01
   l14-c01
      » 1 != 0 » l15-c02
      » 1 == 0 » l28-c00
   l15-c02
      » pigeon := (pigeon + 1) » l16-c02
   l16-c02
      » skip » l17-c03
      » skip » l19-c03
   l17-c03
      » n1 := (n1 + 1) » l26-c02
   l19-c03
      » skip » l20-c04
      » skip » l22-c04
   l20-c04
      » n2 := (n2 + 1) » l26-c02
   l22-c04
      » skip » l23-c05
      » skip » l25-c05
   l23-c05
      » n3 := (n3 + 1) » l26-c02
   l25-c05
      » n4 := (n4 + 1) » l26-c02
   l26-c02
      » pigeon == (((n1 + n2) + n3) + n4) » l14-c01
      » pigeon != (((n1 + n2) + n3) + n4) » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and (= state ~assert)
                (not (= pigeon (+ n1 n2 n3 n4)))
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)
                (= state$ l26-c02)
                (= transition$ |0|)))
      (a!2 (and true
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$))))
  (or a!1
      (and (= state l28-c00)
           (= 1 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |1|))
      (and (= state l26-c02)
           (= n1 (+ n1$ 1))
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l17-c03)
           (= transition$ |2|))
      (and (= state l26-c02)
           (= n2 (+ n2$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l20-c04)
           (= transition$ |3|))
      (and (= state l26-c02)
           (= n3 (+ n3$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l23-c05)
           (= transition$ |4|))
      (and (= state l26-c02)
           (= n4 (+ n4$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l25-c05)
           (= transition$ |5|))
      (and (= state l25-c05) a!2 (= state$ l22-c04) (= transition$ |6|))
      (and (= state l23-c05) a!2 (= state$ l22-c04) (= transition$ |7|))
      (and (= state l22-c04) a!2 (= state$ l19-c03) (= transition$ |8|))
      (and (= state l20-c04) a!2 (= state$ l19-c03) (= transition$ |9|))
      (and (= state l19-c03) a!2 (= state$ l16-c02) (= transition$ |10|))
      (and (= state l17-c03) a!2 (= state$ l16-c02) (= transition$ |11|))
      (and (= state l16-c02)
           (= pigeon (+ pigeon$ 1))
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l15-c02)
           (= transition$ |12|))
      (and (= state l15-c02)
           (not (= 1 0))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |13|))
      (and (= state l14-c01)
           (= pigeon (+ n1 n2 n3 n4))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |14|))
      (and (= state l14-c01)
           (= n4 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l12-c01)
           (= transition$ |15|))
      (and (= state l12-c01)
           (= n3 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l11-c01)
           (= transition$ |16|))
      (and (= state l11-c01)
           (= n2 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l10-c01)
           (= transition$ |17|))
      (and (= state l10-c01)
           (= n1 0)
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l09-c01)
           (= transition$ |18|))
      (and (= state l09-c01)
           (= pigeon 0)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l08-c01)
           (= transition$ |19|))))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: All paths to l08-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l08-c01: Unknown

=============================
prg/pigeon.c with bound 25
=============================
Automaton:
   pigeon
5 variables:
   pigeon, n1, n2, n3, n4
17 locations:
   l08-c01, l09-c01, l10-c01, l11-c01, l12-c01, l14-c01, l15-c02, l16-c02,
   l17-c03, l19-c03, l20-c04, l22-c04, l23-c05, l25-c05, l26-c02, l28-c00,
   ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » pigeon := 0 » l09-c01
   l09-c01
      » n1 := 0 » l10-c01
   l10-c01
      » n2 := 0 » l11-c01
   l11-c01
      » n3 := 0 » l12-c01
   l12-c01
      » n4 := 0 » l14-c01
   l14-c01
      » 1 != 0 » l15-c02
      » 1 == 0 » l28-c00
   l15-c02
      » pigeon := (pigeon + 1) » l16-c02
   l16-c02
      » skip » l17-c03
      » skip » l19-c03
   l17-c03
      » n1 := (n1 + 1) » l26-c02
   l19-c03
      » skip » l20-c04
      » skip » l22-c04
   l20-c04
      » n2 := (n2 + 1) » l26-c02
   l22-c04
      » skip » l23-c05
      » skip » l25-c05
   l23-c05
      » n3 := (n3 + 1) » l26-c02
   l25-c05
      » n4 := (n4 + 1) » l26-c02
   l26-c02
      » pigeon == (((n1 + n2) + n3) + n4) » l14-c01
      » pigeon != (((n1 + n2) + n3) + n4) » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and (= state ~assert)
                (not (= pigeon (+ n1 n2 n3 n4)))
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)
                (= state$ l26-c02)
                (= transition$ |0|)))
      (a!2 (and true
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$))))
  (or a!1
      (and (= state l28-c00)
           (= 1 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |1|))
      (and (= state l26-c02)
           (= n1 (+ n1$ 1))
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l17-c03)
           (= transition$ |2|))
      (and (= state l26-c02)
           (= n2 (+ n2$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l20-c04)
           (= transition$ |3|))
      (and (= state l26-c02)
           (= n3 (+ n3$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l23-c05)
           (= transition$ |4|))
      (and (= state l26-c02)
           (= n4 (+ n4$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l25-c05)
           (= transition$ |5|))
      (and (= state l25-c05) a!2 (= state$ l22-c04) (= transition$ |6|))
      (and (= state l23-c05) a!2 (= state$ l22-c04) (= transition$ |7|))
      (and (= state l22-c04) a!2 (= state$ l19-c03) (= transition$ |8|))
      (and (= state l20-c04) a!2 (= state$ l19-c03) (= transition$ |9|))
      (and (= state l19-c03) a!2 (= state$ l16-c02) (= transition$ |10|))
      (and (= state l17-c03) a!2 (= state$ l16-c02) (= transition$ |11|))
      (and (= state l16-c02)
           (= pigeon (+ pigeon$ 1))
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l15-c02)
           (= transition$ |12|))
      (and (= state l15-c02)
           (not (= 1 0))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |13|))
      (and (= state l14-c01)
           (= pigeon (+ n1 n2 n3 n4))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |14|))
      (and (= state l14-c01)
           (= n4 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l12-c01)
           (= transition$ |15|))
      (and (= state l12-c01)
           (= n3 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l11-c01)
           (= transition$ |16|))
      (and (= state l11-c01)
           (= n2 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l10-c01)
           (= transition$ |17|))
      (and (= state l10-c01)
           (= n1 0)
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l09-c01)
           (= transition$ |18|))
      (and (= state l09-c01)
           (= pigeon 0)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l08-c01)
           (= transition$ |19|))))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: All paths to l08-c01 are unfeasible.
Depth   6: All paths to l08-c01 are unfeasible.
Depth   7: All paths to l08-c01 are unfeasible.
Depth   8: All paths to l08-c01 are unfeasible.
Depth   9: All paths to l08-c01 are unfeasible.
Depth  10: All paths to l08-c01 are unfeasible.
Depth  11: All paths to l08-c01 are unfeasible.
Depth  12: No feasible path of length 12. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c01: No

=============================
prg/pigeon.c with bound 100
=============================
Automaton:
   pigeon
5 variables:
   pigeon, n1, n2, n3, n4
17 locations:
   l08-c01, l09-c01, l10-c01, l11-c01, l12-c01, l14-c01, l15-c02, l16-c02,
   l17-c03, l19-c03, l20-c04, l22-c04, l23-c05, l25-c05, l26-c02, l28-c00,
   ~assert
Initial location:
   l08-c01
Final location:
   ~assert
Transitions:
   l08-c01
      » pigeon := 0 » l09-c01
   l09-c01
      » n1 := 0 » l10-c01
   l10-c01
      » n2 := 0 » l11-c01
   l11-c01
      » n3 := 0 » l12-c01
   l12-c01
      » n4 := 0 » l14-c01
   l14-c01
      » 1 != 0 » l15-c02
      » 1 == 0 » l28-c00
   l15-c02
      » pigeon := (pigeon + 1) » l16-c02
   l16-c02
      » skip » l17-c03
      » skip » l19-c03
   l17-c03
      » n1 := (n1 + 1) » l26-c02
   l19-c03
      » skip » l20-c04
      » skip » l22-c04
   l20-c04
      » n2 := (n2 + 1) » l26-c02
   l22-c04
      » skip » l23-c05
      » skip » l25-c05
   l23-c05
      » n3 := (n3 + 1) » l26-c02
   l25-c05
      » n4 := (n4 + 1) » l26-c02
   l26-c02
      » pigeon == (((n1 + n2) + n3) + n4) » l14-c01
      » pigeon != (((n1 + n2) + n3) + n4) » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and (= state ~assert)
                (not (= pigeon (+ n1 n2 n3 n4)))
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$)
                (= state$ l26-c02)
                (= transition$ |0|)))
      (a!2 (and true
                (= pigeon pigeon$)
                (= n1 n1$)
                (= n2 n2$)
                (= n3 n3$)
                (= n4 n4$))))
  (or a!1
      (and (= state l28-c00)
           (= 1 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |1|))
      (and (= state l26-c02)
           (= n1 (+ n1$ 1))
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l17-c03)
           (= transition$ |2|))
      (and (= state l26-c02)
           (= n2 (+ n2$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l20-c04)
           (= transition$ |3|))
      (and (= state l26-c02)
           (= n3 (+ n3$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l23-c05)
           (= transition$ |4|))
      (and (= state l26-c02)
           (= n4 (+ n4$ 1))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l25-c05)
           (= transition$ |5|))
      (and (= state l25-c05) a!2 (= state$ l22-c04) (= transition$ |6|))
      (and (= state l23-c05) a!2 (= state$ l22-c04) (= transition$ |7|))
      (and (= state l22-c04) a!2 (= state$ l19-c03) (= transition$ |8|))
      (and (= state l20-c04) a!2 (= state$ l19-c03) (= transition$ |9|))
      (and (= state l19-c03) a!2 (= state$ l16-c02) (= transition$ |10|))
      (and (= state l17-c03) a!2 (= state$ l16-c02) (= transition$ |11|))
      (and (= state l16-c02)
           (= pigeon (+ pigeon$ 1))
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l15-c02)
           (= transition$ |12|))
      (and (= state l15-c02)
           (not (= 1 0))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l14-c01)
           (= transition$ |13|))
      (and (= state l14-c01)
           (= pigeon (+ n1 n2 n3 n4))
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l26-c02)
           (= transition$ |14|))
      (and (= state l14-c01)
           (= n4 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= state$ l12-c01)
           (= transition$ |15|))
      (and (= state l12-c01)
           (= n3 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n2 n2$)
           (= n4 n4$)
           (= state$ l11-c01)
           (= transition$ |16|))
      (and (= state l11-c01)
           (= n2 0)
           (= pigeon pigeon$)
           (= n1 n1$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l10-c01)
           (= transition$ |17|))
      (and (= state l10-c01)
           (= n1 0)
           (= pigeon pigeon$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l09-c01)
           (= transition$ |18|))
      (and (= state l09-c01)
           (= pigeon 0)
           (= n1 n1$)
           (= n2 n2$)
           (= n3 n3$)
           (= n4 n4$)
           (= state$ l08-c01)
           (= transition$ |19|))))

Depth   1: All paths to l08-c01 are unfeasible.
Depth   2: All paths to l08-c01 are unfeasible.
Depth   3: All paths to l08-c01 are unfeasible.
Depth   4: All paths to l08-c01 are unfeasible.
Depth   5: All paths to l08-c01 are unfeasible.
Depth   6: All paths to l08-c01 are unfeasible.
Depth   7: All paths to l08-c01 are unfeasible.
Depth   8: All paths to l08-c01 are unfeasible.
Depth   9: All paths to l08-c01 are unfeasible.
Depth  10: All paths to l08-c01 are unfeasible.
Depth  11: All paths to l08-c01 are unfeasible.
Depth  12: No feasible path of length 12. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l08-c01: No

=============================
prg/relational.c with bound 5
=============================
Automaton:
   relational
3 variables:
   x, y, z
10 locations:
   l07-c01, l08-c06, l08-c13, l08-c22, l10-c02, l11-c03, l13-c03, l15-c01,
   l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c06
   l08-c06
      » y := 0 » l08-c13
   l08-c13
      » y < z » l10-c02
      » y >= z » l15-c01
   l08-c22
      » y := (y + 1) » l08-c13
   l10-c02
      » skip » l11-c03
      » skip » l13-c03
   l11-c03
      » x := (x + 5) » l08-c22
   l13-c03
      » x := (x + 3) » l08-c22
   l15-c01
      » x > (2 * z) » l16-c00
      » x <= (2 * z) » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state ~assert)
           (<= x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |0|))
      (and (= state l16-c00)
           (> x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |1|))
      (and (= state l15-c01)
           (>= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |2|))
      (and (= state l13-c03) a!1 (= state$ l10-c02) (= transition$ |3|))
      (and (= state l11-c03) a!1 (= state$ l10-c02) (= transition$ |4|))
      (and (= state l10-c02)
           (< y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |5|))
      (and (= state l08-c22)
           (= x (+ x$ 5))
           (= y y$)
           (= z z$)
           (= state$ l11-c03)
           (= transition$ |6|))
      (and (= state l08-c22)
           (= x (+ x$ 3))
           (= y y$)
           (= z z$)
           (= state$ l13-c03)
           (= transition$ |7|))
      (and (= state l08-c13)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |8|))
      (and (= state l08-c13)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l08-c06)
           (= transition$ |9|))
      (and (= state l08-c06)
           (= x 1)
           (= y y$)
           (= z z$)
           (= state$ l07-c01)
           (= transition$ |10|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/relational.c with bound 25
=============================
Automaton:
   relational
3 variables:
   x, y, z
10 locations:
   l07-c01, l08-c06, l08-c13, l08-c22, l10-c02, l11-c03, l13-c03, l15-c01,
   l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c06
   l08-c06
      » y := 0 » l08-c13
   l08-c13
      » y < z » l10-c02
      » y >= z » l15-c01
   l08-c22
      » y := (y + 1) » l08-c13
   l10-c02
      » skip » l11-c03
      » skip » l13-c03
   l11-c03
      » x := (x + 5) » l08-c22
   l13-c03
      » x := (x + 3) » l08-c22
   l15-c01
      » x > (2 * z) » l16-c00
      » x <= (2 * z) » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state ~assert)
           (<= x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |0|))
      (and (= state l16-c00)
           (> x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |1|))
      (and (= state l15-c01)
           (>= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |2|))
      (and (= state l13-c03) a!1 (= state$ l10-c02) (= transition$ |3|))
      (and (= state l11-c03) a!1 (= state$ l10-c02) (= transition$ |4|))
      (and (= state l10-c02)
           (< y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |5|))
      (and (= state l08-c22)
           (= x (+ x$ 5))
           (= y y$)
           (= z z$)
           (= state$ l11-c03)
           (= transition$ |6|))
      (and (= state l08-c22)
           (= x (+ x$ 3))
           (= y y$)
           (= z z$)
           (= state$ l13-c03)
           (= transition$ |7|))
      (and (= state l08-c13)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |8|))
      (and (= state l08-c13)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l08-c06)
           (= transition$ |9|))
      (and (= state l08-c06)
           (= x 1)
           (= y y$)
           (= z z$)
           (= state$ l07-c01)
           (= transition$ |10|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/relational.c with bound 100
=============================
Automaton:
   relational
3 variables:
   x, y, z
10 locations:
   l07-c01, l08-c06, l08-c13, l08-c22, l10-c02, l11-c03, l13-c03, l15-c01,
   l16-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c06
   l08-c06
      » y := 0 » l08-c13
   l08-c13
      » y < z » l10-c02
      » y >= z » l15-c01
   l08-c22
      » y := (y + 1) » l08-c13
   l10-c02
      » skip » l11-c03
      » skip » l13-c03
   l11-c03
      » x := (x + 5) » l08-c22
   l13-c03
      » x := (x + 3) » l08-c22
   l15-c01
      » x > (2 * z) » l16-c00
      » x <= (2 * z) » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (let ((a!1 (and true (= x x$) (= y y$) (= z z$))))
  (or (and (= state ~assert)
           (<= x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |0|))
      (and (= state l16-c00)
           (> x (* 2 z))
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l15-c01)
           (= transition$ |1|))
      (and (= state l15-c01)
           (>= y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |2|))
      (and (= state l13-c03) a!1 (= state$ l10-c02) (= transition$ |3|))
      (and (= state l11-c03) a!1 (= state$ l10-c02) (= transition$ |4|))
      (and (= state l10-c02)
           (< y z)
           (= x x$)
           (= y y$)
           (= z z$)
           (= state$ l08-c13)
           (= transition$ |5|))
      (and (= state l08-c22)
           (= x (+ x$ 5))
           (= y y$)
           (= z z$)
           (= state$ l11-c03)
           (= transition$ |6|))
      (and (= state l08-c22)
           (= x (+ x$ 3))
           (= y y$)
           (= z z$)
           (= state$ l13-c03)
           (= transition$ |7|))
      (and (= state l08-c13)
           (= y (+ y$ 1))
           (= x x$)
           (= z z$)
           (= state$ l08-c22)
           (= transition$ |8|))
      (and (= state l08-c13)
           (= y 0)
           (= x x$)
           (= z z$)
           (= state$ l08-c06)
           (= transition$ |9|))
      (and (= state l08-c06)
           (= x 1)
           (= y y$)
           (= z z$)
           (= state$ l07-c01)
           (= transition$ |10|))))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: All paths to l07-c01 are unfeasible.
Depth   7: All paths to l07-c01 are unfeasible.
Depth   8: All paths to l07-c01 are unfeasible.
Depth   9: All paths to l07-c01 are unfeasible.
Depth  10: All paths to l07-c01 are unfeasible.
Depth  11: All paths to l07-c01 are unfeasible.
Depth  12: All paths to l07-c01 are unfeasible.
Depth  13: All paths to l07-c01 are unfeasible.
Depth  14: All paths to l07-c01 are unfeasible.
Depth  15: All paths to l07-c01 are unfeasible.
Depth  16: All paths to l07-c01 are unfeasible.
Depth  17: All paths to l07-c01 are unfeasible.
Depth  18: All paths to l07-c01 are unfeasible.
Depth  19: All paths to l07-c01 are unfeasible.
Depth  20: All paths to l07-c01 are unfeasible.
Depth  21: All paths to l07-c01 are unfeasible.
Depth  22: All paths to l07-c01 are unfeasible.
Depth  23: All paths to l07-c01 are unfeasible.
Depth  24: All paths to l07-c01 are unfeasible.
Depth  25: All paths to l07-c01 are unfeasible.
Depth  26: All paths to l07-c01 are unfeasible.
Depth  27: All paths to l07-c01 are unfeasible.
Depth  28: All paths to l07-c01 are unfeasible.
Depth  29: All paths to l07-c01 are unfeasible.
Depth  30: All paths to l07-c01 are unfeasible.
Depth  31: All paths to l07-c01 are unfeasible.
Depth  32: All paths to l07-c01 are unfeasible.
Depth  33: All paths to l07-c01 are unfeasible.
Depth  34: All paths to l07-c01 are unfeasible.
Depth  35: All paths to l07-c01 are unfeasible.
Depth  36: All paths to l07-c01 are unfeasible.
Depth  37: All paths to l07-c01 are unfeasible.
Depth  38: All paths to l07-c01 are unfeasible.
Depth  39: All paths to l07-c01 are unfeasible.
Depth  40: All paths to l07-c01 are unfeasible.
Depth  41: All paths to l07-c01 are unfeasible.
Depth  42: All paths to l07-c01 are unfeasible.
Depth  43: All paths to l07-c01 are unfeasible.
Depth  44: All paths to l07-c01 are unfeasible.
Depth  45: All paths to l07-c01 are unfeasible.
Depth  46: All paths to l07-c01 are unfeasible.
Depth  47: All paths to l07-c01 are unfeasible.
Depth  48: All paths to l07-c01 are unfeasible.
Depth  49: All paths to l07-c01 are unfeasible.
Depth  50: All paths to l07-c01 are unfeasible.
Depth  51: All paths to l07-c01 are unfeasible.
Depth  52: All paths to l07-c01 are unfeasible.
Depth  53: All paths to l07-c01 are unfeasible.
Depth  54: All paths to l07-c01 are unfeasible.
Depth  55: All paths to l07-c01 are unfeasible.
Depth  56: All paths to l07-c01 are unfeasible.
Depth  57: All paths to l07-c01 are unfeasible.
Depth  58: All paths to l07-c01 are unfeasible.
Depth  59: All paths to l07-c01 are unfeasible.
Depth  60: All paths to l07-c01 are unfeasible.
Depth  61: All paths to l07-c01 are unfeasible.
Depth  62: All paths to l07-c01 are unfeasible.
Depth  63: All paths to l07-c01 are unfeasible.
Depth  64: All paths to l07-c01 are unfeasible.
Depth  65: All paths to l07-c01 are unfeasible.
Depth  66: All paths to l07-c01 are unfeasible.
Depth  67: All paths to l07-c01 are unfeasible.
Depth  68: All paths to l07-c01 are unfeasible.
Depth  69: All paths to l07-c01 are unfeasible.
Depth  70: All paths to l07-c01 are unfeasible.
Depth  71: All paths to l07-c01 are unfeasible.
Depth  72: All paths to l07-c01 are unfeasible.
Depth  73: All paths to l07-c01 are unfeasible.
Depth  74: All paths to l07-c01 are unfeasible.
Depth  75: All paths to l07-c01 are unfeasible.
Depth  76: All paths to l07-c01 are unfeasible.
Depth  77: All paths to l07-c01 are unfeasible.
Depth  78: All paths to l07-c01 are unfeasible.
Depth  79: All paths to l07-c01 are unfeasible.
Depth  80: All paths to l07-c01 are unfeasible.
Depth  81: All paths to l07-c01 are unfeasible.
Depth  82: All paths to l07-c01 are unfeasible.
Depth  83: All paths to l07-c01 are unfeasible.
Depth  84: All paths to l07-c01 are unfeasible.
Depth  85: All paths to l07-c01 are unfeasible.
Depth  86: All paths to l07-c01 are unfeasible.
Depth  87: All paths to l07-c01 are unfeasible.
Depth  88: All paths to l07-c01 are unfeasible.
Depth  89: All paths to l07-c01 are unfeasible.
Depth  90: All paths to l07-c01 are unfeasible.
Depth  91: All paths to l07-c01 are unfeasible.
Depth  92: All paths to l07-c01 are unfeasible.
Depth  93: All paths to l07-c01 are unfeasible.
Depth  94: All paths to l07-c01 are unfeasible.
Depth  95: All paths to l07-c01 are unfeasible.
Depth  96: All paths to l07-c01 are unfeasible.
Depth  97: All paths to l07-c01 are unfeasible.
Depth  98: All paths to l07-c01 are unfeasible.
Depth  99: All paths to l07-c01 are unfeasible.
Depth 100: All paths to l07-c01 are unfeasible.
Depth 101: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/running_example.c with bound 5
=============================
Automaton:
   running
2 variables:
   x, y
10 locations:
   l07-c01, l08-c01, l09-c02, l11-c02, l13-c03, l14-c03, l16-c01, l17-c01,
   l18-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c01
   l08-c01
      » y <= 10 » l09-c02
      » y > 10 » l11-c02
   l09-c02
      » y := 10 » l16-c01
   l11-c02
      » x < y » l13-c03
      » x >= y » l16-c01
   l13-c03
      » x := (2 * x) » l14-c03
   l14-c03
      » y := (y - 1) » l11-c02
   l16-c01
      » x := (y + 1) » l17-c01
   l17-c01
      » x > 0 » l18-c00
      » x <= 0 » ~assert

Bounded model checking: backward, depth <= 5

Step formula:
  (or (and (= state ~assert)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |0|))
    (and (= state l18-c00)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |1|))
    (and (= state l17-c01)
         (= x (+ y 1))
         (= y y$)
         (= state$ l16-c01)
         (= transition$ |2|))
    (and (= state l16-c01)
         (= y 10)
         (= x x$)
         (= state$ l09-c02)
         (= transition$ |3|))
    (and (= state l16-c01)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |4|))
    (and (= state l14-c03)
         (= x (* 2 x$))
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |5|))
    (and (= state l13-c03)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |6|))
    (and (= state l11-c02)
         (= y (- y$ 1))
         (= x x$)
         (= state$ l14-c03)
         (= transition$ |7|))
    (and (= state l11-c02)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |8|))
    (and (= state l09-c02)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |9|))
    (and (= state l08-c01)
         (= x 1)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |10|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: Bound exceeded.

Feasible path:
   None, not exhaustive

Final location ~assert reachable from initial location l07-c01: Unknown

=============================
prg/running_example.c with bound 25
=============================
Automaton:
   running
2 variables:
   x, y
10 locations:
   l07-c01, l08-c01, l09-c02, l11-c02, l13-c03, l14-c03, l16-c01, l17-c01,
   l18-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c01
   l08-c01
      » y <= 10 » l09-c02
      » y > 10 » l11-c02
   l09-c02
      » y := 10 » l16-c01
   l11-c02
      » x < y » l13-c03
      » x >= y » l16-c01
   l13-c03
      » x := (2 * x) » l14-c03
   l14-c03
      » y := (y - 1) » l11-c02
   l16-c01
      » x := (y + 1) » l17-c01
   l17-c01
      » x > 0 » l18-c00
      » x <= 0 » ~assert

Bounded model checking: backward, depth <= 25

Step formula:
  (or (and (= state ~assert)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |0|))
    (and (= state l18-c00)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |1|))
    (and (= state l17-c01)
         (= x (+ y 1))
         (= y y$)
         (= state$ l16-c01)
         (= transition$ |2|))
    (and (= state l16-c01)
         (= y 10)
         (= x x$)
         (= state$ l09-c02)
         (= transition$ |3|))
    (and (= state l16-c01)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |4|))
    (and (= state l14-c03)
         (= x (* 2 x$))
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |5|))
    (and (= state l13-c03)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |6|))
    (and (= state l11-c02)
         (= y (- y$ 1))
         (= x x$)
         (= state$ l14-c03)
         (= transition$ |7|))
    (and (= state l11-c02)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |8|))
    (and (= state l09-c02)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |9|))
    (and (= state l08-c01)
         (= x 1)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |10|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c01: No

=============================
prg/running_example.c with bound 100
=============================
Automaton:
   running
2 variables:
   x, y
10 locations:
   l07-c01, l08-c01, l09-c02, l11-c02, l13-c03, l14-c03, l16-c01, l17-c01,
   l18-c00, ~assert
Initial location:
   l07-c01
Final location:
   ~assert
Transitions:
   l07-c01
      » x := 1 » l08-c01
   l08-c01
      » y <= 10 » l09-c02
      » y > 10 » l11-c02
   l09-c02
      » y := 10 » l16-c01
   l11-c02
      » x < y » l13-c03
      » x >= y » l16-c01
   l13-c03
      » x := (2 * x) » l14-c03
   l14-c03
      » y := (y - 1) » l11-c02
   l16-c01
      » x := (y + 1) » l17-c01
   l17-c01
      » x > 0 » l18-c00
      » x <= 0 » ~assert

Bounded model checking: backward, depth <= 100

Step formula:
  (or (and (= state ~assert)
         (<= x 0)
         (= x x$)
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |0|))
    (and (= state l18-c00)
         (> x 0)
         (= x x$)
         (= y y$)
         (= state$ l17-c01)
         (= transition$ |1|))
    (and (= state l17-c01)
         (= x (+ y 1))
         (= y y$)
         (= state$ l16-c01)
         (= transition$ |2|))
    (and (= state l16-c01)
         (= y 10)
         (= x x$)
         (= state$ l09-c02)
         (= transition$ |3|))
    (and (= state l16-c01)
         (>= x y)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |4|))
    (and (= state l14-c03)
         (= x (* 2 x$))
         (= y y$)
         (= state$ l13-c03)
         (= transition$ |5|))
    (and (= state l13-c03)
         (< x y)
         (= x x$)
         (= y y$)
         (= state$ l11-c02)
         (= transition$ |6|))
    (and (= state l11-c02)
         (= y (- y$ 1))
         (= x x$)
         (= state$ l14-c03)
         (= transition$ |7|))
    (and (= state l11-c02)
         (> y 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |8|))
    (and (= state l09-c02)
         (<= y 10)
         (= x x$)
         (= y y$)
         (= state$ l08-c01)
         (= transition$ |9|))
    (and (= state l08-c01)
         (= x 1)
         (= y y$)
         (= state$ l07-c01)
         (= transition$ |10|)))

Depth   1: All paths to l07-c01 are unfeasible.
Depth   2: All paths to l07-c01 are unfeasible.
Depth   3: All paths to l07-c01 are unfeasible.
Depth   4: All paths to l07-c01 are unfeasible.
Depth   5: All paths to l07-c01 are unfeasible.
Depth   6: No feasible path of length 6. Exhaustive check.

Feasible path:
   None, exhaustive

Final location ~assert reachable from initial location l07-c01: No

